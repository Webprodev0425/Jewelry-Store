           // when the user is typing something generic.  Consider the case where the user types:
            //
            //      Foo<number
            //
            // From the lexical classifier's perspective, 'number' is a keyword, and so the word will
            // be classified as such.  However, from the syntactic classifier's tree-based perspective
            // this is simply an expression with the identifier 'number' on the RHS of the less than
            // token.  So the classification will go back to being an identifier.  The moment the user
            // types again, number will become a keyword, then an identifier, etc. etc.
            //
            // To try to avoid this problem, we avoid classifying contextual keywords as keywords
            // when the user is potentially typing something generic.  We just can't do a good enough
            // job at the lexical level, and so well leave it up to the syntactic classifier to make
            // the determination.
            //
            // In order to determine if the user is potentially typing something generic, we use a
            // weak heuristic where we track < and > tokens.  It's a weak heuristic, but should
            // work well enough in practice.
            var angleBracketStack = 0;
            do {
                token = scanner.scan();
                if (!ts.isTrivia(token)) {
                    handleToken();
                    lastNonTriviaToken = token;
                }
                var end = scanner.getTextPos();
                pushEncodedClassification(scanner.getTokenPos(), end, offset, classFromKind(token), spans);
                if (end >= text.length) {
                    var end_1 = getNewEndOfLineState(scanner, token, ts.lastOrUndefined(templateStack));
                    if (end_1 !== undefined) {
                        endOfLineState = end_1;
                    }
                }
            } while (token !== 1 /* EndOfFileToken */);
            function handleToken() {
                switch (token) {
                    case 43 /* SlashToken */:
                    case 68 /* SlashEqualsToken */:
                        if (!noRegexTable[lastNonTriviaToken] && scanner.reScanSlashToken() === 13 /* RegularExpressionLiteral */) {
                            token = 13 /* RegularExpressionLiteral */;
                        }
                        break;
                    case 29 /* LessThanToken */:
                        if (lastNonTriviaToken === 79 /* Identifier */) {
                            // Could be the start of something generic.  Keep track of that by bumping
                            // up the current count of generic contexts we may be in.
                            angleBracketStack++;
                        }
                        break;
                    case 31 /* GreaterThanToken */:
                        if (angleBracketStack > 0) {
                            // If we think we're currently in something generic, then mark that that
                            // generic entity is complete.
                            angleBracketStack--;
                        }
                        break;
                    case 129 /* AnyKeyword */:
                    case 148 /* StringKeyword */:
                    case 145 /* NumberKeyword */:
                    case 132 /* BooleanKeyword */:
                    case 149 /* SymbolKeyword */:
                        if (angleBracketStack > 0 && !syntacticClassifierAbsent) {
                            // If it looks like we're could be in something generic, don't classify this
                            // as a keyword.  We may just get overwritten by the syntactic classifier,
                            // causing a noisy experience for the user.
                            token = 79 /* Identifier */;
                        }
                        break;
                    case 15 /* TemplateHead */:
                        templateStack.push(token);
                        break;
                    case 18 /* OpenBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            templateStack.push(token);
                        }
                        break;
                    case 19 /* CloseBraceToken */:
                        // If we don't have anything on the template stack,
                        // then we aren't trying to keep track of a previously scanned template head.
                        if (templateStack.length > 0) {
                            var lastTemplateStackToken = ts.lastOrUndefined(templateStack);
                            if (lastTemplateStackToken === 15 /* TemplateHead */) {
                                token = scanner.reScanTemplateToken(/* isTaggedTemplate */ false);
                                // Only pop on a TemplateTail; a TemplateMiddle indicates there is more for us.
                                if (token === 17 /* TemplateTail */) {
                                    templateStack.pop();
                                }
                                else {
                                    ts.Debug.assertEqual(token, 16 /* TemplateMiddle */, "Should have been a template middle.");
                                }
                            }
                            else {
                                ts.Debug.assertEqual(lastTemplateStackToken, 18 /* OpenBraceToken */, "Should have been an open brace");
                                templateStack.pop();
                            }
                        }
                        break;
                    default:
                        if (!ts.isKeyword(token)) {
                            break;
                        }
                        if (lastNonTriviaToken === 24 /* DotToken */) {
                            token = 79 /* Identifier */;
                        }
                        else if (ts.isKeyword(lastNonTriviaToken) && ts.isKeyword(token) && !canFollow(lastNonTriviaToken, token)) {
                            // We have two keywords in a row.  Only treat the second as a keyword if
                            // it's a sequence that could legally occur in the language.  Otherwise
                            // treat it as an identifier.  This way, if someone writes "private var"
                            // we recognize that 'var' is actually an identifier here.
                            token = 79 /* Identifier */;
                        }
                }
            }
            return { endOfLineState: endOfLineState, spans: spans };
        }
        return { getClassificationsForLine: getClassificationsForLine, getEncodedLexicalClassifications: getEncodedLexicalClassifications };
    }
    ts.createClassifier = createClassifier;
    /// We do not have a full parser support to know when we should parse a regex or not
    /// If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
    /// we have a series of divide operator. this list allows us to be more accurate by ruling out
    /// locations where a regexp cannot exist.
    var noRegexTable = ts.arrayToNumericMap([
        79 /* Identifier */,
        10 /* StringLiteral */,
        8 /* NumericLiteral */,
        9 /* BigIntLiteral */,
        13 /* RegularExpressionLiteral */,
        108 /* ThisKeyword */,
        45 /* PlusPlusToken */,
        46 /* MinusMinusToken */,
        21 /* CloseParenToken */,
        23 /* CloseBracketToken */,
        19 /* CloseBraceToken */,
        110 /* TrueKeyword */,
        95 /* FalseKeyword */,
    ], function (token) { return token; }, function () { return true; });
    function getNewEndOfLineState(scanner, token, lastOnTemplateStack) {
        switch (token) {
            case 10 /* StringLiteral */: {
                // Check to see if we finished up on a multiline string literal.
                if (!scanner.isUnterminated())
                    return undefined;
                var tokenText = scanner.getTokenText();
                var lastCharIndex = tokenText.length - 1;
                var numBackslashes = 0;
                while (tokenText.charCodeAt(lastCharIndex - numBackslashes) === 92 /* backslash */) {
                    numBackslashes++;
                }
                // If we have an odd number of backslashes, then the multiline string is unclosed
                if ((numBackslashes & 1) === 0)
                    return undefined;
                return tokenText.charCodeAt(0) === 34 /* doubleQuote */ ? 3 /* InDoubleQuoteStringLiteral */ : 2 /* InSingleQuoteStringLiteral */;
            }
            case 3 /* MultiLineCommentTrivia */:
                // Check to see if the multiline comment was unclosed.
                return scanner.isUnterminated() ? 1 /* InMultiLineCommentTrivia */ : undefined;
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    if (!scanner.isUnterminated()) {
                        return undefined;
                    }
                    switch (token) {
                        case 17 /* TemplateTail */:
                            return 5 /* InTemplateMiddleOrTail */;
                        case 14 /* NoSubstitutionTemplateLiteral */:
                            return 4 /* InTemplateHeadOrNoSubstitutionTemplate */;
                        default:
                            return ts.Debug.fail("Only 'NoSubstitutionTemplateLiteral's and 'TemplateTail's can be unterminated; got SyntaxKind #" + token);
                    }
                }
                return lastOnTemplateStack === 15 /* TemplateHead */ ? 6 /* InTemplateSubstitutionPosition */ : undefined;
        }
    }
    function pushEncodedClassification(start, end, offset, classification, result) {
        if (classification === 8 /* whiteSpace */) {
            // Don't bother with whitespace classifications.  They're not needed.
            return;
        }
        if (start === 0 && offset > 0) {
            // We're classifying the first token, and this was a case where we prepended text.
            // We should consider the start of this token to be at the start of the original text.
            start += offset;
        }
        var length = end - start;
        if (length > 0) {
            // All our tokens are in relation to the augmented text.  Move them back to be
            // relative to the original text.
            result.push(start - offset, length, classification);
        }
    }
    function convertClassificationsToResult(classifications, text) {
        var entries = [];
        var dense = classifications.spans;
        var lastEnd = 0;
        for (var i = 0; i < dense.length; i += 3) {
            var start = dense[i];
            var length_1 = dense[i + 1];
            var type = dense[i + 2];
            // Make a whitespace entry between the last item and this one.
            if (lastEnd >= 0) {
                var whitespaceLength_1 = start - lastEnd;
                if (whitespaceLength_1 > 0) {
                    entries.push({ length: whitespaceLength_1, classification: ts.TokenClass.Whitespace });
                }
            }
            entries.push({ length: length_1, classification: convertClassification(type) });
            lastEnd = start + length_1;
        }
        var whitespaceLength = text.length - lastEnd;
        if (whitespaceLength > 0) {
            entries.push({ length: whitespaceLength, classification: ts.TokenClass.Whitespace });
        }
        return { entries: entries, finalLexState: classifications.endOfLineState };
    }
    function convertClassification(type) {
        switch (type) {
            case 1 /* comment */: return ts.TokenClass.Comment;
            case 3 /* keyword */: return ts.TokenClass.Keyword;
            case 4 /* numericLiteral */: return ts.TokenClass.NumberLiteral;
            case 25 /* bigintLiteral */: return ts.TokenClass.BigIntLiteral;
            case 5 /* operator */: return ts.TokenClass.Operator;
            case 6 /* stringLiteral */: return ts.TokenClass.StringLiteral;
            case 8 /* whiteSpace */: return ts.TokenClass.Whitespace;
            case 10 /* punctuation */: return ts.TokenClass.Punctuation;
            case 2 /* identifier */:
            case 11 /* className */:
            case 12 /* enumName */:
            case 13 /* interfaceName */:
            case 14 /* moduleName */:
            case 15 /* typeParameterName */:
            case 16 /* typeAliasName */:
            case 9 /* text */:
            case 17 /* parameterName */:
                return ts.TokenClass.Identifier;
            default:
                return undefined; // TODO: GH#18217 Debug.assertNever(type);
        }
    }
    /** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
    function canFollow(keyword1, keyword2) {
        if (!ts.isAccessibilityModifier(keyword1)) {
            // Assume any other keyword combination is legal.
            // This can be refined in the future if there are more cases we want the classifier to be better at.
            return true;
        }
        switch (keyword2) {
            case 135 /* GetKeyword */:
            case 147 /* SetKeyword */:
            case 133 /* ConstructorKeyword */:
            case 124 /* StaticKeyword */:
                return true; // Allow things like "public get", "public constructor" and "public static".
            default:
                return false; // Any other keyword following "public" is actually an identifier, not a real keyword.
        }
    }
    function getPrefixFromLexState(lexState) {
        // If we're in a string literal, then prepend: "\
        // (and a newline).  That way when we lex we'll think we're still in a string literal.
        //
        // If we're in a multiline comment, then prepend: /*
        // (and a newline).  That way when we lex we'll think we're still in a multiline comment.
        switch (lexState) {
            case 3 /* InDoubleQuoteStringLiteral */:
                return { prefix: "\"\\\n" };
            case 2 /* InSingleQuoteStringLiteral */:
                return { prefix: "'\\\n" };
            case 1 /* InMultiLineCommentTrivia */:
                return { prefix: "/*\n" };
            case 4 /* InTemplateHeadOrNoSubstitutionTemplate */:
                return { prefix: "`\n" };
            case 5 /* InTemplateMiddleOrTail */:
                return { prefix: "}\n", pushTemplate: true };
            case 6 /* InTemplateSubstitutionPosition */:
                return { prefix: "", pushTemplate: true };
            case 0 /* None */:
                return { prefix: "" };
            default:
                return ts.Debug.assertNever(lexState);
        }
    }
    function isBinaryExpressionOperatorToken(token) {
        switch (token) {
            case 41 /* AsteriskToken */:
            case 43 /* SlashToken */:
            case 44 /* PercentToken */:
            case 39 /* PlusToken */:
            case 40 /* MinusToken */:
            case 47 /* LessThanLessThanToken */:
            case 48 /* GreaterThanGreaterThanToken */:
            case 49 /* GreaterThanGreaterThanGreaterThanToken */:
            case 29 /* LessThanToken */:
            case 31 /* GreaterThanToken */:
            case 32 /* LessThanEqualsToken */:
            case 33 /* GreaterThanEqualsToken */:
            case 102 /* InstanceOfKeyword */:
            case 101 /* InKeyword */:
            case 127 /* AsKeyword */:
            case 34 /* EqualsEqualsToken */:
            case 35 /* ExclamationEqualsToken */:
            case 36 /* EqualsEqualsEqualsToken */:
            case 37 /* ExclamationEqualsEqualsToken */:
            case 50 /* AmpersandToken */:
            case 52 /* CaretToken */:
            case 51 /* BarToken */:
            case 55 /* AmpersandAmpersandToken */:
            case 56 /* BarBarToken */:
            case 74 /* BarEqualsToken */:
            case 73 /* AmpersandEqualsToken */:
            case 78 /* CaretEqualsToken */:
            case 70 /* LessThanLessThanEqualsToken */:
            case 71 /* GreaterThanGreaterThanEqualsToken */:
            case 72 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
            case 64 /* PlusEqualsToken */:
            case 65 /* MinusEqualsToken */:
            case 66 /* AsteriskEqualsToken */:
            case 68 /* SlashEqualsToken */:
            case 69 /* PercentEqualsToken */:
            case 63 /* EqualsToken */:
            case 27 /* CommaToken */:
            case 60 /* QuestionQuestionToken */:
            case 75 /* BarBarEqualsToken */:
            case 76 /* AmpersandAmpersandEqualsToken */:
            case 77 /* QuestionQuestionEqualsToken */:
                return true;
            default:
                return false;
        }
    }
    function isPrefixUnaryExpressionOperatorToken(token) {
        switch (token) {
            case 39 /* PlusToken */:
            case 40 /* MinusToken */:
            case 54 /* TildeToken */:
            case 53 /* ExclamationToken */:
            case 45 /* PlusPlusToken */:
            case 46 /* MinusMinusToken */:
                return true;
            default:
                return false;
        }
    }
    function classFromKind(token) {
        if (ts.isKeyword(token)) {
            return 3 /* keyword */;
        }
        else if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
            return 5 /* operator */;
        }
        else if (token >= 18 /* FirstPunctuation */ && token <= 78 /* LastPunctuation */) {
            return 10 /* punctuation */;
        }
        switch (token) {
            case 8 /* NumericLiteral */:
                return 4 /* numericLiteral */;
            case 9 /* BigIntLiteral */:
                return 25 /* bigintLiteral */;
            case 10 /* StringLiteral */:
                return 6 /* stringLiteral */;
            case 13 /* RegularExpressionLiteral */:
                return 7 /* regularExpressionLiteral */;
            case 7 /* ConflictMarkerTrivia */:
            case 3 /* MultiLineCommentTrivia */:
            case 2 /* SingleLineCommentTrivia */:
                return 1 /* comment */;
            case 5 /* WhitespaceTrivia */:
            case 4 /* NewLineTrivia */:
                return 8 /* whiteSpace */;
            case 79 /* Identifier */:
            default:
                if (ts.isTemplateLiteralKind(token)) {
                    return 6 /* stringLiteral */;
                }
                return 2 /* identifier */;
        }
    }
    /* @internal */
    function getSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        return convertClassificationsToSpans(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));
    }
    ts.getSemanticClassifications = getSemanticClassifications;
    function checkForClassificationCancellation(cancellationToken, kind) {
        // We don't want to actually call back into our host on every node to find out if we've
        // been canceled.  That would be an enormous amount of chattyness, along with the all
        // the overhead of marshalling the data to/from the host.  So instead we pick a few
        // reasonable node kinds to bother checking on.  These node kinds represent high level
        // constructs that we would expect to see commonly, but just at a far less frequent
        // interval.
        //
        // For example, in checker.ts (around 750k) we only have around 600 of these constructs.
        // That means we're calling back into the host around every 1.2k of the file we process.
        // Lib.d.ts has similar numbers.
        switch (kind) {
            case 259 /* ModuleDeclaration */:
            case 255 /* ClassDeclaration */:
            case 256 /* InterfaceDeclaration */:
            case 254 /* FunctionDeclaration */:
            case 224 /* ClassExpression */:
            case 211 /* FunctionExpression */:
            case 212 /* ArrowFunction */:
                cancellationToken.throwIfCancellationRequested();
        }
    }
    /* @internal */
    function getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
        var spans = [];
        sourceFile.forEachChild(function cb(node) {
            // Only walk into nodes that intersect the requested span.
            if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth())) {
                return;
            }
            checkForClassificationCancellation(cancellationToken, node.kind);
            // Only bother calling into the typechecker if this is an identifier that
            // could possibly resolve to a type name.  This makes classification run
            // in a third of the time it would normally take.
            if (ts.isIdentifier(node) && !ts.nodeIsMissing(node) && classifiableNames.has(node.escapedText)) {
                var symbol = typeChecker.getSymbolAtLocation(node);
                var type = symbol && classifySymbol(symbol, ts.getMeaningFromLocation(node), typeChecker);
                if (type) {
                    pushClassification(node.getStart(sourceFile), node.getEnd(), type);
                }
            }
            node.forEachChild(cb);
        });
        return { spans: spans, endOfLineState: 0 /* None */ };
        function pushClassification(start, end, type) {
            var length = end - start;
            ts.Debug.assert(length > 0, "Classification had non-positive length of " + length);
            spans.push(start);
            spans.push(length);
            spans.push(type);
        }
    }
    ts.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
    function classifySymbol(symbol, meaningAtPosition, checker) {
        var flags = symbol.getFlags();
        if ((flags & 2885600 /* Classifiable */) === 0 /* None */) {
            return undefined;
        }
        else if (flags & 32 /* Class */) {
            return 11 /* className */;
        }
        else if (flags & 384 /* Enum */) {
            return 12 /* enumName */;
        }
        else if (flags & 524288 /* TypeAlias */) {
            return 16 /* typeAliasName */;
        }
        else if (flags & 1536 /* Module */) {
            // Only classify a module as such if
            //  - It appears in a namespace context.
            //  - There exists a module declaration which actually impacts the value side.
            return meaningAtPosition & 4 /* Namespace */ || meaningAtPosition & 1 /* Value */ && hasValueSideModule(symbol) ? 14 /* moduleName */ : undefined;
        }
        else if (flags & 2097152 /* Alias */) {
            return classifySymbol(checker.getAliasedSymbol(symbol), meaningAtPosition, checker);
        }
        else if (meaningAtPosition & 2 /* Type */) {
            return flags & 64 /* Interface */ ? 13 /* interfaceName */ : flags & 262144 /* TypeParameter */ ? 15 /* typeParameterName */ : undefined;
        }
        else {
            return undefined;
        }
    }
    /** Returns true if there exists a module that introduces entities on the value side. */
    function hasValueSideModule(symbol) {
        return ts.some(symbol.declarations, function (declaration) {
            return ts.isModuleDeclaration(declaration) && ts.getModuleInstanceState(declaration) === 1 /* Instantiated */;
        });
    }
    function getClassificationTypeName(type) {
        switch (type) {
            case 1 /* comment */: return "comment" /* comment */;
            case 2 /* identifier */: return "identifier" /* identifier */;
            case 3 /* keyword */: return "keyword" /* keyword */;
            case 4 /* numericLiteral */: return "number" /* numericLiteral */;
            case 25 /* bigintLiteral */: return "bigint" /* bigintLiteral */;
            case 5 /* operator */: return "operator" /* operator */;
            case 6 /* stringLiteral */: return "string" /* stringLiteral */;
            case 8 /* whiteSpace */: return "whitespace" /* whiteSpace */;
            case 9 /* text */: return "text" /* text */;
            case 10 /* punctuation */: return "punctuation" /* punctuation */;
            case 11 /* className */: return "class name" /* className */;
            case 12 /* enumName */: return "enum name" /* enumName */;
            case 13 /* interfaceName */: return "interface name" /* interfaceName */;
            case 14 /* moduleName */: return "module name" /* moduleName */;
            case 15 /* typeParameterName */: return "type parameter name" /* typeParameterName */;
            case 16 /* typeAliasName */: return "type alias name" /* typeAliasName */;
            case 17 /* parameterName */: return "parameter name" /* parameterName */;
            case 18 /* docCommentTagName */: return "doc comment tag name" /* docCommentTagName */;
            case 19 /* jsxOpenTagName */: return "jsx open tag name" /* jsxOpenTagName */;
            case 20 /* jsxCloseTagName */: return "jsx close tag name" /* jsxCloseTagName */;
            case 21 /* jsxSelfClosingTagName */: return "jsx self closing tag name" /* jsxSelfClosingTagName */;
            case 22 /* jsxAttribute */: return "jsx attribute" /* jsxAttribute */;
            case 23 /* jsxText */: return "jsx text" /* jsxText */;
            case 24 /* jsxAttributeStringLiteralValue */: return "jsx attribute string literal value" /* jsxAttributeStringLiteralValue */;
            default: return undefined; // TODO: GH#18217 throw Debug.assertNever(type);
        }
    }
    function convertClassificationsToSpans(classifications) {
        ts.Debug.assert(classifications.spans.length % 3 === 0);
        var dense = classifications.spans;
        var result = [];
        for (var i = 0; i < dense.length; i += 3) {
            result.push({
                textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
                classificationType: getClassificationTypeName(dense[i + 2])
            });
        }
        return result;
    }
    /* @internal */
    function getSyntacticClassifications(cancellationToken, sourceFile, span) {
        return convertClassificationsToSpans(getEncodedSyntacticClassifications(cancellationToken, sourceFile, span));
    }
    ts.getSyntacticClassifications = getSyntacticClassifications;
    /* @internal */
    function getEncodedSyntacticClassifications(cancellationToken, sourceFile, span) {
        var spanStart = span.start;
        var spanLength = span.length;
        // Make a scanner we can get trivia from.
        var triviaScanner = ts.createScanner(99 /* Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
        var mergeConflictScanner = ts.createScanner(99 /* Latest */, /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
        var result = [];
        processElement(sourceFile);
        return { spans: result, endOfLineState: 0 /* None */ };
        function pushClassification(start, length, type) {
            result.push(start);
            result.push(length);
            result.push(type);
        }
        function classifyLeadingTriviaAndGetTokenStart(token) {
            triviaScanner.setTextPos(token.pos);
            while (true) {
                var start = triviaScanner.getTextPos();
                // only bother scanning if we have something that could be trivia.
                if (!ts.couldStartTrivia(sourceFile.text, start)) {
                    return start;
                }
                var kind = triviaScanner.scan();
                var end = triviaScanner.getTextPos();
                var width = end - start;
                // The moment we get something that isn't trivia, then stop processing.
                if (!ts.isTrivia(kind)) {
                    return start;
                }
                switch (kind) {
                    case 4 /* NewLineTrivia */:
                    case 5 /* WhitespaceTrivia */:
                        // Don't bother with newlines/whitespace.
                        continue;
                    case 2 /* SingleLineCommentTrivia */:
                    case 3 /* MultiLineCommentTrivia */:
                        // Only bother with the trivia if it at least intersects the span of interest.
                        classifyComment(token, kind, start, width);
                        // Classifying a comment might cause us to reuse the trivia scanner
                        // (because of jsdoc comments).  So after we classify the comment make
                        // sure we set the scanner position back to where it needs to be.
                        triviaScanner.setTextPos(end);
                        continue;
                    case 7 /* ConflictMarkerTrivia */:
                        var text = sourceFile.text;
                        var ch = text.charCodeAt(start);
                        // for the <<<<<<< and >>>>>>> markers, we just add them in as comments
                        // in the classification stream.
                        if (ch === 60 /* lessThan */ || ch === 62 /* greaterThan */) {
                            pushClassification(start, width, 1 /* comment */);
                            continue;
                        }
                        // for the ||||||| and ======== markers, add a comment for the first line,
                        // and then lex all subsequent lines up until the end of the conflict marker.
                        ts.Debug.assert(ch === 124 /* bar */ || ch === 61 /* equals */);
                        classifyDisabledMergeCode(text, start, end);
                        break;
                    case 6 /* ShebangTrivia */:
                        // TODO: Maybe we should classify these.
                        break;
                    default:
                        ts.Debug.assertNever(kind);
                }
            }
        }
        function classifyComment(token, kind, start, width) {
            if (kind === 3 /* MultiLineCommentTrivia */) {
                // See if this is a doc comment.  If so, we'll classify certain portions of it
                // specially.
                var docCommentAndDiagnostics = ts.parseIsolatedJSDocComment(sourceFile.text, start, width);
                if (docCommentAndDiagnostics && docCommentAndDiagnostics.jsDoc) {
                    // TODO: This should be predicated on `token["kind"]` being compatible with `HasJSDoc["kind"]`
                    ts.setParent(docCommentAndDiagnostics.jsDoc, token);
                    classifyJSDocComment(docCommentAndDiagnostics.jsDoc);
                    return;
                }
            }
            else if (kind === 2 /* SingleLineCommentTrivia */) {
                if (tryClassifyTripleSlashComment(start, width)) {
                    return;
                }
            }
            // Simple comment.  Just add as is.
            pushCommentRange(start, width);
        }
        function pushCommentRange(start, width) {
            pushClassification(start, width, 1 /* comment */);
        }
        function classifyJSDocComment(docComment) {
            var _a, _b, _c, _d, _e, _f, _g;
            var pos = docComment.pos;
            if (docComment.tags) {
                for (var _i = 0, _h = docComment.tags; _i < _h.length; _i++) {
                    var tag = _h[_i];
                    // As we walk through each tag, classify the portion of text from the end of
                    // the last tag (or the start of the entire doc comment) as 'comment'.
                    if (tag.pos !== pos) {
                        pushCommentRange(pos, tag.pos - pos);
                    }
                    pushClassification(tag.pos, 1, 10 /* punctuation */); // "@"
                    pushClassification(tag.tagName.pos, tag.tagName.end - tag.tagName.pos, 18 /* docCommentTagName */); // e.g. "param"
                    pos = tag.tagName.end;
                    var commentStart = tag.tagName.end;
                    switch (tag.kind) {
                        case 335 /* JSDocParameterTag */:
                            var param = tag;
                            processJSDocParameterTag(param);
                            commentStart = param.isNameFirst && ((_a = param.typeExpression) === null || _a === void 0 ? void 0 : _a.end) || param.name.end;
                            break;
                        case 342 /* JSDocPropertyTag */:
                            var prop = tag;
                            commentStart = prop.isNameFirst && ((_b = prop.typeExpression) === null || _b === void 0 ? void 0 : _b.end) || prop.name.end;
                            break;
                        case 339 /* JSDocTemplateTag */:
                            processJSDocTemplateTag(tag);
                            pos = tag.end;
                            commentStart = tag.typeParameters.end;
                            break;
                        case 340 /* JSDocTypedefTag */:
                            var type = tag;
                            commentStart = ((_c = type.typeExpression) === null || _c === void 0 ? void 0 : _c.kind) === 304 /* JSDocTypeExpression */ && ((_d = type.fullName) === null || _d === void 0 ? void 0 : _d.end) || ((_e = type.typeExpression) === null || _e === void 0 ? void 0 : _e.end) || commentStart;
                            break;
                        case 333 /* JSDocCallbackTag */:
                            commentStart = tag.typeExpression.end;
                            break;
                        case 338 /* JSDocTypeTag */:
                            processElement(tag.typeExpression);
                            pos = tag.end;
                            commentStart = tag.typeExpression.end;
                            break;
                        case 337 /* JSDocThisTag */:
                        case 334 /* JSDocEnumTag */:
                            commentStart = tag.typeExpression.end;
                            break;
                        case 336 /* JSDocReturnTag */:
                            processElement(tag.typeExpression);
                            pos = tag.end;
                            commentStart = ((_f = tag.typeExpression) === null || _f === void 0 ? void 0 : _f.end) || commentStart;
                            break;
                        case 341 /* JSDocSeeTag */:
                            commentStart = ((_g = tag.name) === null || _g === void 0 ? void 0 : _g.end) || commentStart;
                            break;
                        case 323 /* JSDocAugmentsTag */:
                        case 324 /* JSDocImplementsTag */:
                            commentStart = tag.class.end;
                            break;
                    }
                    if (typeof tag.comment === "object") {
                        pushCommentRange(tag.comment.pos, tag.comment.end - tag.comment.pos);
                    }
                    else if (typeof tag.comment === "string") {
                        pushCommentRange(commentStart, tag.end - commentStart);
                    }
                }
            }
            if (pos !== docComment.end) {
                pushCommentRange(pos, docComment.end - pos);
            }
            return;
            function processJSDocParameterTag(tag) {
                if (tag.isNameFirst) {
                    pushCommentRange(pos, tag.name.pos - pos);
                    pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* parameterName */);
                    pos = tag.name.end;
                }
                if (tag.typeExpression) {
                    pushCommentRange(pos, tag.typeExpression.pos - pos);
                    processElement(tag.typeExpression);
                    pos = tag.typeExpression.end;
                }
                if (!tag.isNameFirst) {
                    pushCommentRange(pos, tag.name.pos - pos);
                    pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* parameterName */);
                    pos = tag.name.end;
                }
            }
        }
        function tryClassifyTripleSlashComment(start, width) {
            var tripleSlashXMLCommentRegEx = /^(\/\/\/\s*)(<)(?:(\S+)((?:[^/]|\/[^>])*)(\/>)?)?/im;
            // Require a leading whitespace character (the parser already does) to prevent terrible backtracking performance
            var attributeRegex = /(\s)(\S+)(\s*)(=)(\s*)('[^']+'|"[^"]+")/img;
            var text = sourceFile.text.substr(start, width);
            var match = tripleSlashXMLCommentRegEx.exec(text);
            if (!match) {
                return false;
            }
            // Limiting classification to exactly the elements and attributes
            // defined in `ts.commentPragmas` would be excessive, but we can avoid
            // some obvious false positives (e.g. in XML-like doc comments) by
            // checking the element name.
            // eslint-disable-next-line no-in-operator
            if (!match[3] || !(match[3] in ts.commentPragmas)) {
                return false;
            }
            var pos = start;
            pushCommentRange(pos, match[1].length); // ///
            pos += match[1].length;
            pushClassification(pos, match[2].length, 10 /* punctuation */); // <
            pos += match[2].length;
            pushClassification(pos, match[3].length, 21 /* jsxSelfClosingTagName */); // element name
            pos += match[3].length;
            var attrText = match[4];
            var attrPos = pos;
            while (true) {
                var attrMatch = attributeRegex.exec(attrText);
                if (!attrMatch) {
                    break;
                }
                var newAttrPos = pos + attrMatch.index + attrMatch[1].length; // whitespace
                if (newAttrPos > attrPos) {
                    pushCommentRange(attrPos, newAttrPos - attrPos);
                    attrPos = newAttrPos;
                }
                pushClassification(attrPos, attrMatch[2].length, 22 /* jsxAttribute */); // attribute name
                attrPos += attrMatch[2].length;
                if (attrMatch[3].length) {
                    pushCommentRange(attrPos, attrMatch[3].length); // whitespace
                    attrPos += attrMatch[3].length;
                }
                pushClassification(attrPos, attrMatch[4].length, 5 /* operator */); // =
                attrPos += attrMatch[4].length;
                if (attrMatch[5].length) {
                    pushCommentRange(attrPos, attrMatch[5].length); // whitespace
                    attrPos += attrMatch[5].length;
                }
                pushClassification(attrPos, attrMatch[6].length, 24 /* jsxAttributeStringLiteralValue */); // attribute value
                attrPos += attrMatch[6].length;
            }
            pos += match[4].length;
            if (pos > attrPos) {
                pushCommentRange(attrPos, pos - attrPos);
            }
            if (match[5]) {
                pushClassification(pos, match[5].length, 10 /* punctuation */); // />
                pos += match[5].length;
            }
            var end = start + width;
            if (pos < end) {
                pushCommentRange(pos, end - pos);
            }
            return true;
        }
        function processJSDocTemplateTag(tag) {
            for (var _i = 0, _a = tag.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                processElement(child);
            }
        }
        function classifyDisabledMergeCode(text, start, end) {
            // Classify the line that the ||||||| or ======= marker is on as a comment.
            // Then just lex all further tokens and add them to the result.
            var i;
            for (i = start; i < end; i++) {
                if (ts.isLineBreak(text.charCodeAt(i))) {
                    break;
                }
            }
            pushClassification(start, i - start, 1 /* comment */);
            mergeConflictScanner.setTextPos(i);
            while (mergeConflictScanner.getTextPos() < end) {
                classifyDisabledCodeToken();
            }
        }
        function classifyDisabledCodeToken() {
            var start = mergeConflictScanner.getTextPos();
            var tokenKind = mergeConflictScanner.scan();
            var end = mergeConflictScanner.getTextPos();
            var type = classifyTokenType(tokenKind);
            if (type) {
                pushClassification(start, end - start, type);
            }
        }
        /**
         * Returns true if node should be treated as classified and no further processing is required.
         * False will mean that node is not classified and traverse routine should recurse into node contents.
         */
        function tryClassifyNode(node) {
            if (ts.isJSDoc(node)) {
                return true;
            }
            if (ts.nodeIsMissing(node)) {
                return true;
            }
            var classifiedElementName = tryClassifyJsxElementName(node);
            if (!ts.isToken(node) && node.kind !== 11 /* JsxText */ && classifiedElementName === undefined) {
                return false;
            }
            var tokenStart = node.kind === 11 /* JsxText */ ? node.pos : classifyLeadingTriviaAndGetTokenStart(node);
            var tokenWidth = node.end - tokenStart;
            ts.Debug.assert(tokenWidth >= 0);
            if (tokenWidth > 0) {
                var type = classifiedElementName || classifyTokenType(node.kind, node);
                if (type) {
                    pushClassification(tokenStart, tokenWidth, type);
                }
            }
            return true;
        }
        function tryClassifyJsxElementName(token) {
            switch (token.parent && token.parent.kind) {
                case 278 /* JsxOpeningElement */:
                    if (token.parent.tagName === token) {
                        return 19 /* jsxOpenTagName */;
                    }
                    break;
                case 279 /* JsxClosingElement */:
                    if (token.parent.tagName === token) {
                        return 20 /* jsxCloseTagName */;
                    }
                    break;
                case 277 /* JsxSelfClosingElement */:
                    if (token.parent.tagName === token) {
                        return 21 /* jsxSelfClosingTagName */;
                    }
                    break;
                case 283 /* JsxAttribute */:
                    if (token.parent.name === token) {
                        return 22 /* jsxAttribute */;
                    }
                    break;
            }
            return undefined;
        }
        // for accurate classification, the actual token should be passed in.  however, for
        // cases like 'disabled merge code' classification, we just get the token kind and
        // classify based on that instead.
        function classifyTokenType(tokenKind, token) {
            if (ts.isKeyword(tokenKind)) {
                return 3 /* keyword */;
            }
            // Special case `<` and `>`: If they appear in a generic context they are punctuation,
            // not operators.
            if (tokenKind === 29 /* LessThanToken */ || tokenKind === 31 /* GreaterThanToken */) {
                // If the node owning the token has a type argument list or type parameter list, then
                // we can effectively assume that a '<' and '>' belong to those lists.
                if (token && ts.getTypeArgumentOrTypeParameterList(token.parent)) {
                    return 10 /* punctuation */;
                }
            }
            if (ts.isPunctuation(tokenKind)) {
                if (token) {
                    var parent = token.parent;
                    if (tokenKind === 63 /* EqualsToken */) {
                        // the '=' in a variable declaration is special cased here.
                        if (parent.kind === 252 /* VariableDeclaration */ ||
                            parent.kind === 165 /* PropertyDeclaration */ ||
                            parent.kind === 162 /* Parameter */ ||
                            parent.kind === 283 /* JsxAttribute */) {
                            return 5 /* operator */;
                        }
                    }
                    if (parent.kind === 219 /* BinaryExpression */ ||
                        parent.kind === 217 /* PrefixUnaryExpression */ ||
                        parent.kind === 218 /* PostfixUnaryExpression */ ||
                        parent.kind === 220 /* ConditionalExpression */) {
                        return 5 /* operator */;
                    }
                }
                return 10 /* punctuation */;
            }
            else if (tokenKind === 8 /* NumericLiteral */) {
                return 4 /* numericLiteral */;
            }
            else if (tokenKind === 9 /* BigIntLiteral */) {
                return 25 /* bigintLiteral */;
            }
            else if (tokenKind === 10 /* StringLiteral */) {
                return token && token.parent.kind === 283 /* JsxAttribute */ ? 24 /* jsxAttributeStringLiteralValue */ : 6 /* stringLiteral */;
            }
            else if (tokenKind === 13 /* RegularExpressionLiteral */) {
                // TODO: we should get another classification type for these literals.
                return 6 /* stringLiteral */;
            }
            else if (ts.isTemplateLiteralKind(tokenKind)) {
                // TODO (drosen): we should *also* get another classification type for these literals.
                return 6 /* stringLiteral */;
            }
            else if (tokenKind === 11 /* JsxText */) {
                return 23 /* jsxText */;
            }
            else if (tokenKind === 79 /* Identifier */) {
                if (token) {
                    switch (token.parent.kind) {
                        case 255 /* ClassDeclaration */:
                            if (token.parent.name === token) {
                                return 11 /* className */;
                            }
                            return;
                        case 161 /* TypeParameter */:
                            if (token.parent.name === token) {
                                return 15 /* typeParameterName */;
                            }
                            return;
                        case 256 /* InterfaceDeclaration */:
                            if (token.parent.name === token) {
                                return 13 /* interfaceName */;
                            }
                            return;
                        case 258 /* EnumDeclaration */:
                            if (token.parent.name === token) {
                                return 12 /* enumName */;
                            }
                            return;
                        case 259 /* ModuleDeclaration */:
                            if (token.parent.name === token) {
                                return 14 /* moduleName */;
                            }
                            return;
                        case 162 /* Parameter */:
                            if (token.parent.name === token) {
                                return ts.isThisIdentifier(token) ? 3 /* keyword */ : 17 /* parameterName */;
                            }
                            return;
                    }
                }
                return 2 /* identifier */;
            }
        }
        function processElement(element) {
            if (!element) {
                return;
            }
            // Ignore nodes that don't intersect the original span to classify.
            if (ts.decodedTextSpanIntersectsWith(spanStart, spanLength, element.pos, element.getFullWidth())) {
                checkForClassificationCancellation(cancellationToken, element.kind);
                for (var _i = 0, _a = element.getChildren(sourceFile); _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (!tryClassifyNode(child)) {
                        // Recurse into our child nodes.
                        processElement(child);
                    }
                }
            }
        }
    }
    ts.getEncodedSyntacticClassifications = getEncodedSyntacticClassifications;
})(ts || (ts = {}));
/** @internal */
var ts;
(function (ts) {
    var classifier;
    (function (classifier) {
        var v2020;
        (function (v2020) {
            var TokenEncodingConsts;
            (function (TokenEncodingConsts) {
                TokenEncodingConsts[TokenEncodingConsts["typeOffset"] = 8] = "typeOffset";
                TokenEncodingConsts[TokenEncodingConsts["modifierMask"] = 255] = "modifierMask";
            })(TokenEncodingConsts = v2020.TokenEncodingConsts || (v2020.TokenEncodingConsts = {}));
            var TokenType;
            (function (TokenType) {
                TokenType[TokenType["class"] = 0] = "class";
                TokenType[TokenType["enum"] = 1] = "enum";
                TokenType[TokenType["interface"] = 2] = "interface";
                TokenType[TokenType["namespace"] = 3] = "namespace";
                TokenType[TokenType["typeParameter"] = 4] = "typeParameter";
                TokenType[TokenType["type"] = 5] = "type";
                TokenType[TokenType["parameter"] = 6] = "parameter";
                TokenType[TokenType["variable"] = 7] = "variable";
                TokenType[TokenType["enumMember"] = 8] = "enumMember";
                TokenType[TokenType["property"] = 9] = "property";
                TokenType[TokenType["function"] = 10] = "function";
                TokenType[TokenType["member"] = 11] = "member";
            })(TokenType = v2020.TokenType || (v2020.TokenType = {}));
            var TokenModifier;
            (function (TokenModifier) {
                TokenModifier[TokenModifier["declaration"] = 0] = "declaration";
                TokenModifier[TokenModifier["static"] = 1] = "static";
                TokenModifier[TokenModifier["async"] = 2] = "async";
                TokenModifier[TokenModifier["readonly"] = 3] = "readonly";
                TokenModifier[TokenModifier["defaultLibrary"] = 4] = "defaultLibrary";
                TokenModifier[TokenModifier["local"] = 5] = "local";
            })(TokenModifier = v2020.TokenModifier || (v2020.TokenModifier = {}));
            /** This is mainly used internally for testing */
            function getSemanticClassifications(program, cancellationToken, sourceFile, span) {
                var classifications = getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span);
                ts.Debug.assert(classifications.spans.length % 3 === 0);
                var dense = classifications.spans;
                var result = [];
                for (var i = 0; i < dense.length; i += 3) {
                    result.push({
                        textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
                        classificationType: dense[i + 2]
                    });
                }
                return result;
            }
            v2020.getSemanticClassifications = getSemanticClassifications;
            function getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span) {
                return {
                    spans: getSemanticTokens(program, sourceFile, span, cancellationToken),
                    endOfLineState: 0 /* None */
                };
            }
            v2020.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
            function getSemanticTokens(program, sourceFile, span, cancellationToken) {
                var resultTokens = [];
                var collector = function (node, typeIdx, modifierSet) {
                    resultTokens.push(node.getStart(sourceFile), node.getWidth(sourceFile), ((typeIdx + 1) << 8 /* typeOffset */) + modifierSet);
                };
                if (program && sourceFile) {
                    collectTokens(program, sourceFile, span, collector, cancellationToken);
                }
                return resultTokens;
            }
            function collectTokens(program, sourceFile, span, collector, cancellationToken) {
                var typeChecker = program.getTypeChecker();
                var inJSXElement = false;
                function visit(node) {
                    switch (node.kind) {
                        case 259 /* ModuleDeclaration */:
                        case 255 /* ClassDeclaration */:
                        case 256 /* InterfaceDeclaration */:
                        case 254 /* FunctionDeclaration */:
                        case 224 /* ClassExpression */:
                        case 211 /* FunctionExpression */:
                        case 212 /* ArrowFunction */:
                            cancellationToken.throwIfCancellationRequested();
                    }
                    if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth()) || node.getFullWidth() === 0) {
                        return;
                    }
                    var prevInJSXElement = inJSXElement;
                    if (ts.isJsxElement(node) || ts.isJsxSelfClosingElement(node)) {
                        inJSXElement = true;
                    }
                    if (ts.isJsxExpression(node)) {
                        inJSXElement = false;
                    }
                    if (ts.isIdentifier(node) && !inJSXElement && !inImportClause(node) && !ts.isInfinityOrNaNString(node.escapedText)) {
                        var symbol = typeChecker.getSymbolAtLocation(node);
                        if (symbol) {
                            if (symbol.flags & 2097152 /* Alias */) {
                                symbol = typeChecker.getAliasedSymbol(symbol);
                            }
                            var typeIdx = classifySymbol(symbol, ts.getMeaningFromLocation(node));
                            if (typeIdx !== undefined) {
                                var modifierSet = 0;
                                if (node.parent) {
                                    var parentIsDeclaration = (ts.isBindingElement(node.parent) || tokenFromDeclarationMapping.get(node.parent.kind) === typeIdx);
                                    if (parentIsDeclaration && node.parent.name === node) {
                                        modifierSet = 1 << 0 /* declaration */;
                                    }
                                }
                                // property declaration in constructor
                                if (typeIdx === 6 /* parameter */ && isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                                    typeIdx = 9 /* property */;
                                }
                                typeIdx = reclassifyByType(typeChecker, node, typeIdx);
                                var decl = symbol.valueDeclaration;
                                if (decl) {
                                    var modifiers = ts.getCombinedModifierFlags(decl);
                                    var nodeFlags = ts.getCombinedNodeFlags(decl);
                                    if (modifiers & 32 /* Static */) {
                                        modifierSet |= 1 << 1 /* static */;
                                    }
                                    if (modifiers & 256 /* Async */) {
                                        modifierSet |= 1 << 2 /* async */;
                                    }
                                    if (typeIdx !== 0 /* class */ && typeIdx !== 2 /* interface */) {
                                        if ((modifiers & 64 /* Readonly */) || (nodeFlags & 2 /* Const */) || (symbol.getFlags() & 8 /* EnumMember */)) {
                                            modifierSet |= 1 << 3 /* readonly */;
                                        }
                                    }
                                    if ((typeIdx === 7 /* variable */ || typeIdx === 10 /* function */) && isLocalDeclaration(decl, sourceFile)) {
                                        modifierSet |= 1 << 5 /* local */;
                                    }
                                    if (program.isSourceFileDefaultLibrary(decl.getSourceFile())) {
                                        modifierSet |= 1 << 4 /* defaultLibrary */;
                                    }
                                }
                                else if (symbol.declarations && symbol.declarations.some(function (d) { return program.isSourceFileDefaultLibrary(d.getSourceFile()); })) {
                                    modifierSet |= 1 << 4 /* defaultLibrary */;
                                }
                                collector(node, typeIdx, modifierSet);
                            }
                        }
                    }
                    ts.forEachChild(node, visit);
                    inJSXElement = prevInJSXElement;
                }
                visit(sourceFile);
            }
            function classifySymbol(symbol, meaning) {
                var flags = symbol.getFlags();
                if (flags & 32 /* Class */) {
                    return 0 /* class */;
                }
                else if (flags & 384 /* Enum */) {
                    return 1 /* enum */;
                }
                else if (flags & 524288 /* TypeAlias */) {
                    return 5 /* type */;
                }
                else if (flags & 64 /* Interface */) {
                    if (meaning & 2 /* Type */) {
                        return 2 /* interface */;
                    }
                }
                else if (flags & 262144 /* TypeParameter */) {
                    return 4 /* typeParameter */;
                }
                var decl = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];
                if (decl && ts.isBindingElement(decl)) {
                    decl = getDeclarationForBindingElement(decl);
                }
                return decl && tokenFromDeclarationMapping.get(decl.kind);
            }
            function reclassifyByType(typeChecker, node, typeIdx) {
                // type based classifications
                if (typeIdx === 7 /* variable */ || typeIdx === 9 /* property */ || typeIdx === 6 /* parameter */) {
                    var type_1 = typeChecker.getTypeAtLocation(node);
                    if (type_1) {
                        var test = function (condition) {
                            return condition(type_1) || type_1.isUnion() && type_1.types.some(condition);
                        };
                        if (typeIdx !== 6 /* parameter */ && test(function (t) { return t.getConstructSignatures().length > 0; })) {
                            return 0 /* class */;
                        }
                        if (test(function (t) { return t.getCallSignatures().length > 0; }) && !test(function (t) { return t.getProperties().length > 0; }) || isExpressionInCallExpression(node)) {
                            return typeIdx === 9 /* property */ ? 11 /* member */ : 10 /* function */;
                        }
                    }
                }
                return typeIdx;
            }
            function isLocalDeclaration(decl, sourceFile) {
                if (ts.isBindingElement(decl)) {
                    decl = getDeclarationForBindingElement(decl);
                }
                if (ts.isVariableDeclaration(decl)) {
                    return (!ts.isSourceFile(decl.parent.parent.parent) || ts.isCatchClause(decl.parent)) && decl.getSourceFile() === sourceFile;
                }
                else if (ts.isFunctionDeclaration(decl)) {
                    return !ts.isSourceFile(decl.parent) && decl.getSourceFile() === sourceFile;
                }
                return false;
            }
            function getDeclarationForBindingElement(element) {
                while (true) {
                    if (ts.isBindingElement(element.parent.parent)) {
                        element = element.parent.parent;
                    }
                    else {
                        return element.parent.parent;
                    }
                }
            }
            function inImportClause(node) {
                var parent = node.parent;
                return parent && (ts.isImportClause(parent) || ts.isImportSpecifier(parent) || ts.isNamespaceImport(parent));
            }
            function isExpressionInCallExpression(node) {
                while (isRightSideOfQualifiedNameOrPropertyAccess(node)) {
                    node = node.parent;
                }
                return ts.isCallExpression(node.parent) && node.parent.expression === node;
            }
            function isRightSideOfQualifiedNameOrPropertyAccess(node) {
                return (ts.isQualifiedName(node.parent) && node.parent.right === node) || (ts.isPropertyAccessExpression(node.parent) && node.parent.name === node);
            }
            var tokenFromDeclarationMapping = new ts.Map([
                [252 /* VariableDeclaration */, 7 /* variable */],
                [162 /* Parameter */, 6 /* parameter */],
                [165 /* PropertyDeclaration */, 9 /* property */],
                [259 /* ModuleDeclaration */, 3 /* namespace */],
                [258 /* EnumDeclaration */, 1 /* enum */],
                [294 /* EnumMember */, 8 /* enumMember */],
                [255 /* ClassDeclaration */, 0 /* class */],
                [167 /* MethodDeclaration */, 11 /* member */],
                [254 /* FunctionDeclaration */, 10 /* function */],
                [211 /* FunctionExpression */, 10 /* function */],
                [166 /* MethodSignature */, 11 /* member */],
                [170 /* GetAccessor */, 9 /* property */],
                [171 /* SetAccessor */, 9 /* property */],
                [164 /* PropertySignature */, 9 /* property */],
                [256 /* InterfaceDeclaration */, 2 /* interface */],
                [257 /* TypeAliasDeclaration */, 5 /* type */],
                [161 /* TypeParameter */, 4 /* typeParameter */],
                [291 /* PropertyAssignment */, 9 /* property */],
                [292 /* ShorthandPropertyAssignment */, 9 /* property */]
            ]);
        })(v2020 = classifier.v2020 || (classifier.v2020 = {}));
    })(classifier = ts.classifier || (ts.classifier = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var Completions;
    (function (Completions) {
        var StringCompletions;
        (function (StringCompletions) {
            function getStringLiteralCompletions(sourceFile, position, contextToken, checker, options, host, log, preferences) {
                if (ts.isInReferenceComment(sourceFile, position)) {
                    var entries = getTripleSlashReferenceCompletion(sourceFile, position, options, host);
                    return entries && convertPathCompletions(entries);
                }
                if (ts.isInString(sourceFile, position, contextToken)) {
                    if (!contextToken || !ts.isStringLiteralLike(contextToken))
                        return undefined;
                    var entries = getStringLiteralCompletionEntries(sourceFile, contextToken, position, checker, options, host, preferences);
                    return convertStringLiteralCompletions(entries, contextToken, sourceFile, checker, log, options, preferences);
                }
            }
            StringCompletions.getStringLiteralCompletions = getStringLiteralCompletions;
            function convertStringLiteralCompletions(completion, contextToken, sourceFile, checker, log, options, preferences) {
                if (completion === undefined) {
                    return undefined;
                }
                var optionalReplacementSpan = ts.createTextSpanFromStringLiteralLikeContent(contextToken);
                switch (completion.kind) {
                    case 0 /* Paths */:
                        return convertPathCompletions(completion.paths);
                    case 1 /* Properties */: {
                        var entries = [];
                        Completions.getCompletionEntriesFromSymbols(completion.symbols, entries, contextToken, sourceFile, sourceFile, checker, 99 /* ESNext */, log, 4 /* String */, preferences, options); // Target will not be used, so arbitrary
                        return { isGlobalCompletion: false, isMemberCompletion: true, isNewIdentifierLocation: completion.hasIndexSignature, optionalReplacementSpan: optionalReplacementSpan, entries: entries };
                    }
                    case 2 /* Types */: {
                        var entries = completion.types.map(function (type) { return ({
                            name: type.value,
                            kindModifiers: "" /* none */,
                            kind: "string" /* string */,
                            sortText: Completions.SortText.LocationPriority,
                            replacementSpan: ts.getReplacementSpanForContextToken(contextToken)
                        }); });
                        return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: completion.isNewIdentifier, optionalReplacementSpan: optionalReplacementSpan, entries: entries };
                    }
                    default:
                        return ts.Debug.assertNever(completion);
                }
            }
            function getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, checker, options, host, cancellationToken, preferences) {
                if (!contextToken || !ts.isStringLiteralLike(contextToken))
                    return undefined;
                var completions = getStringLiteralCompletionEntries(sourceFile, contextToken, position, checker, options, host, preferences);
                return completions && stringLiteralCompletionDetails(name, contextToken, completions, sourceFile, checker, cancellationToken);
            }
            StringCompletions.getStringLiteralCompletionDetails = getStringLiteralCompletionDetails;
            function stringLiteralCompletionDetails(name, location, completion, sourceFile, checker, cancellationToken) {
                switch (completion.kind) {
                    case 0 /* Paths */: {
                        var match = ts.find(completion.paths, function (p) { return p.name === name; });
                        return match && Completions.createCompletionDetails(name, kindModifiersFromExtension(match.extension), match.kind, [ts.textPart(name)]);
                    }
                    case 1 /* Properties */: {
                        var match = ts.find(completion.symbols, function (s) { return s.name === name; });
                        return match && Completions.createCompletionDetailsForSymbol(match, checker, sourceFile, location, cancellationToken);
                    }
                    case 2 /* Types */:
                        return ts.find(completion.types, function (t) { return t.value === name; }) ? Completions.createCompletionDetails(name, "" /* none */, "type" /* typeElement */, [ts.textPart(name)]) : undefined;
                    default:
                        return ts.Debug.assertNever(completion);
                }
            }
            function convertPathCompletions(pathCompletions) {
                var isGlobalCompletion = false; // We don't want the editor to offer any other completions, such as snippets, inside a comment.
                var isNewIdentifierLocation = true; // The user may type in a path that doesn't yet exist, creating a "new identifier" with respect to the collection of identifiers the server is aware of.
                var entries = pathCompletions.map(function (_a) {
                    var name = _a.name, kind = _a.kind, span = _a.span, extension = _a.extension;
                    return ({ name: name, kind: kind, kindModifiers: kindModifiersFromExtension(extension), sortText: Completions.SortText.LocationPriority, replacementSpan: span });
                });
                return { isGlobalCompletion: isGlobalCompletion, isMemberCompletion: false, isNewIdentifierLocation: isNewIdentifierLocation, entries: entries };
            }
            function kindModifiersFromExtension(extension) {
                switch (extension) {
                    case ".d.ts" /* Dts */: return ".d.ts" /* dtsModifier */;
                    case ".js" /* Js */: return ".js" /* jsModifier */;
                    case ".json" /* Json */: return ".json" /* jsonModifier */;
                    case ".jsx" /* Jsx */: return ".jsx" /* jsxModifier */;
                    case ".ts" /* Ts */: return ".ts" /* tsModifier */;
                    case ".tsx" /* Tsx */: return ".tsx" /* tsxModifier */;
                    case ".tsbuildinfo" /* TsBuildInfo */: return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
                    case undefined: return "" /* none */;
                    default:
                        return ts.Debug.assertNever(extension);
                }
            }
            var StringLiteralCompletionKind;
            (function (StringLiteralCompletionKind) {
                StringLiteralCompletionKind[StringLiteralCompletionKind["Paths"] = 0] = "Paths";
                StringLiteralCompletionKind[StringLiteralCompletionKind["Properties"] = 1] = "Properties";
                StringLiteralCompletionKind[StringLiteralCompletionKind["Types"] = 2] = "Types";
            })(StringLiteralCompletionKind || (StringLiteralCompletionKind = {}));
            function getStringLiteralCompletionEntries(sourceFile, node, position, typeChecker, compilerOptions, host, preferences) {
                var parent = walkUpParentheses(node.parent);
                switch (parent.kind) {
                    case 194 /* LiteralType */: {
                        var grandParent = walkUpParentheses(parent.parent);
                        switch (grandParent.kind) {
                            case 176 /* TypeReference */: {
                                var typeReference_1 = grandParent;
                                var typeArgument = ts.findAncestor(parent, function (n) { return n.parent === typeReference_1; });
                                if (typeArgument) {
                                    return { kind: 2 /* Types */, types: getStringLiteralTypes(typeChecker.getTypeArgumentConstraint(typeArgument)), isNewIdentifier: false };
                                }
                                return undefined;
                            }
                            case 192 /* IndexedAccessType */:
                                // Get all apparent property names
                                // i.e. interface Foo {
                                //          foo: string;
                                //          bar: string;
                                //      }
                                //      let x: Foo["/*completion position*/"]
                                var _a = grandParent, indexType = _a.indexType, objectType = _a.objectType;
                                if (!ts.rangeContainsPosition(indexType, position)) {
                                    return undefined;
                                }
                                return stringLiteralCompletionsFromProperties(typeChecker.getTypeFromTypeNode(objectType));
                            case 198 /* ImportType */:
                                return { kind: 0 /* Paths */, paths: getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) };
                            case 185 /* UnionType */: {
                                if (!ts.isTypeReferenceNode(grandParent.parent)) {
                                    return undefined;
                                }
                                var alreadyUsedTypes_1 = getAlreadyUsedTypesInStringLiteralUnion(grandParent, parent);
                                var types = getStringLiteralTypes(typeChecker.getTypeArgumentConstraint(grandParent)).filter(function (t) { return !ts.contains(alreadyUsedTypes_1, t.value); });
                                return { kind: 2 /* Types */, types: types, isNewIdentifier: false };
                            }
                            default:
                                return undefined;
                        }
                    }
                    case 291 /* PropertyAssignment */:
                        if (ts.isObjectLiteralExpression(parent.parent) && parent.name === node) {
                            // Get quoted name of properties of the object literal expression
                            // i.e. interface ConfigFiles {
                            //          'jspm:dev': string
                            //      }
                            //      let files: ConfigFiles = {
                            //          '/*completion position*/'
                            //      }
                            //
                            //      function foo(c: ConfigFiles) {}
                            //      foo({
                            //          '/*completion position*/'
                            //      });
                            return stringLiteralCompletionsForObjectLiteral(typeChecker, parent.parent);
                        }
                        return fromContextualType();
                    case 205 /* ElementAccessExpression */: {
                        var _b = parent, expression = _b.expression, argumentExpression = _b.argumentExpression;
                        if (node === ts.skipParentheses(argumentExpression)) {
                            // Get all names of properties on the expression
                            // i.e. interface A {
                            //      'prop1': string
                            // }
                            // let a: A;
                            // a['/*completion position*/']
                            return stringLiteralCompletionsFromProperties(typeChecker.getTypeAtLocation(expression));
                        }
                        return undefined;
                    }
                    case 206 /* CallExpression */:
                    case 207 /* NewExpression */:
                        if (!isRequireCallArgument(node) && !ts.isImportCall(parent)) {
                            var argumentInfo = ts.SignatureHelp.getArgumentInfoForCompletions(node, position, sourceFile);
                            // Get string literal completions from specialized signatures of the target
                            // i.e. declare function f(a: 'A');
                            // f("/*completion position*/")
                            return argumentInfo ? getStringLiteralCompletionsFromSignature(argumentInfo, typeChecker) : fromContextualType();
                        }
                    // falls through (is `require("")` or `require(""` or `import("")`)
                    case 264 /* ImportDeclaration */:
                    case 270 /* ExportDeclaration */:
                    case 275 /* ExternalModuleReference */:
                        // Get all known external module names or complete a path to a module
                        // i.e. import * as ns from "/*completion position*/";
                        //      var y = import("/*completion position*/");
                        //      import x = require("/*completion position*/");
                        //      var y = require("/*completion position*/");
                        //      export * from "/*completion position*/";
                        return { kind: 0 /* Paths */, paths: getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) };
                    default:
                        return fromContextualType();
                }
                function fromContextualType() {
                    // Get completion for string literal from string literal type
                    // i.e. var x: "hi" | "hello" = "/*completion position*/"
                    return { kind: 2 /* Types */, types: getStringLiteralTypes(ts.getContextualTypeFromParent(node, typeChecker)), isNewIdentifier: false };
                }
            }
            function walkUpParentheses(node) {
                switch (node.kind) {
                    case 189 /* ParenthesizedType */:
                        return ts.walkUpParenthesizedTypes(node);
                    case 210 /* ParenthesizedExpression */:
                        return ts.walkUpParenthesizedExpressions(node);
                    default:
                        return node;
                }
            }
            function getAlreadyUsedTypesInStringLiteralUnion(union, current) {
                return ts.mapDefined(union.types, function (type) {
                    return type !== current && ts.isLiteralTypeNode(type) && ts.isStringLiteral(type.literal) ? type.literal.text : undefined;
                });
            }
            function getStringLiteralCompletionsFromSignature(argumentInfo, checker) {
                var isNewIdentifier = false;
                var uniques = new ts.Map();
                var candidates = [];
                checker.getResolvedSignature(argumentInfo.invocation, candidates, argumentInfo.argumentCount);
                var types = ts.flatMap(candidates, function (candidate) {
                    if (!ts.signatureHasRestParameter(candidate) && argumentInfo.argumentCount > candidate.parameters.length)
                        return;
                    var type = checker.getParameterType(candidate, argumentInfo.argumentIndex);
                    isNewIdentifier = isNewIdentifier || !!(type.flags & 4 /* String */);
                    return getStringLiteralTypes(type, uniques);
                });
                return { kind: 2 /* Types */, types: types, isNewIdentifier: isNewIdentifier };
            }
            function stringLiteralCompletionsFromProperties(type) {
                return type && {
                    kind: 1 /* Properties */,
                    symbols: ts.filter(type.getApparentProperties(), function (prop) { return !(prop.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(prop.valueDeclaration)); }),
                    hasIndexSignature: ts.hasIndexSignature(type)
                };
            }
            function stringLiteralCompletionsForObjectLiteral(checker, objectLiteralExpression) {
                var contextualType = checker.getContextualType(objectLiteralExpression);
                if (!contextualType)
                    return undefined;
                var completionsType = checker.getContextualType(objectLiteralExpression, 4 /* Completions */);
                var symbols = Completions.getPropertiesForObjectExpression(contextualType, completionsType, objectLiteralExpression, checker);
                return {
                    kind: 1 /* Properties */,
                    symbols: symbols,
                    hasIndexSignature: ts.hasIndexSignature(contextualType)
                };
            }
            function getStringLiteralTypes(type, uniques) {
                if (uniques === void 0) { uniques = new ts.Map(); }
                if (!type)
                    return ts.emptyArray;
                type = ts.skipConstraint(type);
                return type.isUnion() ? ts.flatMap(type.types, function (t) { return getStringLiteralTypes(t, uniques); }) :
                    type.isStringLiteral() && !(type.flags & 1024 /* EnumLiteral */) && ts.addToSeen(uniques, type.value) ? [type] : ts.emptyArray;
            }
            function nameAndKind(name, kind, extension) {
                return { name: name, kind: kind, extension: extension };
            }
            function directoryResult(name) {
                return nameAndKind(name, "directory" /* directory */, /*extension*/ undefined);
            }
            function addReplacementSpans(text, textStart, names) {
                var span = getDirectoryFragmentTextSpan(text, textStart);
                var wholeSpan = text.length === 0 ? undefined : ts.createTextSpan(textStart, text.length);
                return names.map(function (_a) {
                    var name = _a.name, kind = _a.kind, extension = _a.extension;
                    return Math.max(name.indexOf(ts.directorySeparator), name.indexOf(ts.altDirectorySeparator)) !== -1 ? { name: name, kind: kind, extension: extension, span: wholeSpan } : { name: name, kind: kind, extension: extension, span: span };
                });
            }
            function getStringLiteralCompletionsFromModuleNames(sourceFile, node, compilerOptions, host, typeChecker, preferences) {
                return addReplacementSpans(node.text, node.getStart(sourceFile) + 1, getStringLiteralCompletionsFromModuleNamesWorker(sourceFile, node, compilerOptions, host, typeChecker, preferences));
            }
            function getStringLiteralCompletionsFromModuleNamesWorker(sourceFile, node, compilerOptions, host, typeChecker, preferences) {
                var literalValue = ts.normalizeSlashes(node.text);
                var scriptPath = sourceFile.path;
                var scriptDirectory = ts.getDirectoryPath(scriptPath);
                return isPathRelativeToScript(literalValue) || !compilerOptions.baseUrl && (ts.isRootedDiskPath(literalValue) || ts.isUrl(literalValue))
                    ? getCompletionEntriesForRelativeModules(literalValue, scriptDirectory, compilerOptions, host, scriptPath, preferences)
                    : getCompletionEntriesForNonRelativeModules(literalValue, scriptDirectory, compilerOptions, host, typeChecker);
            }
            function getExtensionOptions(compilerOptions, includeExtensionsOption) {
                if (includeExtensionsOption === void 0) { includeExtensionsOption = 0 /* Exclude */; }
                return { extensions: getSupportedExtensionsForModuleResolution(compilerOptions), includeExtensionsOption: includeExtensionsOption };
            }
            function getCompletionEntriesForRelativeModules(literalValue, scriptDirectory, compilerOptions, host, scriptPath, preferences) {
                var includeExtensions = preferences.importModuleSpecifierEnding === "js" ? 2 /* ModuleSpecifierCompletion */ : 0 /* Exclude */;
                var extensionOptions = getExtensionOptions(compilerOptions, includeExtensions);
                if (compilerOptions.rootDirs) {
                    return getCompletionEntriesForDirectoryFragmentWithRootDirs(compilerOptions.rootDirs, literalValue, scriptDirectory, extensionOptions, compilerOptions, host, scriptPath);
                }
                else {
                    return getCompletionEntriesForDirectoryFragment(literalValue, scriptDirectory, extensionOptions, host, scriptPath);
                }
            }
            function getSupportedExtensionsForModuleResolution(compilerOptions) {
                var extensions = ts.getSupportedExtensions(compilerOptions);
                return compilerOptions.resolveJsonModule && ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs ?
                    extensions.concat(".json" /* Json */) :
                    extensions;
            }
            /**
             * Takes a script path and returns paths for all potential folders that could be merged with its
             * containing folder via the "rootDirs" compiler option
             */
            function getBaseDirectoriesFromRootDirs(rootDirs, basePath, scriptDirectory, ignoreCase) {
                // Make all paths absolute/normalized if they are not already
                rootDirs = rootDirs.map(function (rootDirectory) { return ts.normalizePath(ts.isRootedDiskPath(rootDirectory) ? rootDirectory : ts.combinePaths(basePath, rootDirectory)); });
                // Determine the path to the directory containing the script relative to the root directory it is contained within
                var relativeDirectory = ts.firstDefined(rootDirs, function (rootDirectory) {
                    return ts.containsPath(rootDirectory, scriptDirectory, basePath, ignoreCase) ? scriptDirectory.substr(rootDirectory.length) : undefined;
                }); // TODO: GH#18217
                // Now find a path for each potential directory that is to be merged with the one containing the script
                return ts.deduplicate(__spreadArray(__spreadArray([], rootDirs.map(function (rootDirectory) { return ts.combinePaths(rootDirectory, relativeDirectory); }), true), [scriptDirectory], false), ts.equateStringsCaseSensitive, ts.compareStringsCaseSensitive);
            }
            function getCompletionEntriesForDirectoryFragmentWithRootDirs(rootDirs, fragment, scriptDirectory, extensionOptions, compilerOptions, host, exclude) {
                var basePath = compilerOptions.project || host.getCurrentDirectory();
                var ignoreCase = !(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames());
                var baseDirectories = getBaseDirectoriesFromRootDirs(rootDirs, basePath, scriptDirectory, ignoreCase);
                return ts.flatMap(baseDirectories, function (baseDirectory) { return getCompletionEntriesForDirectoryFragment(fragment, baseDirectory, extensionOptions, host, exclude); });
            }
            var IncludeExtensionsOption;
            (function (IncludeExtensionsOption) {
                IncludeExtensionsOption[IncludeExtensionsOption["Exclude"] = 0] = "Exclude";
                IncludeExtensionsOption[IncludeExtensionsOption["Include"] = 1] = "Include";
                IncludeExtensionsOption[IncludeExtensionsOption["ModuleSpecifierCompletion"] = 2] = "ModuleSpecifierCompletion";
            })(IncludeExtensionsOption || (IncludeExtensionsOption = {}));
            /**
             * Given a path ending at a directory, gets the completions for the path, and filters for those entries containing the basename.
             */
            function getCompletionEntriesForDirectoryFragment(fragment, scriptPath, _a, host, exclude, result) {
                var extensions = _a.extensions, includeExtensionsOption = _a.includeExtensionsOption;
                if (result === void 0) { result = []; }
                if (fragment === undefined) {
                    fragment = "";
                }
                fragment = ts.normalizeSlashes(fragment);
                /**
                 * Remove the basename from the path. Note that we don't use the basename to filter completions;
                 * the client is responsible for refining completions.
                 */
                if (!ts.hasTrailingDirectorySeparator(fragment)) {
                    fragment = ts.getDirectoryPath(fragment);
                }
                if (fragment === "") {
                    fragment = "." + ts.directorySeparator;
                }
                fragment = ts.ensureTrailingDirectorySeparator(fragment);
                // const absolutePath = normalizeAndPreserveTrailingSlash(isRootedDiskPath(fragment) ? fragment : combinePaths(scriptPath, fragment)); // TODO(rbuckton): should use resolvePaths
                var absolutePath = ts.resolvePath(scriptPath, fragment);
                var baseDirectory = ts.hasTrailingDirectorySeparator(absolutePath) ? absolutePath : ts.getDirectoryPath(absolutePath);
                var ignoreCase = !(host.useCaseSensitiveFileNames && host.useCaseSensitiveFileNames());
                if (!ts.tryDirectoryExists(host, baseDirectory))
                    return result;
                // Enumerate the available files if possible
                var files = ts.tryReadDirectory(host, baseDirectory, extensions, /*exclude*/ undefined, /*include*/ ["./*"]);
                if (files) {
                    /**
                     * Multiple file entries might map to the same truncated name once we remove extensions
                     * (happens iff includeExtensionsOption === includeExtensionsOption.Exclude) so we use a set-like data structure. Eg:
                     *
                     * both foo.ts and foo.tsx become foo
                     */
                    var foundFiles = new ts.Map(); // maps file to its extension
                    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                        var filePath = files_1[_i];
                        filePath = ts.normalizePath(filePath);
                        if (exclude && ts.comparePaths(filePath, exclude, scriptPath, ignoreCase) === 0 /* EqualTo */) {
                            continue;
                        }
                        var foundFileName = void 0;
                        var outputExtension = ts.moduleSpecifiers.tryGetJSExtensionForFile(filePath, host.getCompilationSettings());
                        if (includeExtensionsOption === 0 /* Exclude */ && !ts.fileExtensionIs(filePath, ".json" /* Json */)) {
                            foundFileName = ts.removeFileExtension(ts.getBaseFileName(filePath));
                            foundFiles.set(foundFileName, ts.tryGetExtensionFromPath(filePath));
                        }
                        else if (includeExtensionsOption === 2 /* ModuleSpecifierCompletion */ && outputExtension) {
                            foundFileName = ts.changeExtension(ts.getBaseFileName(filePath), outputExtension);
                            foundFiles.set(foundFileName, outputExtension);
                        }
                        else {
                            foundFileName = ts.getBaseFileName(filePath);
                            foundFiles.set(foundFileName, ts.tryGetExtensionFromPath(filePath));
                        }
                    }
                    foundFiles.forEach(function (ext, foundFile) {
                        result.push(nameAndKind(foundFile, "script" /* scriptElement */, ext));
                    });
                }
                // If possible, get folder completion as well
                var directories = ts.tryGetDirectories(host, baseDirectory);
                if (directories) {
                    for (var _b = 0, directories_1 = directories; _b < directories_1.length; _b++) {
                        var directory = directories_1[_b];
                        var directoryName = ts.getBaseFileName(ts.normalizePath(directory));
                        if (directoryName !== "@types") {
                            result.push(directoryResult(directoryName));
                        }
                    }
                }
                // check for a version redirect
                var packageJsonPath = ts.findPackageJson(baseDirectory, host);
                if (packageJsonPath) {
                    var packageJson = ts.readJson(packageJsonPath, host);
                    var typesVersions = packageJson.typesVersions;
                    if (typeof typesVersions === "object") {
                        var versionResult = ts.getPackageJsonTypesVersionsPaths(typesVersions);
                        var versionPaths = versionResult && versionResult.paths;
                        var rest = absolutePath.slice(ts.ensureTrailingDirectorySeparator(baseDirectory).length);
                        if (versionPaths) {
                            addCompletionEntriesFromPaths(result, rest, baseDirectory, extensions, versionPaths, host);
                        }
                    }
                }
                return result;
            }
            function addCompletionEntriesFromPaths(result, fragment, baseDirectory, fileExtensions, paths, host) {
                for (var path in paths) {
                    if (!ts.hasProperty(paths, path))
                        continue;
                    var patterns = paths[path];
                    if (patterns) {
                        var _loop_2 = function (name, kind, extension) {
                            // Path mappings may provide a duplicate way to get to something we've already added, so don't add again.
                            if (!result.some(function (entry) { return entry.name === name; })) {
                                result.push(nameAndKind(name, kind, extension));
                            }
                        };
                        for (var _i = 0, _a = getCompletionsForPathMapping(path, patterns, fragment, baseDirectory, fileExtensions, host); _i < _a.length; _i++) {
                            var _b = _a[_i], name = _b.name, kind = _b.kind, extension = _b.extension;
                            _loop_2(name, kind, extension);
                        }
                    }
                }
            }
            /**
             * Check all of the declared modules and those in node modules. Possible sources of modules:
             *      Modules that are found by the type checker
             *      Modules found relative to "baseUrl" compliler options (including patterns from "paths" compiler option)
             *      Modules from node_modules (i.e. those listed in package.json)
             *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
             */
            function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, compilerOptions, host, typeChecker) {
                var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                var result = [];
                var extensionOptions = getExtensionOptions(compilerOptions);
                if (baseUrl) {
                    var projectDir = compilerOptions.project || host.getCurrentDirectory();
                    var absolute = ts.normalizePath(ts.combinePaths(projectDir, baseUrl));
                    getCompletionEntriesForDirectoryFragment(fragment, absolute, extensionOptions, host, /*exclude*/ undefined, result);
                    if (paths) {
                        addCompletionEntriesFromPaths(result, fragment, absolute, extensionOptions.extensions, paths, host);
                    }
                }
                var fragmentDirectory = getFragmentDirectory(fragment);
                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
                    var ambientName = _a[_i];
                    result.push(nameAndKind(ambientName, "external module name" /* externalModuleName */, /*extension*/ undefined));
                }
                getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
                if (ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs) {
                    // If looking for a global package name, don't just include everything in `node_modules` because that includes dependencies' own dependencies.
                    // (But do if we didn't find anything, e.g. 'package.json' missing.)
                    var foundGlobal = false;
                    if (fragmentDirectory === undefined) {
                        var _loop_3 = function (moduleName) {
                            if (!result.some(function (entry) { return entry.name === moduleName; })) {
                                foundGlobal = true;
                                result.push(nameAndKind(moduleName, "external module name" /* externalModuleName */, /*extension*/ undefined));
                            }
                        };
                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
                            var moduleName = _c[_b];
                            _loop_3(moduleName);
                        }
                    }
                    if (!foundGlobal) {
                        ts.forEachAncestorDirectory(scriptPath, function (ancestor) {
                            var nodeModules = ts.combinePaths(ancestor, "node_modules");
                            if (ts.tryDirectoryExists(host, nodeModules)) {
                                getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                            }
                        });
                    }
                }
                return result;
            }
            function getFragmentDirectory(fragment) {
                return containsSlash(fragment) ? ts.hasTrailingDirectorySeparator(fragment) ? fragment : ts.getDirectoryPath(fragment) : undefined;
            }
            function getCompletionsForPathMapping(path, patterns, fragment, baseUrl, fileExtensions, host) {
                if (!ts.endsWith(path, "*")) {
                    // For a path mapping "foo": ["/x/y/z.ts"], add "foo" itself as a completion.
                    return !ts.stringContains(path, "*") ? justPathMappingName(path) : ts.emptyArray;
                }
                var pathPrefix = path.slice(0, path.length - 1);
                var remainingFragment = ts.tryRemovePrefix(fragment, pathPrefix);
                return remainingFragment === undefined ? justPathMappingName(pathPrefix) : ts.flatMap(patterns, function (pattern) {
                    return getModulesForPathsPattern(remainingFragment, baseUrl, pattern, fileExtensions, host);
                });
                function justPathMappingName(name) {
                    return ts.startsWith(name, fragment) ? [directoryResult(name)] : ts.emptyArray;
                }
            }
            function getModulesForPathsPattern(fragment, baseUrl, pattern, fileExtensions, host) {
                if (!host.readDirectory) {
                    return undefined;
                }
                var parsed = ts.tryParsePattern(pattern);
                if (parsed === undefined || ts.isString(parsed)) {
                    return undefined;
                }
                // The prefix has two effective parts: the directory path and the base component after the filepath that is not a
                // full directory component. For example: directory/path/of/prefix/base*
                var normalizedPrefix = ts.resolvePath(parsed.prefix);
                var normalizedPrefixDirectory = ts.hasTrailingDirectorySeparator(parsed.prefix) ? normalizedPrefix : ts.getDirectoryPath(normalizedPrefix);
                var normalizedPrefixBase = ts.hasTrailingDirectorySeparator(parsed.prefix) ? "" : ts.getBaseFileName(normalizedPrefix);
                var fragmentHasPath = containsSlash(fragment);
                var fragmentDirectory = fragmentHasPath ? ts.hasTrailingDirectorySeparator(fragment) ? fragment : ts.getDirectoryPath(fragment) : undefined;
                // Try and expand the prefix to include any path from the fragment so that we can limit the readDirectory call
                var expandedPrefixDirectory = fragmentHasPath ? ts.combinePaths(normalizedPrefixDirectory, normalizedPrefixBase + fragmentDirectory) : normalizedPrefixDirectory;
                var normalizedSuffix = ts.normalizePath(parsed.suffix);
                // Need to normalize after combining: If we combinePaths("a", "../b"), we want "b" and not "a/../b".
                var baseDirectory = ts.normalizePath(ts.combinePaths(baseUrl, expandedPrefixDirectory));
                var completePrefix = fragmentHasPath ? baseDirectory : ts.ensureTrailingDirectorySeparator(baseDirectory) + normalizedPrefixBase;
                // If we have a suffix, then we need to read the directory all the way down. We could create a glob
                // that encodes the suffix, but we would have to escape the character "?" which readDirectory
                // doesn't support. For now, this is safer but slower
                var includeGlob = normalizedSuffix ? "**/*" : "./*";
                var matches = ts.mapDefined(ts.tryReadDirectory(host, baseDirectory, fileExtensions, /*exclude*/ undefined, [includeGlob]), function (match) {
                    var extension = ts.tryGetExtensionFromPath(match);
                    var name = trimPrefixAndSuffix(match);
                    return name === undefined ? undefined : nameAndKind(ts.removeFileExtension(name), "script" /* scriptElement */, extension);
                });
                var directories = ts.mapDefined(ts.tryGetDirectories(host, baseDirectory).map(function (d) { return ts.combinePaths(baseDirectory, d); }), function (dir) {
                    var name = trimPrefixAndSuffix(dir);
                    return name === undefined ? undefined : directoryResult(name);
                });
                return __spreadArray(__spreadArray([], matches, true), directories, true);
                function trimPrefixAndSuffix(path) {
                    var inner = withoutStartAndEnd(ts.normalizePath(path), completePrefix, normalizedSuffix);
                    return inner === undefined ? undefined : removeLeadingDirectorySeparator(inner);
                }
            }
            function withoutStartAndEnd(s, start, end) {
                return ts.startsWith(s, start) && ts.endsWith(s, end) ? s.slice(start.length, s.length - end.length) : undefined;
            }
            function removeLeadingDirectorySeparator(path) {
                return path[0] === ts.directorySeparator ? path.slice(1) : path;
            }
            function getAmbientModuleCompletions(fragment, fragmentDirectory, checker) {
                // Get modules that the type checker picked up
                var ambientModules = checker.getAmbientModules().map(function (sym) { return ts.stripQuotes(sym.name); });
                var nonRelativeModuleNames = ambientModules.filter(function (moduleName) { return ts.startsWith(moduleName, fragment); });
                // Nested modules of the form "module-name/sub" need to be adjusted to only return the string
                // after the last '/' that appears in the fragment because that's where the replacement span
                // starts
                if (fragmentDirectory !== undefined) {
                    var moduleNameWithSeparator_1 = ts.ensureTrailingDirectorySeparator(fragmentDirectory);
                    return nonRelativeModuleNames.map(function (nonRelativeModuleName) { return ts.removePrefix(nonRelativeModuleName, moduleNameWithSeparator_1); });
                }
                return nonRelativeModuleNames;
            }
            function getTripleSlashReferenceCompletion(sourceFile, position, compilerOptions, host) {
                var token = ts.getTokenAtPosition(sourceFile, position);
                var commentRanges = ts.getLeadingCommentRanges(sourceFile.text, token.pos);
                var range = commentRanges && ts.find(commentRanges, function (commentRange) { return position >= commentRange.pos && position <= commentRange.end; });
                if (!range) {
                    return undefined;
                }
                var text = sourceFile.text.slice(range.pos, position);
                var match = tripleSlashDirectiveFragmentRegex.exec(text);
                if (!match) {
                    return undefined;
                }
                var prefix = match[1], kind = match[2], toComplete = match[3];
                var scriptPath = ts.getDirectoryPath(sourceFile.path);
                var names = kind === "path" ? getCompletionEntriesForDirectoryFragment(toComplete, scriptPath, getExtensionOptions(compilerOptions, 1 /* Include */), host, sourceFile.path)
                    : kind === "types" ? getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, getFragmentDirectory(toComplete), getExtensionOptions(compilerOptions))
                        : ts.Debug.fail();
                return addReplacementSpans(toComplete, range.pos + prefix.length, names);
            }
            function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
                if (result === void 0) { result = []; }
                // Check for typings specified in compiler options
                var seen = new ts.Map();
                var typeRoots = ts.tryAndIgnoreErrors(function () { return ts.getEffectiveTypeRoots(options, host); }) || ts.emptyArray;
                for (var _i = 0, typeRoots_1 = typeRoots; _i < typeRoots_1.length; _i++) {
                    var root = typeRoots_1[_i];
                    getCompletionEntriesFromDirectories(root);
                }
                // Also get all @types typings installed in visible node_modules directories
                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
                    var packageJson = _b[_a];
                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
                    getCompletionEntriesFromDirectories(typesDir);
                }
                return result;
                function getCompletionEntriesFromDirectories(directory) {
                    if (!ts.tryDirectoryExists(host, directory))
                        return;
                    for (var _i = 0, _a = ts.tryGetDirectories(host, directory); _i < _a.length; _i++) {
                        var typeDirectoryName = _a[_i];
                        var packageName = ts.unmangleScopedPackageName(typeDirectoryName);
                        if (options.types && !ts.contains(options.types, packageName))
                            continue;
                        if (fragmentDirectory === undefined) {
                            if (!seen.has(packageName)) {
                                result.push(nameAndKind(packageName, "external module name" /* externalModuleName */, /*extension*/ undefined));
                                seen.set(packageName, true);
                            }
                        }
                        else {
                            var baseDirectory = ts.combinePaths(directory, typeDirectoryName);
                            var remainingFragment = ts.tryRemoveDirectoryPrefix(fragmentDirectory, packageName, ts.hostGetCanonicalFileName(host));
                            if (remainingFragment !== undefined) {
                                getCompletionEntriesForDirectoryFragment(remainingFragment, baseDirectory, extensionOptions, host, /*exclude*/ undefined, result);
                            }
                        }
                    }
                }
            }
            function enumerateNodeModulesVisibleToScript(host, scriptPath) {
                if (!host.readFile || !host.fileExists)
                    return ts.emptyArray;
                var result = [];
                for (var _i = 0, _a = ts.findPackageJsons(scriptPath, host); _i < _a.length; _i++) {
                    var packageJson = _a[_i];
                    var contents = ts.readJson(packageJson, host); // Cast to assert that readFile is defined
                    // Provide completions for all non @types dependencies
                    for (var _b = 0, nodeModulesDependencyKeys_1 = nodeModulesDependencyKeys; _b < nodeModulesDependencyKeys_1.length; _b++) {
                        var key = nodeModulesDependencyKeys_1[_b];
                        var dependencies = contents[key];
                        if (!dependencies)
                            continue;
                        for (var dep in dependencies) {
                            if (dependencies.hasOwnProperty(dep) && !ts.startsWith(dep, "@types/")) {
                                result.push(dep);
                            }
                        }
                    }
                }
                return result;
            }
            // Replace everything after the last directory separator that appears
            function getDirectoryFragmentTextSpan(text, textStart) {
                var index = Math.max(text.lastIndexOf(ts.directorySeparator), text.lastIndexOf(ts.altDirectorySeparator));
                var offset = index !== -1 ? index + 1 : 0;
                // If the range is an identifier, span is unnecessary.
                var length = text.length - offset;
                return length === 0 || ts.isIdentifierText(text.substr(offset, length), 99 /* ESNext */) ? undefined : ts.createTextSpan(textStart + offset, length);
            }
            // Returns true if the path is explicitly relative to the script (i.e. relative to . or ..)
            function isPathRelativeToScript(path) {
                if (path && path.length >= 2 && path.charCodeAt(0) === 46 /* dot */) {
                    var slashIndex = path.length >= 3 && path.charCodeAt(1) === 46 /* dot */ ? 2 : 1;
                    var slashCharCode = path.charCodeAt(slashIndex);
                    return slashCharCode === 47 /* slash */ || slashCharCode === 92 /* backslash */;
                }
                return false;
            }
            /**
             * Matches a triple slash reference directive with an incomplete string literal for its path. Used
             * to determine if the caret is currently within the string literal and capture the literal fragment
             * for completions.
             * For example, this matches
             *
             * /// <reference path="fragment
             *
             * but not
             *
             * /// <reference path="fragment"
             */
            var tripleSlashDirectiveFragmentRegex = /^(\/\/\/\s*<reference\s+(path|types)\s*=\s*(?:'|"))([^\3"]*)$/;
            var nodeModulesDependencyKeys = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
            function containsSlash(fragment) {
                return ts.stringContains(fragment, ts.directorySeparator);
            }
            /**
             * Matches
             *   require(""
             *   require("")
             */
            function isRequireCallArgument(node) {
                return ts.isCallExpression(node.parent) && ts.firstOrUndefined(node.parent.arguments) === node
                    && ts.isIdentifier(node.parent.expression) && node.parent.expression.escapedText === "require";
            }
        })(StringCompletions = Completions.StringCompletions || (Completions.StringCompletions = {}));
    })(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var Completions;
    (function (Completions) {
        // Exported only for tests
        Completions.moduleSpecifierResolutionLimit = 100;
        Completions.moduleSpecifierResolutionCacheAttemptLimit = 1000;
        // NOTE: Make sure that each entry has the exact same number of digits
        //       since many implementations will sort by string contents,
        //       where "10" is considered less than "2".
        var SortText;
        (function (SortText) {
            SortText["LocalDeclarationPriority"] = "10";
            SortText["LocationPriority"] = "11";
            SortText["OptionalMember"] = "12";
            SortText["MemberDeclaredBySpreadAssignment"] = "13";
            SortText["SuggestedClassMembers"] = "14";
            SortText["GlobalsOrKeywords"] = "15";
            SortText["AutoImportSuggestions"] = "16";
            SortText["JavascriptIdentifiers"] = "17";
            SortText["DeprecatedLocalDeclarationPriority"] = "18";
            SortText["DeprecatedLocationPriority"] = "19";
            SortText["DeprecatedOptionalMember"] = "20";
            SortText["DeprecatedMemberDeclaredBySpreadAssignment"] = "21";
            SortText["DeprecatedSuggestedClassMembers"] = "22";
            SortText["DeprecatedGlobalsOrKeywords"] = "23";
            SortText["DeprecatedAutoImportSuggestions"] = "24";
        })(SortText = Completions.SortText || (Completions.SortText = {}));
        var SortTextId;
        (function (SortTextId) {
            SortTextId[SortTextId["LocalDeclarationPriority"] = 10] = "LocalDeclarationPriority";
            SortTextId[SortTextId["LocationPriority"] = 11] = "LocationPriority";
            SortTextId[SortTextId["OptionalMember"] = 12] = "OptionalMember";
            SortTextId[SortTextId["MemberDeclaredBySpreadAssignment"] = 13] = "MemberDeclaredBySpreadAssignment";
            SortTextId[SortTextId["SuggestedClassMembers"] = 14] = "SuggestedClassMembers";
            SortTextId[SortTextId["GlobalsOrKeywords"] = 15] = "GlobalsOrKeywords";
            SortTextId[SortTextId["AutoImportSuggestions"] = 16] = "AutoImportSuggestions";
            // Don't use these directly.
            SortTextId[SortTextId["_JavaScriptIdentifiers"] = 17] = "_JavaScriptIdentifiers";
            SortTextId[SortTextId["_DeprecatedStart"] = 18] = "_DeprecatedStart";
            SortTextId[SortTextId["_First"] = 10] = "_First";
            SortTextId[SortTextId["DeprecatedOffset"] = 8] = "DeprecatedOffset";
        })(SortTextId || (SortTextId = {}));
        /**
         * Special values for `CompletionInfo['source']` used to disambiguate
         * completion items with the same `name`. (Each completion item must
         * have a unique name/source combination, because those two fields
         * comprise `CompletionEntryIdentifier` in `getCompletionEntryDetails`.
         *
         * When the completion item is an auto-import suggestion, the source
         * is the module specifier of the suggestion. To avoid collisions,
         * the values here should not be a module specifier we would ever
         * generate for an auto-import.
         */
        var CompletionSource;
        (function (CompletionSource) {
            /** Completions that require `this.` insertion text */
            CompletionSource["ThisProperty"] = "ThisProperty/";
        })(CompletionSource = Completions.CompletionSource || (Completions.CompletionSource = {}));
        var SymbolOriginInfoKind;
        (function (SymbolOriginInfoKind) {
            SymbolOriginInfoKind[SymbolOriginInfoKind["ThisType"] = 1] = "ThisType";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMember"] = 2] = "SymbolMember";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Export"] = 4] = "Export";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Promise"] = 8] = "Promise";
            SymbolOriginInfoKind[SymbolOriginInfoKind["Nullable"] = 16] = "Nullable";
            SymbolOriginInfoKind[SymbolOriginInfoKind["ResolvedExport"] = 32] = "ResolvedExport";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMemberNoExport"] = 2] = "SymbolMemberNoExport";
            SymbolOriginInfoKind[SymbolOriginInfoKind["SymbolMemberExport"] = 6] = "SymbolMemberExport";
        })(SymbolOriginInfoKind || (SymbolOriginInfoKind = {}));
        function originIsThisType(origin) {
            return !!(origin.kind & 1 /* ThisType */);
        }
        function originIsSymbolMember(origin) {
            return !!(origin.kind & 2 /* SymbolMember */);
        }
        function originIsExport(origin) {
            return !!(origin && origin.kind & 4 /* Export */);
        }
        function originIsResolvedExport(origin) {
            return !!(origin && origin.kind === 32 /* ResolvedExport */);
        }
        function originIncludesSymbolName(origin) {
            return originIsExport(origin) || originIsResolvedExport(origin);
        }
        function originIsPackageJsonImport(origin) {
            return (originIsExport(origin) || originIsResolvedExport(origin)) && !!origin.isFromPackageJson;
        }
        function originIsPromise(origin) {
            return !!(origin.kind & 8 /* Promise */);
        }
        function originIsNullableMember(origin) {
            return !!(origin.kind & 16 /* Nullable */);
        }
        var KeywordCompletionFilters;
        (function (KeywordCompletionFilters) {
            KeywordCompletionFilters[KeywordCompletionFilters["None"] = 0] = "None";
            KeywordCompletionFilters[KeywordCompletionFilters["All"] = 1] = "All";
            KeywordCompletionFilters[KeywordCompletionFilters["ClassElementKeywords"] = 2] = "ClassElementKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["InterfaceElementKeywords"] = 3] = "InterfaceElementKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["ConstructorParameterKeywords"] = 4] = "ConstructorParameterKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["FunctionLikeBodyKeywords"] = 5] = "FunctionLikeBodyKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeAssertionKeywords"] = 6] = "TypeAssertionKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["TypeKeywords"] = 7] = "TypeKeywords";
            KeywordCompletionFilters[KeywordCompletionFilters["Last"] = 7] = "Last";
        })(KeywordCompletionFilters || (KeywordCompletionFilters = {}));
        var GlobalsSearch;
        (function (GlobalsSearch) {
            GlobalsSearch[GlobalsSearch["Continue"] = 0] = "Continue";
            GlobalsSearch[GlobalsSearch["Success"] = 1] = "Success";
            GlobalsSearch[GlobalsSearch["Fail"] = 2] = "Fail";
        })(GlobalsSearch || (GlobalsSearch = {}));
        function resolvingModuleSpecifiers(logPrefix, host, program, sourceFile, preferences, isForImportStatementCompletion, cb) {
            var _a, _b, _c;
            var start = ts.timestamp();
            var resolutionLimitExceeded = false;
            var ambientCount = 0;
            var resolvedCount = 0;
            var resolvedFromCacheCount = 0;
            var cacheAttemptCount = 0;
            var result = cb({ tryResolve: tryResolve, resolutionLimitExceeded: function () { return resolutionLimitExceeded; } });
            var hitRateMessage = cacheAttemptCount ? " (" + (resolvedFromCacheCount / cacheAttemptCount * 100).toFixed(1) + "% hit rate)" : "";
            (_a = host.log) === null || _a === void 0 ? void 0 : _a.call(host, logPrefix + ": resolved " + resolvedCount + " module specifiers, plus " + ambientCount + " ambient and " + resolvedFromCacheCount + " from cache" + hitRateMessage);
            (_b = host.log) === null || _b === void 0 ? void 0 : _b.call(host, logPrefix + ": response is " + (resolutionLimitExceeded ? "incomplete" : "complete"));
            (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, logPrefix + ": " + (ts.timestamp() - start));
            return result;
            function tryResolve(exportInfo, isFromAmbientModule) {
                if (isFromAmbientModule) {
                    var result_1 = ts.codefix.getModuleSpecifierForBestExportInfo(exportInfo, sourceFile, program, host, preferences);
                    if (result_1) {
                        ambientCount++;
                    }
                    return result_1;
                }
                var shouldResolveModuleSpecifier = isForImportStatementCompletion || preferences.allowIncompleteCompletions && resolvedCount < Completions.moduleSpecifierResolutionLimit;
                var shouldGetModuleSpecifierFromCache = !shouldResolveModuleSpecifier && preferences.allowIncompleteCompletions && cacheAttemptCount < Completions.moduleSpecifierResolutionCacheAttemptLimit;
                var result = (shouldResolveModuleSpecifier || shouldGetModuleSpecifierFromCache)
                    ? ts.codefix.getModuleSpecifierForBestExportInfo(exportInfo, sourceFile, program, host, preferences, shouldGetModuleSpecifierFromCache)
                    : undefined;
                if (!shouldResolveModuleSpecifier && !shouldGetModuleSpecifierFromCache || shouldGetModuleSpecifierFromCache && !result) {
                    resolutionLimitExceeded = true;
                }
                resolvedCount += (result === null || result === void 0 ? void 0 : result.computedWithoutCacheCount) || 0;
                resolvedFromCacheCount += exportInfo.length - resolvedCount;
                if (shouldGetModuleSpecifierFromCache) {
                    cacheAttemptCount++;
                }
                return result;
            }
        }
        function getCompletionsAtPosition(host, program, log, sourceFile, position, preferences, triggerCharacter, completionKind, cancellationToken) {
            var _a;
            var previousToken = getRelevantTokens(position, sourceFile).previousToken;
            if (triggerCharacter && !ts.isInString(sourceFile, position, previousToken) && !isValidTrigger(sourceFile, triggerCharacter, previousToken, position)) {
                return undefined;
            }
            if (triggerCharacter === " ") {
                // `isValidTrigger` ensures we are at `import |`
                if (preferences.includeCompletionsForImportStatements && preferences.includeCompletionsWithInsertText) {
                    return { isGlobalCompletion: true, isMemberCompletion: false, isNewIdentifierLocation: true, isIncomplete: true, entries: [] };
                }
                return undefined;
            }
            // If the request is a continuation of an earlier `isIncomplete` response,
            // we can continue it from the cached previous response.
            var typeChecker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var incompleteCompletionsCache = preferences.allowIncompleteCompletions ? (_a = host.getIncompleteCompletionsCache) === null || _a === void 0 ? void 0 : _a.call(host) : undefined;
            if (incompleteCompletionsCache && completionKind === 3 /* TriggerForIncompleteCompletions */ && previousToken && ts.isIdentifier(previousToken)) {
                var incompleteContinuation = continuePreviousIncompleteResponse(incompleteCompletionsCache, sourceFile, previousToken, program, host, preferences, cancellationToken);
                if (incompleteContinuation) {
                    return incompleteContinuation;
                }
            }
            else {
                incompleteCompletionsCache === null || incompleteCompletionsCache === void 0 ? void 0 : incompleteCompletionsCache.clear();
            }
            var stringCompletions = Completions.StringCompletions.getStringLiteralCompletions(sourceFile, position, previousToken, typeChecker, compilerOptions, host, log, preferences);
            if (stringCompletions) {
                return stringCompletions;
            }
            if (previousToken && ts.isBreakOrContinueStatement(previousToken.parent)
                && (previousToken.kind === 81 /* BreakKeyword */ || previousToken.kind === 86 /* ContinueKeyword */ || previousToken.kind === 79 /* Identifier */)) {
                return getLabelCompletionAtPosition(previousToken.parent);
            }
            var completionData = getCompletionData(program, log, sourceFile, isUncheckedFile(sourceFile, compilerOptions), position, preferences, /*detailsEntryId*/ undefined, host, cancellationToken);
            if (!completionData) {
                return undefined;
            }
            switch (completionData.kind) {
                case 0 /* Data */:
                    var response = completionInfoFromData(sourceFile, typeChecker, compilerOptions, log, completionData, preferences);
                    if (response === null || response === void 0 ? void 0 : response.isIncomplete) {
                        incompleteCompletionsCache === null || incompleteCompletionsCache === void 0 ? void 0 : incompleteCompletionsCache.set(response);
                    }
                    return response;
                case 1 /* JsDocTagName */:
                    // If the current position is a jsDoc tag name, only tag names should be provided for completion
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocTagNameCompletions());
                case 2 /* JsDocTag */:
                    // If the current position is a jsDoc tag, only tags should be provided for completion
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocTagCompletions());
                case 3 /* JsDocParameterName */:
                    return jsdocCompletionInfo(ts.JsDoc.getJSDocParameterNameCompletions(completionData.tag));
                case 4 /* Keywords */:
                    return specificKeywordCompletionInfo(completionData.keywords);
                default:
                    return ts.Debug.assertNever(completionData);
            }
        }
        Completions.getCompletionsAtPosition = getCompletionsAtPosition;
        function continuePreviousIncompleteResponse(cache, file, location, program, host, preferences, cancellationToken) {
            var _a;
            var previousResponse = cache.get();
            if (!previousResponse)
                return undefined;
            var lowerCaseTokenText = location.text.toLowerCase();
            var exportMap = ts.getExportInfoMap(file, host, program, cancellationToken);
            var checker = program.getTypeChecker();
            var autoImportProvider = (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
            var autoImportProviderChecker = autoImportProvider === null || autoImportProvider === void 0 ? void 0 : autoImportProvider.getTypeChecker();
            var newEntries = resolvingModuleSpecifiers("continuePreviousIncompleteResponse", host, program, file, preferences, 
            /*isForImportStatementCompletion*/ false, function (context) {
                var entries = ts.mapDefined(previousResponse.entries, function (entry) {
                    if (!entry.hasAction || !entry.source || !entry.data || entry.data.moduleSpecifier) {
                        // Not an auto import or already resolved; keep as is
                        return entry;
                    }
                    if (!charactersFuzzyMatchInString(entry.name, lowerCaseTokenText)) {
                        // No longer matches typed characters; filter out
                        return undefined;
                    }
                    var _a = ts.Debug.checkDefined(getAutoImportSymbolFromCompletionEntryData(entry.name, entry.data, program, host)), symbol = _a.symbol, origin = _a.origin;
                    var info = exportMap.get(file.path, entry.name, symbol, origin.moduleSymbol.name, origin.isFromPackageJson ? autoImportProviderChecker : checker);
                    var result = info && context.tryResolve(info, !ts.isExternalModuleNameRelative(ts.stripQuotes(origin.moduleSymbol.name)));
                    if (!result)
                        return entry;
                    var newOrigin = __assign(__assign({}, origin), { kind: 32 /* ResolvedExport */, moduleSpecifier: result.moduleSpecifier });
                    // Mutating for performance... feels sketchy but nobody else uses the cache,
                    // so why bother allocating a bunch of new objects?
                    entry.data = originToCompletionEntryData(newOrigin);
                    entry.source = getSourceFromOrigin(newOrigin);
                    entry.sourceDisplay = [ts.textPart(newOrigin.moduleSpecifier)];
                    return entry;
                });
                if (!context.resolutionLimitExceeded()) {
                    previousResponse.isIncomplete = undefined;
                }
                return entries;
            });
            previousResponse.entries = newEntries;
            return previousResponse;
        }
        function jsdocCompletionInfo(entries) {
            return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: entries };
        }
        function specificKeywordCompletionInfo(keywords) {
            return {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                entries: keywords.map(function (k) { return ({
                    name: ts.tokenToString(k),
                    kind: "keyword" /* keyword */,
                    kindModifiers: "" /* none */,
                    sortText: SortText.GlobalsOrKeywords,
                }); }),
            };
        }
        function getOptionalReplacementSpan(location) {
            // StringLiteralLike locations are handled separately in stringCompletions.ts
            return (location === null || location === void 0 ? void 0 : location.kind) === 79 /* Identifier */ ? ts.createTextSpanFromNode(location) : undefined;
        }
        function completionInfoFromData(sourceFile, typeChecker, compilerOptions, log, completionData, preferences) {
            var symbols = completionData.symbols, completionKind = completionData.completionKind, isInSnippetScope = completionData.isInSnippetScope, isNewIdentifierLocation = completionData.isNewIdentifierLocation, location = completionData.location, propertyAccessToConvert = completionData.propertyAccessToConvert, keywordFilters = completionData.keywordFilters, literals = completionData.literals, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, recommendedCompletion = completionData.recommendedCompletion, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation, isJsxIdentifierExpected = completionData.isJsxIdentifierExpected, importCompletionNode = completionData.importCompletionNode, insideJsDocTagTypeExpression = completionData.insideJsDocTagTypeExpression, symbolToSortTextIdMap = completionData.symbolToSortTextIdMap, hasUnresolvedAutoImports = completionData.hasUnresolvedAutoImports;
            // Verify if the file is JSX language variant
            if (ts.getLanguageVariant(sourceFile.scriptKind) === 1 /* JSX */) {
                var completionInfo = getJsxClosingTagCompletion(location, sourceFile);
                if (completionInfo) {
                    return completionInfo;
                }
            }
            var entries = [];
            if (isUncheckedFile(sourceFile, compilerOptions)) {
                var uniqueNames = getCompletionEntriesFromSymbols(symbols, entries, 
                /* contextToken */ undefined, location, sourceFile, typeChecker, compilerOptions.target, log, completionKind, preferences, compilerOptions, isTypeOnlyLocation, propertyAccessToConvert, isJsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextIdMap);
                getJSCompletionEntries(sourceFile, location.pos, uniqueNames, compilerOptions.target, entries); // TODO: GH#18217
            }
            else {
                if (!isNewIdentifierLocation && (!symbols || symbols.length === 0) && keywordFilters === 0 /* None */) {
                    return undefined;
                }
                getCompletionEntriesFromSymbols(symbols, entries, 
                /* contextToken */ undefined, location, sourceFile, typeChecker, compilerOptions.target, log, completionKind, preferences, compilerOptions, isTypeOnlyLocation, propertyAccessToConvert, isJsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextIdMap);
            }
            if (keywordFilters !== 0 /* None */) {
                var entryNames = new ts.Set(entries.map(function (e) { return e.name; }));
                for (var _i = 0, _a = getKeywordCompletions(keywordFilters, !insideJsDocTagTypeExpression && ts.isSourceFileJS(sourceFile)); _i < _a.length; _i++) {
                    var keywordEntry = _a[_i];
                    if (!entryNames.has(keywordEntry.name)) {
                        entries.push(keywordEntry);
                    }
                }
            }
            for (var _b = 0, literals_1 = literals; _b < literals_1.length; _b++) {
                var literal = literals_1[_b];
                entries.push(createCompletionEntryForLiteral(sourceFile, preferences, literal));
            }
            return {
                isGlobalCompletion: isInSnippetScope,
                isIncomplete: preferences.allowIncompleteCompletions && hasUnresolvedAutoImports ? true : undefined,
                isMemberCompletion: isMemberCompletionKind(completionKind),
                isNewIdentifierLocation: isNewIdentifierLocation,
                optionalReplacementSpan: getOptionalReplacementSpan(location),
                entries: entries
            };
        }
        function isUncheckedFile(sourceFile, compilerOptions) {
            return ts.isSourceFileJS(sourceFile) && !ts.isCheckJsEnabledForFile(sourceFile, compilerOptions);
        }
        function isMemberCompletionKind(kind) {
            switch (kind) {
                case 0 /* ObjectPropertyDeclaration */:
                case 3 /* MemberLike */:
                case 2 /* PropertyAccess */:
                    return true;
                default:
                    return false;
            }
        }
        function getJsxClosingTagCompletion(location, sourceFile) {
            // We wanna walk up the tree till we find a JSX closing element
            var jsxClosingElement = ts.findAncestor(location, function (node) {
                switch (node.kind) {
                    case 279 /* JsxClosingElement */:
                        return true;
                    case 43 /* SlashToken */:
                    case 31 /* GreaterThanToken */:
                    case 79 /* Identifier */:
                    case 204 /* PropertyAccessExpression */:
                        return false;
                    default:
                        return "quit";
                }
            });
            if (jsxClosingElement) {
                // In the TypeScript JSX element, if such element is not defined. When users query for completion at closing tag,
                // instead of simply giving unknown value, the completion will return the tag-name of an associated opening-element.
                // For example:
                //     var x = <div> </ /*1*/
                // The completion list at "1" will contain "div>" with type any
                // And at `<div> </ /*1*/ >` (with a closing `>`), the completion list will contain "div".
                // And at property access expressions `<MainComponent.Child> </MainComponent. /*1*/ >` the completion will
                // return full closing tag with an optional replacement span
                // For example:
                //     var x = <MainComponent.Child> </     MainComponent /*1*/  >
                //     var y = <MainComponent.Child> </   /*2*/   MainComponent >
                // the completion list at "1" and "2" will contain "MainComponent.Child" with a replacement span of closing tag name
                var hasClosingAngleBracket = !!ts.findChildOfKind(jsxClosingElement, 31 /* GreaterThanToken */, sourceFile);
                var tagName = jsxClosingElement.parent.openingElement.tagName;
                var closingTag = tagName.getText(sourceFile);
                var fullClosingTag = closingTag + (hasClosingAngleBracket ? "" : ">");
                var replacementSpan = ts.createTextSpanFromNode(jsxClosingElement.tagName);
                var entry = {
                    name: fullClosingTag,
                    kind: "class" /* classElement */,
                    kindModifiers: undefined,
                    sortText: SortText.LocationPriority,
                };
                return { isGlobalCompletion: false, isMemberCompletion: true, isNewIdentifierLocation: false, optionalReplacementSpan: replacementSpan, entries: [entry] };
            }
            return;
        }
        function getJSCompletionEntries(sourceFile, position, uniqueNames, target, entries) {
            ts.getNameTable(sourceFile).forEach(function (pos, name) {
                // Skip identifiers produced only from the current location
                if (pos === position) {
                    return;
                }
                var realName = ts.unescapeLeadingUnderscores(name);
                if (!uniqueNames.has(realName) && ts.isIdentifierText(realName, target)) {
                    uniqueNames.add(realName);
                    entries.push({
                        name: realName,
                        kind: "warning" /* warning */,
                        kindModifiers: "",
                        sortText: SortText.JavascriptIdentifiers,
                        isFromUncheckedFile: true
                    });
                }
            });
        }
        function completionNameForLiteral(sourceFile, preferences, literal) {
            return typeof literal === "object" ? ts.pseudoBigIntToString(literal) + "n" :
                ts.isString(literal) ? ts.quote(sourceFile, preferences, literal) : JSON.stringify(literal);
        }
        function createCompletionEntryForLiteral(sourceFile, preferences, literal) {
            return { name: completionNameForLiteral(sourceFile, preferences, literal), kind: "string" /* string */, kindModifiers: "" /* none */, sortText: SortText.LocationPriority };
        }
        function createCompletionEntry(symbol, sortText, contextToken, location, sourceFile, typeChecker, name, needsConvertPropertyAccess, origin, recommendedCompletion, propertyAccessToConvert, isJsxInitializer, importCompletionNode, useSemicolons, options, preferences) {
            var _a;
            var insertText;
            var replacementSpan = ts.getReplacementSpanForContextToken(contextToken);
            var data;
            var isSnippet;
            var sourceDisplay;
            var hasAction;
            var insertQuestionDot = origin && originIsNullableMember(origin);
            var useBraces = origin && originIsSymbolMember(origin) || needsConvertPropertyAccess;
            if (origin && originIsThisType(origin)) {
                insertText = needsConvertPropertyAccess
                    ? "this" + (insertQuestionDot ? "?." : "") + "[" + quotePropertyName(sourceFile, preferences, name) + "]"
                    : "this" + (insertQuestionDot ? "?." : ".") + name;
            }
            // We should only have needsConvertPropertyAccess if there's a property access to convert. But see #21790.
            // Somehow there was a global with a non-identifier name. Hopefully someone will complain about getting a "foo bar" global completion and provide a repro.
            else if ((useBraces || insertQuestionDot) && propertyAccessToConvert) {
                insertText = useBraces ? needsConvertPropertyAccess ? "[" + quotePropertyName(sourceFile, preferences, name) + "]" : "[" + name + "]" : name;
                if (insertQuestionDot || propertyAccessToConvert.questionDotToken) {
                    insertText = "?." + insertText;
                }
                var dot = ts.findChildOfKind(propertyAccessToConvert, 24 /* DotToken */, sourceFile) ||
                    ts.findChildOfKind(propertyAccessToConvert, 28 /* QuestionDotToken */, sourceFile);
                if (!dot) {
                    return undefined;
                }
                // If the text after the '.' starts with this name, write over it. Else, add new text.
                var end = ts.startsWith(name, propertyAccessToConvert.name.text) ? propertyAccessToConvert.name.end : dot.end;
                replacementSpan = ts.createTextSpanFromBounds(dot.getStart(sourceFile), end);
            }
            if (isJsxInitializer) {
                if (insertText === undefined)
                    insertText = name;
                insertText = "{" + insertText + "}";
                if (typeof isJsxInitializer !== "boolean") {
                    replacementSpan = ts.createTextSpanFromNode(isJsxInitializer, sourceFile);
                }
            }
            if (origin && originIsPromise(origin) && propertyAccessToConvert) {
                if (insertText === undefined)
                    insertText = name;
                var precedingToken = ts.findPrecedingToken(propertyAccessToConvert.pos, sourceFile);
                var awaitText = "";
                if (precedingToken && ts.positionIsASICandidate(precedingToken.end, precedingToken.parent, sourceFile)) {
                    awaitText = ";";
                }
                awaitText += "(await " + propertyAccessToConvert.expression.getText() + ")";
                insertText = needsConvertPropertyAccess ? "" + awaitText + insertText : "" + awaitText + (insertQuestionDot ? "?." : ".") + insertText;
                replacementSpan = ts.createTextSpanFromBounds(propertyAccessToConvert.getStart(sourceFile), propertyAccessToConvert.end);
            }
            if (originIsResolvedExport(origin)) {
                sourceDisplay = [ts.textPart(origin.moduleSpecifier)];
                if (importCompletionNode) {
                    (_a = getInsertTextAndReplacementSpanForImportCompletion(name, importCompletionNode, origin, useSemicolons, options, preferences), insertText = _a.insertText, replacementSpan = _a.replacementSpan);
                    isSnippet = preferences.includeCompletionsWithSnippetText ? true : undefined;
                }
            }
            if (insertText !== undefined && !preferences.includeCompletionsWithInsertText) {
                return undefined;
            }
            if (originIsExport(origin) || originIsResolvedExport(origin)) {
                data = originToCompletionEntryData(origin);
                hasAction = !importCompletionNode;
            }
            // TODO(drosen): Right now we just permit *all* semantic meanings when calling
            // 'getSymbolKind' which is permissible given that it is backwards compatible; but
            // really we should consider passing the meaning for the node so that we don't report
            // that a suggestion for a value is an interface.  We COULD also just do what
            // 'getSymbolModifiers' does, which is to use the first declaration.
            // Use a 'sortText' of 0' so that all symbol completion entries come before any other
            // entries (like JavaScript identifier entries).
            return {
                name: name,
                kind: ts.SymbolDisplay.getSymbolKind(typeChecker, symbol, location),
                kindModifiers: ts.SymbolDisplay.getSymbolModifiers(typeChecker, symbol),
                sortText: sortText,
                source: getSourceFromOrigin(origin),
                hasAction: hasAction ? true : undefined,
                isRecommended: isRecommendedCompletionMatch(symbol, recommendedCompletion, typeChecker) || undefined,
                insertText: insertText,
                replacementSpan: replacementSpan,
                sourceDisplay: sourceDisplay,
                isSnippet: isSnippet,
                isPackageJsonImport: originIsPackageJsonImport(origin) || undefined,
                isImportStatementCompletion: !!importCompletionNode || undefined,
                data: data,
            };
        }
        function originToCompletionEntryData(origin) {
            return {
                exportName: origin.exportName,
                fileName: origin.fileName,
                ambientModuleName: origin.fileName ? undefined : ts.stripQuotes(origin.moduleSymbol.name),
                isPackageJsonImport: origin.isFromPackageJson ? true : undefined,
                moduleSpecifier: originIsResolvedExport(origin) ? origin.moduleSpecifier : undefined,
            };
        }
        function getInsertTextAndReplacementSpanForImportCompletion(name, importCompletionNode, origin, useSemicolons, options, preferences) {
            var sourceFile = importCompletionNode.getSourceFile();
            var replacementSpan = ts.createTextSpanFromNode(importCompletionNode, sourceFile);
            var quotedModuleSpecifier = ts.quote(sourceFile, preferences, origin.moduleSpecifier);
            var exportKind = origin.isDefaultExport ? 1 /* Default */ :
                origin.exportName === "export=" /* ExportEquals */ ? 2 /* ExportEquals */ :
                    0 /* Named */;
            var tabStop = preferences.includeCompletionsWithSnippetText ? "$1" : "";
            var importKind = ts.codefix.getImportKind(sourceFile, exportKind, options, /*forceImportKeyword*/ true);
            var suffix = useSemicolons ? ";" : "";
            switch (importKind) {
                case 3 /* CommonJS */: return { replacementSpan: replacementSpan, insertText: "import " + name + tabStop + " = require(" + quotedModuleSpecifier + ")" + suffix };
                case 1 /* Default */: return { replacementSpan: replacementSpan, insertText: "import " + name + tabStop + " from " + quotedModuleSpecifier + suffix };
                case 2 /* Namespace */: return { replacementSpan: replacementSpan, insertText: "import * as " + name + " from " + quotedModuleSpecifier + suffix };
                case 0 /* Named */: return { replacementSpan: replacementSpan, insertText: "import { " + name + tabStop + " } from " + quotedModuleSpecifier + suffix };
            }
        }
        function quotePropertyName(sourceFile, preferences, name) {
            if (/^\d+$/.test(name)) {
                return name;
            }
            return ts.quote(sourceFile, preferences, name);
        }
        function isRecommendedCompletionMatch(localSymbol, recommendedCompletion, checker) {
            return localSymbol === recommendedCompletion ||
                !!(localSymbol.flags & 1048576 /* ExportValue */) && checker.getExportSymbolOfSymbol(localSymbol) === recommendedCompletion;
        }
        function getSourceFromOrigin(origin) {
            if (originIsExport(origin)) {
                return ts.stripQuotes(origin.moduleSymbol.name);
            }
            if (originIsResolvedExport(origin)) {
                return origin.moduleSpecifier;
            }
            if ((origin === null || origin === void 0 ? void 0 : origin.kind) === 1 /* ThisType */) {
                return CompletionSource.ThisProperty;
            }
        }
        function getCompletionEntriesFromSymbols(symbols, entries, contextToken, location, sourceFile, typeChecker, target, log, kind, preferences, compilerOptions, isTypeOnlyLocation, propertyAccessToConvert, jsxIdentifierExpected, isJsxInitializer, importCompletionNode, recommendedCompletion, symbolToOriginInfoMap, symbolToSortTextIdMap) {
            var _a;
            var start = ts.timestamp();
            var variableDeclaration = getVariableDeclaration(location);
            var useSemicolons = ts.probablyUsesSemicolons(sourceFile);
            // Tracks unique names.
            // Value is set to false for global variables or completions from external module exports, because we can have multiple of those;
            // true otherwise. Based on the order we add things we will always see locals first, then globals, then module exports.
            // So adding a completion for a local will prevent us from adding completions for external module exports sharing the same name.
            var uniques = new ts.Map();
            for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                var origin = symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, !!jsxIdentifierExpected);
                if (!info || uniques.get(info.name) || kind === 1 /* Global */ && symbolToSortTextIdMap && !shouldIncludeSymbol(symbol, symbolToSortTextIdMap)) {
                    continue;
                }
                var name = info.name, needsConvertPropertyAccess = info.needsConvertPropertyAccess;
                var sortTextId = (_a = symbolToSortTextIdMap === null || symbolToSortTextIdMap === void 0 ? void 0 : symbolToSortTextIdMap[ts.getSymbolId(symbol)]) !== null && _a !== void 0 ? _a : 11 /* LocationPriority */;
                var sortText = (isDeprecated(symbol, typeChecker) ? 8 /* DeprecatedOffset */ + sortTextId : sortTextId).toString();
                var entry = createCompletionEntry(symbol, sortText, contextToken, location, sourceFile, typeChecker, name, needsConvertPropertyAccess, origin, recommendedCompletion, propertyAccessToConvert, isJsxInitializer, importCompletionNode, useSemicolons, compilerOptions, preferences);
                if (!entry) {
                    continue;
                }
                /** True for locals; false for globals, module exports from other files, `this.` completions. */
                var shouldShadowLaterSymbols = !origin && !(symbol.parent === undefined && !ts.some(symbol.declarations, function (d) { return d.getSourceFile() === location.getSourceFile(); }));
                uniques.set(name, shouldShadowLaterSymbols);
                entries.push(entry);
            }
            log("getCompletionsAtPosition: getCompletionEntriesFromSymbols: " + (ts.timestamp() - start));
            // Prevent consumers of this map from having to worry about
            // the boolean value. Externally, it should be seen as the
            // set of all names.
            return {
                has: function (name) { return uniques.has(name); },
                add: function (name) { return uniques.set(name, true); },
            };
            function shouldIncludeSymbol(symbol, symbolToSortTextIdMap) {
                if (!ts.isSourceFile(location)) {
                    // export = /**/ here we want to get all meanings, so any symbol is ok
                    if (ts.isExportAssignment(location.parent)) {
                        return true;
                    }
                    // Filter out variables from their own initializers
                    // `const a = /* no 'a' here */`
                    if (variableDeclaration && symbol.valueDeclaration === variableDeclaration) {
                        return false;
                    }
                    // External modules can have global export declarations that will be
                    // available as global keywords in all scopes. But if the external module
                    // already has an explicit export and user only wants to user explicit
                    // module imports then the global keywords will be filtered out so auto
                    // import suggestions will win in the completion
                    var symbolOrigin = ts.skipAlias(symbol, typeChecker);
                    // We only want to filter out the global keywords
                    // Auto Imports are not available for scripts so this conditional is always false
                    if (!!sourceFile.externalModuleIndicator
                        && !compilerOptions.allowUmdGlobalAccess
                        && symbolToSortTextIdMap[ts.getSymbolId(symbol)] === 15 /* GlobalsOrKeywords */
                        && (symbolToSortTextIdMap[ts.getSymbolId(symbolOrigin)] === 16 /* AutoImportSuggestions */
                            || symbolToSortTextIdMap[ts.getSymbolId(symbolOrigin)] === 11 /* LocationPriority */)) {
                        return false;
                    }
                    // Continue with origin symbol
                    symbol = symbolOrigin;
                    // import m = /**/ <-- It can only access namespace (if typing import = x. this would get member symbols and not namespace)
                    if (ts.isInRightSideOfInternalImportEqualsDeclaration(location)) {
                        return !!(symbol.flags & 1920 /* Namespace */);
                    }
                    if (isTypeOnlyLocation) {
                        // It's a type, but you can reach it by namespace.type as well
                        return symbolCanBeReferencedAtTypeLocation(symbol, typeChecker);
                    }
                }
                // expressions are value space (which includes the value namespaces)
                return !!(ts.getCombinedLocalAndExportSymbolFlags(symbol) & 111551 /* Value */);
            }
        }
        Completions.getCompletionEntriesFromSymbols = getCompletionEntriesFromSymbols;
        function getLabelCompletionAtPosition(node) {
            var entries = getLabelStatementCompletions(node);
            if (entries.length) {
                return { isGlobalCompletion: false, isMemberCompletion: false, isNewIdentifierLocation: false, entries: entries };
            }
        }
        function getLabelStatementCompletions(node) {
            var entries = [];
            var uniques = new ts.Map();
            var current = node;
            while (current) {
                if (ts.isFunctionLike(current)) {
                    break;
                }
                if (ts.isLabeledStatement(current)) {
                    var name = current.label.text;
                    if (!uniques.has(name)) {
                        uniques.set(name, true);
                        entries.push({
                            name: name,
                            kindModifiers: "" /* none */,
                            kind: "label" /* label */,
                            sortText: SortText.LocationPriority
                        });
                    }
                }
                current = current.parent;
            }
            return entries;
        }
        function getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences) {
            if (entryId.data) {
                var autoImport = getAutoImportSymbolFromCompletionEntryData(entryId.name, entryId.data, program, host);
                if (autoImport) {
                    return {
                        type: "symbol",
                        symbol: autoImport.symbol,
                        location: ts.getTouchingPropertyName(sourceFile, position),
                        previousToken: ts.findPrecedingToken(position, sourceFile, /*startNode*/ undefined),
                        isJsxInitializer: false,
                        isTypeOnlyLocation: false,
                        origin: autoImport.origin,
                    };
                }
            }
            var compilerOptions = program.getCompilerOptions();
            var completionData = getCompletionData(program, log, sourceFile, isUncheckedFile(sourceFile, compilerOptions), position, { includeCompletionsForModuleExports: true, includeCompletionsWithInsertText: true }, entryId, host);
            if (!completionData) {
                return { type: "none" };
            }
            if (completionData.kind !== 0 /* Data */) {
                return { type: "request", request: completionData };
            }
            var symbols = completionData.symbols, literals = completionData.literals, location = completionData.location, completionKind = completionData.completionKind, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, previousToken = completionData.previousToken, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation;
            var literal = ts.find(literals, function (l) { return completionNameForLiteral(sourceFile, preferences, l) === entryId.name; });
            if (literal !== undefined)
                return { type: "literal", literal: literal };
            // Find the symbol with the matching entry name.
            // We don't need to perform character checks here because we're only comparing the
            // name against 'entryName' (which is known to be good), not building a new
            // completion entry.
            return ts.firstDefined(symbols, function (symbol, index) {
                var origin = symbolToOriginInfoMap[index];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, compilerOptions.target, origin, completionKind, completionData.isJsxIdentifierExpected);
                return info && info.name === entryId.name && getSourceFromOrigin(origin) === entryId.source
                    ? { type: "symbol", symbol: symbol, location: location, origin: origin, previousToken: previousToken, isJsxInitializer: isJsxInitializer, isTypeOnlyLocation: isTypeOnlyLocation }
                    : undefined;
            }) || { type: "none" };
        }
        function getCompletionEntryDetails(program, log, sourceFile, position, entryId, host, formatContext, preferences, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var name = entryId.name;
            var contextToken = ts.findPrecedingToken(position, sourceFile);
            if (ts.isInString(sourceFile, position, contextToken)) {
                return Completions.StringCompletions.getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, typeChecker, compilerOptions, host, cancellationToken, preferences);
            }
            // Compute all the completion symbols again.
            var symbolCompletion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            switch (symbolCompletion.type) {
                case "request": {
                    var request = symbolCompletion.request;
                    switch (request.kind) {
                        case 1 /* JsDocTagName */:
                            return ts.JsDoc.getJSDocTagNameCompletionDetails(name);
                        case 2 /* JsDocTag */:
                            return ts.JsDoc.getJSDocTagCompletionDetails(name);
                        case 3 /* JsDocParameterName */:
                            return ts.JsDoc.getJSDocParameterNameCompletionDetails(name);
                        case 4 /* Keywords */:
                            return request.keywords.indexOf(ts.stringToToken(name)) > -1 ? createSimpleDetails(name, "keyword" /* keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                        default:
                            return ts.Debug.assertNever(request);
                    }
                }
                case "symbol": {
                    var symbol = symbolCompletion.symbol, location = symbolCompletion.location, origin = symbolCompletion.origin, previousToken = symbolCompletion.previousToken;
                    var _a = getCompletionEntryCodeActionsAndSourceDisplay(origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, entryId.data), codeActions = _a.codeActions, sourceDisplay = _a.sourceDisplay;
                    return createCompletionDetailsForSymbol(symbol, typeChecker, sourceFile, location, cancellationToken, codeActions, sourceDisplay); // TODO: GH#18217
                }
                case "literal": {
                    var literal = symbolCompletion.literal;
                    return createSimpleDetails(completionNameForLiteral(sourceFile, preferences, literal), "string" /* string */, typeof literal === "string" ? ts.SymbolDisplayPartKind.stringLiteral : ts.SymbolDisplayPartKind.numericLiteral);
                }
                case "none":
                    // Didn't find a symbol with this name.  See if we can find a keyword instead.
                    return allKeywordsCompletions().some(function (c) { return c.name === name; }) ? createSimpleDetails(name, "keyword" /* keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                default:
                    ts.Debug.assertNever(symbolCompletion);
            }
        }
        Completions.getCompletionEntryDetails = getCompletionEntryDetails;
        function createSimpleDetails(name, kind, kind2) {
            return createCompletionDetails(name, "" /* none */, kind, [ts.displayPart(name, kind2)]);
        }
        function createCompletionDetailsForSymbol(symbol, checker, sourceFile, location, cancellationToken, codeActions, sourceDisplay) {
            var _a = checker.runWithCancellationToken(cancellationToken, function (checker) {
                return ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(checker, symbol, sourceFile, location, location, 7 /* All */);
            }), displayParts = _a.displayParts, documentation = _a.documentation, symbolKind = _a.symbolKind, tags = _a.tags;
            return createCompletionDetails(symbol.name, ts.SymbolDisplay.getSymbolModifiers(checker, symbol), symbolKind, displayParts, documentation, tags, codeActions, sourceDisplay);
        }
        Completions.createCompletionDetailsForSymbol = createCompletionDetailsForSymbol;
        function createCompletionDetails(name, kindModifiers, kind, displayParts, documentation, tags, codeActions, source) {
            return { name: name, kindModifiers: kindModifiers, kind: kind, displayParts: displayParts, documentation: documentation, tags: tags, codeActions: codeActions, source: source, sourceDisplay: source };
        }
        Completions.createCompletionDetails = createCompletionDetails;
        function getCompletionEntryCodeActionsAndSourceDisplay(origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, data) {
            if (data === null || data === void 0 ? void 0 : data.moduleSpecifier) {
                var _a = getRelevantTokens(position, sourceFile), contextToken = _a.contextToken, previousToken_1 = _a.previousToken;
                if (previousToken_1 && getImportCompletionNode(contextToken || previousToken_1)) {
                    // Import statement completion: 'import c|'
                    return { codeActions: undefined, sourceDisplay: [ts.textPart(data.moduleSpecifier)] };
                }
            }
            if (!origin || !(originIsExport(origin) || originIsResolvedExport(origin))) {
                return { codeActions: undefined, sourceDisplay: undefined };
            }
            var checker = origin.isFromPackageJson ? host.getPackageJsonAutoImportProvider().getTypeChecker() : program.getTypeChecker();
            var moduleSymbol = origin.moduleSymbol;
            var exportedSymbol = checker.getMergedSymbol(ts.skipAlias(symbol.exportSymbol || symbol, checker));
            var _b = ts.codefix.getImportCompletionAction(exportedSymbol, moduleSymbol, sourceFile, ts.getNameForExportedSymbol(symbol, compilerOptions.target), host, program, formatContext, previousToken && ts.isIdentifier(previousToken) ? previousToken.getStart(sourceFile) : position, preferences), moduleSpecifier = _b.moduleSpecifier, codeAction = _b.codeAction;
            ts.Debug.assert(!(data === null || data === void 0 ? void 0 : data.moduleSpecifier) || moduleSpecifier === data.moduleSpecifier);
            return { sourceDisplay: [ts.textPart(moduleSpecifier)], codeActions: [codeAction] };
        }
        function getCompletionEntrySymbol(program, log, sourceFile, position, entryId, host, preferences) {
            var completion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            return completion.type === "symbol" ? completion.symbol : undefined;
        }
        Completions.getCompletionEntrySymbol = getCompletionEntrySymbol;
        var CompletionDataKind;
        (function (CompletionDataKind) {
            CompletionDataKind[CompletionDataKind["Data"] = 0] = "Data";
            CompletionDataKind[CompletionDataKind["JsDocTagName"] = 1] = "JsDocTagName";
            CompletionDataKind[CompletionDataKind["JsDocTag"] = 2] = "JsDocTag";
            CompletionDataKind[CompletionDataKind["JsDocParameterName"] = 3] = "JsDocParameterName";
            CompletionDataKind[CompletionDataKind["Keywords"] = 4] = "Keywords";
        })(CompletionDataKind || (CompletionDataKind = {}));
        var CompletionKind;
        (function (CompletionKind) {
            CompletionKind[CompletionKind["ObjectPropertyDeclaration"] = 0] = "ObjectPropertyDeclaration";
            CompletionKind[CompletionKind["Global"] = 1] = "Global";
            CompletionKind[CompletionKind["PropertyAccess"] = 2] = "PropertyAccess";
            CompletionKind[CompletionKind["MemberLike"] = 3] = "MemberLike";
            CompletionKind[CompletionKind["String"] = 4] = "String";
            CompletionKind[CompletionKind["None"] = 5] = "None";
        })(CompletionKind = Completions.CompletionKind || (Completions.CompletionKind = {}));
        function getRecommendedCompletion(previousToken, contextualType, checker) {
            // For a union, return the first one with a recommended completion.
            return ts.firstDefined(contextualType && (contextualType.isUnion() ? contextualType.types : [contextualType]), function (type) {
                var symbol = type && type.symbol;
                // Don't include make a recommended completion for an abstract class
                return symbol && (symbol.flags & (8 /* EnumMember */ | 384 /* Enum */ | 32 /* Class */) && !ts.isAbstractConstructorSymbol(symbol))
                    ? getFirstSymbolInChain(symbol, previousToken, checker)
                    : undefined;
            });
        }
        function getContextualType(previousToken, position, sourceFile, checker) {
            var parent = previousToken.parent;
            switch (previousToken.kind) {
                case 79 /* Identifier */:
                    return ts.getContextualTypeFromParent(previousToken, checker);
                case 63 /* EqualsToken */:
                    switch (parent.kind) {
                        case 252 /* VariableDeclaration */:
                            return checker.getContextualType(parent.initializer); // TODO: GH#18217
                        case 219 /* BinaryExpression */:
                            return checker.getTypeAtLocation(parent.left);
                        case 283 /* JsxAttribute */:
                            return checker.getContextualTypeForJsxAttribute(parent);
                        default:
                            return undefined;
                    }
                case 103 /* NewKeyword */:
                    return checker.getContextualType(parent);
                case 82 /* CaseKeyword */:
                    return ts.getSwitchedType(ts.cast(parent, ts.isCaseClause), checker);
                case 18 /* OpenBraceToken */:
                    return ts.isJsxExpression(parent) && parent.parent.kind !== 276 /* JsxElement */ ? checker.getContextualTypeForJsxAttribute(parent.parent) : undefined;
                default:
                    var argInfo = ts.SignatureHelp.getArgumentInfoForCompletions(previousToken, position, sourceFile);
                    return argInfo ?
                        // At `,`, treat this as the next argument after the comma.
                        checker.getContextualTypeForArgumentAtIndex(argInfo.invocation, argInfo.argumentIndex + (previousToken.kind === 27 /* CommaToken */ ? 1 : 0)) :
                        ts.isEqualityOperatorKind(previousToken.kind) && ts.isBinaryExpression(parent) && ts.isEqualityOperatorKind(parent.operatorToken.kind) ?
                            // completion at `x ===/**/` should be for the right side
                            checker.getTypeAtLocation(parent.left) :
                            checker.getContextualType(previousToken);
            }
        }
        function getFirstSymbolInChain(symbol, enclosingDeclaration, checker) {
            var chain = checker.getAccessibleSymbolChain(symbol, enclosingDeclaration, /*meaning*/ 67108863 /* All */, /*useOnlyExternalAliasing*/ false);
            if (chain)
                return ts.first(chain);
            return symbol.parent && (isModuleSymbol(symbol.parent) ? symbol : getFirstSymbolInChain(symbol.parent, enclosingDeclaration, checker));
        }
        function isModuleSymbol(symbol) {
            var _a;
            return !!((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.kind === 300 /* SourceFile */; }));
        }
        function getCompletionData(program, log, sourceFile, isUncheckedFile, position, preferences, detailsEntryId, host, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var start = ts.timestamp();
            var currentToken = ts.getTokenAtPosition(sourceFile, position); // TODO: GH#15853
            // We will check for jsdoc comments with insideComment and getJsDocTagAtPosition. (TODO: that seems rather inefficient to check the same thing so many times.)
            log("getCompletionData: Get current token: " + (ts.timestamp() - start));
            start = ts.timestamp();
            var insideComment = ts.isInComment(sourceFile, position, currentToken);
            log("getCompletionData: Is inside comment: " + (ts.timestamp() - start));
            var insideJsDocTagTypeExpression = false;
            var isInSnippetScope = false;
            if (insideComment) {
                if (ts.hasDocComment(sourceFile, position)) {
                    if (sourceFile.text.charCodeAt(position - 1) === 64 /* at */) {
                        // The current position is next to the '@' sign, when no tag name being provided yet.
                        // Provide a full list of tag names
                        return { kind: 1 /* JsDocTagName */ };
                    }
                    else {
                        // When completion is requested without "@", we will have check to make sure that
                        // there are no comments prefix the request position. We will only allow "*" and space.
                        // e.g
                        //   /** |c| /*
                        //
                        //   /**
                        //     |c|
                        //    */
                        //
                        //   /**
                        //    * |c|
                        //    */
                        //
                        //   /**
                        //    *         |c|
                        //    */
                        var lineStart = ts.getLineStartPositionForPosition(position, sourceFile);
                        if (!/[^\*|\s(/)]/.test(sourceFile.text.substring(lineStart, position))) {
                            return { kind: 2 /* JsDocTag */ };
                        }
                    }
                }
                // Completion should work inside certain JsDoc tags. For example:
                //     /** @type {number | string} */
                // Completion should work in the brackets
                var tag = getJsDocTagAtPosition(currentToken, position);
                if (tag) {
                    if (tag.tagName.pos <= position && position <= tag.tagName.end) {
                        return { kind: 1 /* JsDocTagName */ };
                    }
                    if (isTagWithTypeExpression(tag) && tag.typeExpression && tag.typeExpression.kind === 304 /* JSDocTypeExpression */) {
                        currentToken = ts.getTokenAtPosition(sourceFile, position);
                        if (!currentToken ||
                            (!ts.isDeclarationName(currentToken) &&
                                (currentToken.parent.kind !== 342 /* JSDocPropertyTag */ ||
                                    currentToken.parent.name !== currentToken))) {
                            // Use as type location if inside tag's type expression
                            insideJsDocTagTypeExpression = isCurrentlyEditingNode(tag.typeExpression);
                        }
                    }
                    if (!insideJsDocTagTypeExpression && ts.isJSDocParameterTag(tag) && (ts.nodeIsMissing(tag.name) || tag.name.pos <= position && position <= tag.name.end)) {
                        return { kind: 3 /* JsDocParameterName */, tag: tag };
                    }
                }
                if (!insideJsDocTagTypeExpression) {
                    // Proceed if the current position is in jsDoc tag expression; otherwise it is a normal
                    // comment or the plain text part of a jsDoc comment, so no completion should be available
                    log("Returning an empty list because completion was inside a regular comment or plain text part of a JsDoc comment.");
                    return undefined;
                }
            }
            start = ts.timestamp();
            // The decision to provide completion depends on the contextToken, which is determined through the previousToken.
            // Note: 'previousToken' (and thus 'contextToken') can be undefined if we are the beginning of the file
            var tokens = getRelevantTokens(position, sourceFile);
            var previousToken = tokens.previousToken;
            var contextToken = tokens.contextToken;
            log("getCompletionData: Get previous token: " + (ts.timestamp() - start));
            // Find the node where completion is requested on.
            // Also determine whether we are trying to complete with members of that node
            // or attributes of a JSX tag.
            var node = currentToken;
            var propertyAccessToConvert;
            var isRightOfDot = false;
            var isRightOfQuestionDot = false;
            var isRightOfOpenTag = false;
            var isStartingCloseTag = false;
            var isJsxInitializer = false;
            var isJsxIdentifierExpected = false;
            var importCompletionNode;
            var location = ts.getTouchingPropertyName(sourceFile, position);
            if (contextToken) {
                var importCompletionCandidate = getImportCompletionNode(contextToken);
                if (importCompletionCandidate === 154 /* FromKeyword */) {
                    return { kind: 4 /* Keywords */, keywords: [154 /* FromKeyword */] };
                }
                // Import statement completions use `insertText`, and also require the `data` property of `CompletionEntryIdentifier`
                // added in TypeScript 4.3 to be sent back from the client during `getCompletionEntryDetails`. Since this feature
                // is not backward compatible with older clients, the language service defaults to disabling it, allowing newer clients
                // to opt in with the `includeCompletionsForImportStatements` user preference.
                if (importCompletionCandidate && preferences.includeCompletionsForImportStatements && preferences.includeCompletionsWithInsertText) {
                    importCompletionNode = importCompletionCandidate;
                }
                // Bail out if this is a known invalid completion location
                if (!importCompletionNode && isCompletionListBlocker(contextToken)) {
                    log("Returning an empty list because completion was requested in an invalid position.");
                    return undefined;
                }
                var parent = contextToken.parent;
                if (contextToken.kind === 24 /* DotToken */ || contextToken.kind === 28 /* QuestionDotToken */) {
                    isRightOfDot = contextToken.kind === 24 /* DotToken */;
                    isRightOfQuestionDot = contextToken.kind === 28 /* QuestionDotToken */;
                    switch (parent.kind) {
                        case 204 /* PropertyAccessExpression */:
                            propertyAccessToConvert = parent;
                            node = propertyAccessToConvert.expression;
                            var leftmostAccessExpression = ts.getLeftmostAccessExpression(propertyAccessToConvert);
                            if (ts.nodeIsMissing(leftmostAccessExpression) ||
                                ((ts.isCallExpression(node) || ts.isFunctionLike(node)) &&
                                    node.end === contextToken.pos &&
                                    node.getChildCount(sourceFile) &&
                                    ts.last(node.getChildren(sourceFile)).kind !== 21 /* CloseParenToken */)) {
                                // This is likely dot from incorrectly parsed expression and user is starting to write spread
                                // eg: Math.min(./**/)
                                // const x = function (./**/) {}
                                // ({./**/})
                                return undefined;
                            }
                            break;
                        case 159 /* QualifiedName */:
                            node = parent.left;
                            break;
                        case 259 /* ModuleDeclaration */:
                            node = parent.name;
                            break;
                        case 198 /* ImportType */:
                            node = parent;
                            break;
                        case 229 /* MetaProperty */:
                            node = parent.getFirstToken(sourceFile);
                            ts.Debug.assert(node.kind === 100 /* ImportKeyword */ || node.kind === 103 /* NewKeyword */);
                            break;
                        default:
                            // There is nothing that precedes the dot, so this likely just a stray character
                            // or leading into a '...' token. Just bail out instead.
                            return undefined;
                    }
                }
                else if (!importCompletionNode && sourceFile.languageVariant === 1 /* JSX */) {
                    // <UI.Test /* completion position */ />
                    // If the tagname is a property access expression, we will then walk up to the top most of property access expression.
                    // Then, try to get a JSX container and its associated attributes type.
                    if (parent && parent.kind === 204 /* PropertyAccessExpression */) {
                        contextToken = parent;
                        parent = parent.parent;
                    }
                    // Fix location
                    if (currentToken.parent === location) {
                        switch (currentToken.kind) {
                            case 31 /* GreaterThanToken */:
                                if (currentToken.parent.kind === 276 /* JsxElement */ || currentToken.parent.kind === 278 /* JsxOpeningElement */) {
                                    location = currentToken;
                                }
                                break;
                            case 43 /* SlashToken */:
                                if (currentToken.parent.kind === 277 /* JsxSelfClosingElement */) {
                                    location = currentToken;
                                }
                                break;
                        }
                    }
                    switch (parent.kind) {
                        case 279 /* JsxClosingElement */:
                            if (contextToken.kind === 43 /* SlashToken */) {
                                isStartingCloseTag = true;
                                location = contextToken;
                            }
                            break;
                        case 219 /* BinaryExpression */:
                            if (!binaryExpressionMayBeOpenTag(parent)) {
                                break;
                            }
                        // falls through
                        case 277 /* JsxSelfClosingElement */:
                        case 276 /* JsxElement */:
                        case 278 /* JsxOpeningElement */:
                            isJsxIdentifierExpected = true;
                            if (contextToken.kind === 29 /* LessThanToken */) {
                                isRightOfOpenTag = true;
                                location = contextToken;
                            }
                            break;
                        case 286 /* JsxExpression */:
                        case 285 /* JsxSpreadAttribute */:
                            // For `<div foo={true} [||] ></div>`, `parent` will be `{true}` and `previousToken` will be `}`
                            if (previousToken.kind === 19 /* CloseBraceToken */ && currentToken.kind === 31 /* GreaterThanToken */) {
                                isJsxIdentifierExpected = true;
                            }
                            break;
                        case 283 /* JsxAttribute */:
                            // For `<div className="x" [||] ></div>`, `parent` will be JsxAttribute and `previousToken` will be its initializer
                            if (parent.initializer === previousToken &&
                                previousToken.end < position) {
                                isJsxIdentifierExpected = true;
                                break;
                            }
                            switch (previousToken.kind) {
                                case 63 /* EqualsToken */:
                                    isJsxInitializer = true;
                                    break;
                                case 79 /* Identifier */:
                                    isJsxIdentifierExpected = true;
                                    // For `<div x=[|f/**/|]`, `parent` will be `x` and `previousToken.parent` will be `f` (which is its own JsxAttribute)
                                    // Note for `<div someBool f>` we don't want to treat this as a jsx inializer, instead it's the attribute name.
                                    if (parent !== previousToken.parent &&
                                        !parent.initializer &&
                                        ts.findChildOfKind(parent, 63 /* EqualsToken */, sourceFile)) {
                                        isJsxInitializer = previousToken;
                                    }
                            }
                            break;
                    }
                }
            }
            var semanticStart = ts.timestamp();
            var completionKind = 5 /* None */;
            var isNewIdentifierLocation = false;
            var isNonContextualObjectLiteral = false;
            var hasUnresolvedAutoImports = false;
            var keywordFilters = 0 /* None */;
            // This also gets mutated in nested-functions after the return
            var symbols = [];
            var symbolToOriginInfoMap = [];
            var symbolToSortTextIdMap = [];
            var seenPropertySymbols = new ts.Map();
            var isTypeOnlyLocation = isTypeOnlyCompletion();
            var getModuleSpecifierResolutionHost = ts.memoizeOne(function (isFromPackageJson) {
                return ts.createModuleSpecifierResolutionHost(isFromPackageJson ? host.getPackageJsonAutoImportProvider() : program, host);
            });
            if (isRightOfDot || isRightOfQuestionDot) {
                getTypeScriptMemberSymbols();
            }
            else if (isRightOfOpenTag) {
                symbols = typeChecker.getJsxIntrinsicTagNamesAt(location);
                ts.Debug.assertEachIsDefined(symbols, "getJsxIntrinsicTagNames() should all be defined");
                tryGetGlobalSymbols();
                completionKind = 1 /* Global */;
                keywordFilters = 0 /* None */;
            }
            else if (isStartingCloseTag) {
                var tagName = contextToken.parent.parent.openingElement.tagName;
                var tagSymbol = typeChecker.getSymbolAtLocation(tagName);
                if (tagSymbol) {
                    symbols = [tagSymbol];
                }
                completionKind = 1 /* Global */;
                keywordFilters = 0 /* None */;
            }
            else {
                // For JavaScript or TypeScript, if we're not after a dot, then just try to get the
                // global symbols in scope.  These results should be valid for either language as
                // the set of symbols that can be referenced from this location.
                if (!tryGetGlobalSymbols()) {
                    return undefined;
                }
            }
            log("getCompletionData: Semantic work: " + (ts.timestamp() - semanticStart));
            var contextualType = previousToken && getContextualType(previousToken, position, sourceFile, typeChecker);
            var literals = ts.mapDefined(contextualType && (contextualType.isUnion() ? contextualType.types : [contextualType]), function (t) { return t.isLiteral() ? t.value : undefined; });
            var recommendedCompletion = previousToken && contextualType && getRecommendedCompletion(previousToken, contextualType, typeChecker);
            return {
                kind: 0 /* Data */,
                symbols: symbols,
                completionKind: completionKind,
                isInSnippetScope: isInSnippetScope,
                propertyAccessToConvert: propertyAccessToConvert,
                isNewIdentifierLocation: isNewIdentifierLocation,
                location: location,
                keywordFilters: keywordFilters,
                literals: literals,
                symbolToOriginInfoMap: symbolToOriginInfoMap,
                recommendedCompletion: recommendedCompletion,
                previousToken: previousToken,
                isJsxInitializer: isJsxInitializer,
                insideJsDocTagTypeExpression: insideJsDocTagTypeExpression,
                symbolToSortTextIdMap: symbolToSortTextIdMap,
                isTypeOnlyLocation: isTypeOnlyLocation,
                isJsxIdentifierExpected: isJsxIdentifierExpected,
                importCompletionNode: importCompletionNode,
                hasUnresolvedAutoImports: hasUnresolvedAutoImports,
            };
            function isTagWithTypeExpression(tag) {
                switch (tag.kind) {
                    case 335 /* JSDocParameterTag */:
                    case 342 /* JSDocPropertyTag */:
                    case 336 /* JSDocReturnTag */:
                    case 338 /* JSDocTypeTag */:
                    case 340 /* JSDocTypedefTag */:
                        return true;
                    default:
                        return false;
                }
            }
            function getTypeScriptMemberSymbols() {
                // Right of dot member completion list
                completionKind = 2 /* PropertyAccess */;
                // Since this is qualified name check it's a type node location
                var isImportType = ts.isLiteralImportTypeNode(node);
                var isTypeLocation = insideJsDocTagTypeExpression
                    || (isImportType && !node.isTypeOf)
                    || ts.isPartOfTypeNode(node.parent)
                    || ts.isPossiblyTypeArgumentPosition(contextToken, sourceFile, typeChecker);
                var isRhsOfImportDeclaration = ts.isInRightSideOfInternalImportEqualsDeclaration(node);
                if (ts.isEntityName(node) || isImportType || ts.isPropertyAccessExpression(node)) {
                    var isNamespaceName = ts.isModuleDeclaration(node.parent);
                    if (isNamespaceName)
                        isNewIdentifierLocation = true;
                    var symbol = typeChecker.getSymbolAtLocation(node);
                    if (symbol) {
                        symbol = ts.skipAlias(symbol, typeChecker);
                        if (symbol.flags & (1536 /* Module */ | 384 /* Enum */)) {
                            // Extract module or enum members
                            var exportedSymbols = typeChecker.getExportsOfModule(symbol);
                            ts.Debug.assertEachIsDefined(exportedSymbols, "getExportsOfModule() should all be defined");
                            var isValidValueAccess_1 = function (symbol) { return typeChecker.isValidPropertyAccess(isImportType ? node : node.parent, symbol.name); };
                            var isValidTypeAccess_1 = function (symbol) { return symbolCanBeReferencedAtTypeLocation(symbol, typeChecker); };
                            var isValidAccess = isNamespaceName
                                // At `namespace N.M/**/`, if this is the only declaration of `M`, don't include `M` as a completion.
                                ? function (symbol) { var _a; return !!(symbol.flags & 1920 /* Namespace */) && !((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.every(function (d) { return d.parent === node.parent; })); }
                                : isRhsOfImportDeclaration ?
                                    // Any kind is allowed when dotting off namespace in internal import equals declaration
                                    function (symbol) { return isValidTypeAccess_1(symbol) || isValidValueAccess_1(symbol); } :
                                    isTypeLocation ? isValidTypeAccess_1 : isValidValueAccess_1;
                            for (var _i = 0, exportedSymbols_1 = exportedSymbols; _i < exportedSymbols_1.length; _i++) {
                                var exportedSymbol = exportedSymbols_1[_i];
                                if (isValidAccess(exportedSymbol)) {
                                    symbols.push(exportedSymbol);
                                }
                            }
                            // If the module is merged with a value, we must get the type of the class and add its propertes (for inherited static methods).
                            if (!isTypeLocation &&
                                symbol.declarations &&
                                symbol.declarations.some(function (d) { return d.kind !== 300 /* SourceFile */ && d.kind !== 259 /* ModuleDeclaration */ && d.kind !== 258 /* EnumDeclaration */; })) {
                                var type = typeChecker.getTypeOfSymbolAtLocation(symbol, node).getNonOptionalType();
                                var insertQuestionDot = false;
                                if (type.isNullableType()) {
                                    var canCorrectToQuestionDot = isRightOfDot &&
                                        !isRightOfQuestionDot &&
                                        preferences.includeAutomaticOptionalChainCompletions !== false;
                                    if (canCorrectToQuestionDot || isRightOfQuestionDot) {
                                        type = type.getNonNullableType();
                                        if (canCorrectToQuestionDot) {
                                            insertQuestionDot = true;
                                        }
                                    }
                                }
                                addTypeProperties(type, !!(node.flags & 32768 /* AwaitContext */), insertQuestionDot);
                            }
                            return;
                        }
                    }
                }
                if (!isTypeLocation) {
                    // GH#39946. Pulling on the type of a node inside of a function with a contextual `this` parameter can result in a circularity
                    // if the `node` is part of the exprssion of a `yield` or `return`. This circularity doesn't exist at compile time because
                    // we will check (and cache) the type of `this` *before* checking the type of the node.
                    var container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
                    if (!ts.isSourceFile(container) && container.parent)
                        typeChecker.getTypeAtLocation(container);
                    var type = typeChecker.getTypeAtLocation(node).getNonOptionalType();
                    var insertQuestionDot = false;
                    if (type.isNullableType()) {
                        var canCorrectToQuestionDot = isRightOfDot &&
                            !isRightOfQuestionDot &&
                            preferences.includeAutomaticOptionalChainCompletions !== false;
                        if (canCorrectToQuestionDot || isRightOfQuestionDot) {
                            type = type.getNonNullableType();
                            if (canCorrectToQuestionDot) {
                                insertQuestionDot = true;
                            }
                        }
                    }
                    addTypeProperties(type, !!(node.flags & 32768 /* AwaitContext */), insertQuestionDot);
                }
            }
            function addTypeProperties(type, insertAwait, insertQuestionDot) {
                isNewIdentifierLocation = !!type.getStringIndexType();
                if (isRightOfQuestionDot && ts.some(type.getCallSignatures())) {
                    isNewIdentifierLocation = true;
                }
                var propertyAccess = node.kind === 198 /* ImportType */ ? node : node.parent;
                if (isUncheckedFile) {
                    // In javascript files, for union types, we don't just get the members that
                    // the individual types have in common, we also include all the members that
                    // each individual type has. This is because we're going to add all identifiers
                    // anyways. So we might as well elevate the members that were at least part
                    // of the individual types to a higher status since we know what they are.
                    symbols.push.apply(symbols, ts.filter(getPropertiesForCompletion(type, typeChecker), function (s) { return typeChecker.isValidPropertyAccessForCompletions(propertyAccess, type, s); }));
                }
                else {
                    for (var _i = 0, _a = type.getApparentProperties(); _i < _a.length; _i++) {
                        var symbol = _a[_i];
                        if (typeChecker.isValidPropertyAccessForCompletions(propertyAccess, type, symbol)) {
                            addPropertySymbol(symbol, /* insertAwait */ false, insertQuestionDot);
                        }
                    }
                }
                if (insertAwait && preferences.includeCompletionsWithInsertText) {
                    var promiseType = typeChecker.getPromisedTypeOfPromise(type);
                    if (promiseType) {
                        for (var _b = 0, _c = promiseType.getApparentProperties(); _b < _c.length; _b++) {
                            var symbol = _c[_b];
                            if (typeChecker.isValidPropertyAccessForCompletions(propertyAccess, promiseType, symbol)) {
                                addPropertySymbol(symbol, /* insertAwait */ true, insertQuestionDot);
                            }
                        }
                    }
                }
            }
            function addPropertySymbol(symbol, insertAwait, insertQuestionDot) {
                // For a computed property with an accessible name like `Symbol.iterator`,
                // we'll add a completion for the *name* `Symbol` instead of for the property.
                // If this is e.g. [Symbol.iterator], add a completion for `Symbol`.
                var computedPropertyName = ts.firstDefined(symbol.declarations, function (decl) { return ts.tryCast(ts.getNameOfDeclaration(decl), ts.isComputedPropertyName); });
                if (computedPropertyName) {
                    var leftMostName = getLeftMostName(computedPropertyName.expression); // The completion is for `Symbol`, not `iterator`.
                    var nameSymbol = leftMostName && typeChecker.getSymbolAtLocation(leftMostName);
                    // If this is nested like for `namespace N { export const sym = Symbol(); }`, we'll add the completion for `N`.
                    var firstAccessibleSymbol = nameSymbol && getFirstSymbolInChain(nameSymbol, contextToken, typeChecker);
                    if (firstAccessibleSymbol && ts.addToSeen(seenPropertySymbols, ts.getSymbolId(firstAccessibleSymbol))) {
                        var index = symbols.length;
                        symbols.push(firstAccessibleSymbol);
                        var moduleSymbol = firstAccessibleSymbol.parent;
                        if (!moduleSymbol || !ts.isExternalModuleSymbol(moduleSymbol)) {
                            symbolToOriginInfoMap[index] = { kind: getNullableSymbolOriginInfoKind(2 /* SymbolMemberNoExport */) };
                        }
                        else {
                            var origin = {
                                kind: getNullableSymbolOriginInfoKind(6 /* SymbolMemberExport */),
                                moduleSymbol: moduleSymbol,
                                isDefaultExport: false,
                                symbolName: firstAccessibleSymbol.name,
                                exportName: firstAccessibleSymbol.name,
                                fileName: ts.isExternalModuleNameRelative(ts.stripQuotes(moduleSymbol.name)) ? ts.cast(moduleSymbol.valueDeclaration, ts.isSourceFile).fileName : undefined,
                            };
                            symbolToOriginInfoMap[index] = origin;
                        }
                    }
                    else if (preferences.includeCompletionsWithInsertText) {
                        addSymbolOriginInfo(symbol);
                        addSymbolSortInfo(symbol);
                        symbols.push(symbol);
                    }
                }
                else {
                    addSymbolOriginInfo(symbol);
                    addSymbolSortInfo(symbol);
                    symbols.push(symbol);
                }
                function addSymbolSortInfo(symbol) {
                    if (isStaticProperty(symbol)) {
                        symbolToSortTextIdMap[ts.getSymbolId(symbol)] = 10 /* LocalDeclarationPriority */;
                    }
                }
                function addSymbolOriginInfo(symbol) {
                    if (preferences.includeCompletionsWithInsertText) {
                        if (insertAwait && ts.addToSeen(seenPropertySymbols, ts.getSymbolId(symbol))) {
                            symbolToOriginInfoMap[symbols.length] = { kind: getNullableSymbolOriginInfoKind(8 /* Promise */) };
                        }
                        else if (insertQuestionDot) {
                            symbolToOriginInfoMap[symbols.length] = { kind: 16 /* Nullable */ };
                        }
                    }
                }
                function getNullableSymbolOriginInfoKind(kind) {
                    return insertQuestionDot ? kind | 16 /* Nullable */ : kind;
                }
            }
            /** Given 'a.b.c', returns 'a'. */
            function getLeftMostName(e) {
                return ts.isIdentifier(e) ? e : ts.isPropertyAccessExpression(e) ? getLeftMostName(e.expression) : undefined;
            }
            function tryGetGlobalSymbols() {
                var result = tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols()
                    || tryGetObjectLikeCompletionSymbols()
                    || tryGetImportCompletionSymbols()
                    || tryGetImportOrExportClauseCompletionSymbols()
                    || tryGetLocalNamedExportCompletionSymbols()
                    || tryGetConstructorCompletion()
                    || tryGetClassLikeCompletionSymbols()
                    || tryGetJsxCompletionSymbols()
                    || (getGlobalCompletions(), 1 /* Success */);
                return result === 1 /* Success */;
            }
            function tryGetConstructorCompletion() {
                if (!tryGetConstructorLikeCompletionContainer(contextToken))
                    return 0 /* Continue */;
                // no members, only keywords
                completionKind = 5 /* None */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                // Has keywords for constructor parameter
                keywordFilters = 4 /* ConstructorParameterKeywords */;
                return 1 /* Success */;
            }
            function tryGetJsxCompletionSymbols() {
                var jsxContainer = tryGetContainingJsxElement(contextToken);
                // Cursor is inside a JSX self-closing element or opening element
                var attrsType = jsxContainer && typeChecker.getContextualType(jsxContainer.attributes);
                if (!attrsType)
                    return 0 /* Continue */;
                var completionsType = jsxContainer && typeChecker.getContextualType(jsxContainer.attributes, 4 /* Completions */);
                symbols = ts.concatenate(symbols, filterJsxAttributes(getPropertiesForObjectExpression(attrsType, completionsType, jsxContainer.attributes, typeChecker), jsxContainer.attributes.properties));
                setSortTextToOptionalMember();
                completionKind = 3 /* MemberLike */;
                isNewIdentifierLocation = false;
                return 1 /* Success */;
            }
            function tryGetImportCompletionSymbols() {
                if (!importCompletionNode)
                    return 0 /* Continue */;
                isNewIdentifierLocation = true;
                collectAutoImports();
                return 1 /* Success */;
            }
            function getGlobalCompletions() {
                keywordFilters = tryGetFunctionLikeBodyCompletionContainer(contextToken) ? 5 /* FunctionLikeBodyKeywords */ : 1 /* All */;
                // Get all entities in the current scope.
                completionKind = 1 /* Global */;
                isNewIdentifierLocation = isNewIdentifierDefinitionLocation();
                if (previousToken !== contextToken) {
                    ts.Debug.assert(!!previousToken, "Expected 'contextToken' to be defined when different from 'previousToken'.");
                }
                // We need to find the node that will give us an appropriate scope to begin
                // aggregating completion candidates. This is achieved in 'getScopeNode'
                // by finding the first node that encompasses a position, accounting for whether a node
                // is "complete" to decide whether a position belongs to the node.
                //
                // However, at the end of an identifier, we are interested in the scope of the identifier
                // itself, but fall outside of the identifier. For instance:
                //
                //      xyz => x$
                //
                // the cursor is outside of both the 'x' and the arrow function 'xyz => x',
                // so 'xyz' is not returned in our results.
                //
                // We define 'adjustedPosition' so that we may appropriately account for
                // being at the end of an identifier. The intention is that if requesting completion
                // at the end of an identifier, it should be effectively equivalent to requesting completion
                // anywhere inside/at the beginning of the identifier. So in the previous case, the
                // 'adjustedPosition' will work as if requesting completion in the following:
                //
                //      xyz => $x
                //
                // If previousToken !== contextToken, then
                //   - 'contextToken' was adjusted to the token prior to 'previousToken'
                //      because we were at the end of an identifier.
                //   - 'previousToken' is defined.
                var adjustedPosition = previousToken !== contextToken ?
                    previousToken.getStart() :
                    position;
                var scopeNode = getScopeNode(contextToken, adjustedPosition, sourceFile) || sourceFile;
                isInSnippetScope = isSnippetScope(scopeNode);
                var symbolMeanings = (isTypeOnlyLocation ? 0 /* None */ : 111551 /* Value */) | 788968 /* Type */ | 1920 /* Namespace */ | 2097152 /* Alias */;
                symbols = ts.concatenate(symbols, typeChecker.getSymbolsInScope(scopeNode, symbolMeanings));
                ts.Debug.assertEachIsDefined(symbols, "getSymbolsInScope() should all be defined");
                for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                    var symbol = symbols_1[_i];
                    if (!typeChecker.isArgumentsSymbol(symbol) &&
                        !ts.some(symbol.declarations, function (d) { return d.getSourceFile() === sourceFile; })) {
                        symbolToSortTextIdMap[ts.getSymbolId(symbol)] = 15 /* GlobalsOrKeywords */;
                    }
                }
                // Need to insert 'this.' before properties of `this` type, so only do that if `includeInsertTextCompletions`
                if (preferences.includeCompletionsWithInsertText && scopeNode.kind !== 300 /* SourceFile */) {
                    var thisType = typeChecker.tryGetThisTypeAt(scopeNode, /*includeGlobalThis*/ false);
                    if (thisType && !isProbablyGlobalType(thisType, sourceFile, typeChecker)) {
                        for (var _a = 0, _b = getPropertiesForCompletion(thisType, typeChecker); _a < _b.length; _a++) {
                            var symbol = _b[_a];
                            symbolToOriginInfoMap[symbols.length] = { kind: 1 /* ThisType */ };
                            symbols.push(symbol);
                            symbolToSortTextIdMap[ts.getSymbolId(symbol)] = 14 /* SuggestedClassMembers */;
                        }
                    }
                }
                collectAutoImports();
                if (isTypeOnlyLocation) {
                    keywordFilters = contextToken && ts.isAssertionExpression(contextToken.parent)
                        ? 6 /* TypeAssertionKeywords */
                        : 7 /* TypeKeywords */;
                }
            }
            function shouldOfferImportCompletions() {
                // If already typing an import statement, provide completions for it.
                if (importCompletionNode)
                    return true;
                // If current completion is for non-contextual Object literal shortahands, ignore auto-import symbols
                if (isNonContextualObjectLiteral)
                    return false;
                // If not already a module, must have modules enabled.
                if (!preferences.includeCompletionsForModuleExports)
                    return false;
                // If already using ES6 modules, OK to continue using them.
                if (sourceFile.externalModuleIndicator || sourceFile.commonJsModuleIndicator)
                    return true;
                // If module transpilation is enabled or we're targeting es6 or above, or not emitting, OK.
                if (ts.compilerOptionsIndicateEs6Modules(program.getCompilerOptions()))
                    return true;
                // If some file is using ES6 modules, assume that it's OK to add more.
                return ts.programContainsModules(program);
            }
            function isSnippetScope(scopeNode) {
                switch (scopeNode.kind) {
                    case 300 /* SourceFile */:
                    case 221 /* TemplateExpression */:
                    case 286 /* JsxExpression */:
                    case 233 /* Block */:
                        return true;
                    default:
                        return ts.isStatement(scopeNode);
                }
            }
            function isTypeOnlyCompletion() {
                return insideJsDocTagTypeExpression
                    || !isContextTokenValueLocation(contextToken) &&
                        (ts.isPossiblyTypeArgumentPosition(contextToken, sourceFile, typeChecker)
                            || ts.isPartOfTypeNode(location)
                            || isContextTokenTypeLocation(contextToken));
            }
            function isContextTokenValueLocation(contextToken) {
                return contextToken &&
                    ((contextToken.kind === 112 /* TypeOfKeyword */ &&
                        (contextToken.parent.kind === 179 /* TypeQuery */ || ts.isTypeOfExpression(contextToken.parent))) ||
                        (contextToken.kind === 128 /* AssertsKeyword */ && contextToken.parent.kind === 175 /* TypePredicate */));
            }
            function isContextTokenTypeLocation(contextToken) {
                if (contextToken) {
                    var parentKind = contextToken.parent.kind;
                    switch (contextToken.kind) {
                        case 58 /* ColonToken */:
                            return parentKind === 165 /* PropertyDeclaration */ ||
                                parentKind === 164 /* PropertySignature */ ||
                                parentKind === 162 /* Parameter */ ||
                                parentKind === 252 /* VariableDeclaration */ ||
                                ts.isFunctionLikeKind(parentKind);
                        case 63 /* EqualsToken */:
                            return parentKind === 257 /* TypeAliasDeclaration */;
                        case 127 /* AsKeyword */:
                            return parentKind === 227 /* AsExpression */;
                        case 29 /* LessThanToken */:
                            return parentKind === 176 /* TypeReference */ ||
                                parentKind === 209 /* TypeAssertionExpression */;
                        case 94 /* ExtendsKeyword */:
                            return parentKind === 161 /* TypeParameter */;
                    }
                }
                return false;
            }
            /** Mutates `symbols`, `symbolToOriginInfoMap`, and `symbolToSortTextIdMap` */
            function collectAutoImports() {
                var _a, _b;
                if (!shouldOfferImportCompletions())
                    return;
                ts.Debug.assert(!(detailsEntryId === null || detailsEntryId === void 0 ? void 0 : detailsEntryId.data), "Should not run 'collectAutoImports' when faster path is available via `data`");
                if (detailsEntryId && !detailsEntryId.source) {
                    // Asking for completion details for an item that is not an auto-import
                    return;
                }
                var moduleSpecifierCache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
                var lowerCaseTokenText = previousToken && ts.isIdentifier(previousToken) ? previousToken.text.toLowerCase() : "";
                var exportInfo = ts.getExportInfoMap(sourceFile, host, program, cancellationToken);
                var packageJsonAutoImportProvider = (_b = host.getPackageJsonAutoImportProvider) === null || _b === void 0 ? void 0 : _b.call(host);
                var packageJsonFilter = detailsEntryId ? undefined : ts.createPackageJsonImportFilter(sourceFile, preferences, host);
                resolvingModuleSpecifiers("collectAutoImports", host, program, sourceFile, preferences, !!importCompletionNode, function (context) {
                    exportInfo.forEach(sourceFile.path, function (info, symbolName, isFromAmbientModule) {
                        if (!ts.isIdentifierText(symbolName, ts.getEmitScriptTarget(host.getCompilationSettings())))
                            return;
                        if (!detailsEntryId && ts.isStringANonContextualKeyword(symbolName))
                            return;
                        // `targetFlags` should be the same for each `info`
                        if (!isTypeOnlyLocation && !importCompletionNode && !(info[0].targetFlags & 111551 /* Value */))
                            return;
                        if (isTypeOnlyLocation && !(info[0].targetFlags & (1536 /* Module */ | 788968 /* Type */)))
                            return;
                        var isCompletionDetailsMatch = detailsEntryId && ts.some(info, function (i) { return detailsEntryId.source === ts.stripQuotes(i.moduleSymbol.name); });
                        if (isCompletionDetailsMatch || !detailsEntryId && charactersFuzzyMatchInString(symbolName, lowerCaseTokenText)) {
                            var defaultExportInfo = ts.find(info, isImportableExportInfo);
                            if (!defaultExportInfo) {
                                return;
                            }
                            // If we don't need to resolve module specifiers, we can use any re-export that is importable at all
                            // (We need to ensure that at least one is importable to show a completion.)
                            var _a = context.tryResolve(info, isFromAmbientModule) || {}, _b = _a.exportInfo, exportInfo_1 = _b === void 0 ? defaultExportInfo : _b, moduleSpecifier = _a.moduleSpecifier;
                            var isDefaultExport = exportInfo_1.exportKind === 1 /* Default */;
                            var symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(exportInfo_1.symbol) || exportInfo_1.symbol;
                            pushAutoImportSymbol(symbol, {
                                kind: moduleSpecifier ? 32 /* ResolvedExport */ : 4 /* Export */,
                                moduleSpecifier: moduleSpecifier,
                                symbolName: symbolName,
                                exportName: exportInfo_1.exportKind === 2 /* ExportEquals */ ? "export=" /* ExportEquals */ : exportInfo_1.symbol.name,
                                fileName: exportInfo_1.moduleFileName,
                                isDefaultExport: isDefaultExport,
                                moduleSymbol: exportInfo_1.moduleSymbol,
                                isFromPackageJson: exportInfo_1.isFromPackageJson,
                            });
                        }
                    });
                    hasUnresolvedAutoImports = context.resolutionLimitExceeded();
                });
                function isImportableExportInfo(info) {
                    var moduleFile = ts.tryCast(info.moduleSymbol.valueDeclaration, ts.isSourceFile);
                    if (!moduleFile) {
                        var moduleName = ts.stripQuotes(info.moduleSymbol.name);
                        if (ts.JsTyping.nodeCoreModules.has(moduleName) && ts.startsWith(moduleName, "node:") !== ts.shouldUseUriStyleNodeCoreModules(sourceFile, program)) {
                            return false;
                        }
                        return packageJsonFilter
                            ? packageJsonFilter.allowsImportingAmbientModule(info.moduleSymbol, getModuleSpecifierResolutionHost(info.isFromPackageJson))
                            : true;
                    }
                    return ts.isImportableFile(info.isFromPackageJson ? packageJsonAutoImportProvider : program, sourceFile, moduleFile, preferences, packageJsonFilter, getModuleSpecifierResolutionHost(info.isFromPackageJson), moduleSpecifierCache);
                }
            }
            function pushAutoImportSymbol(symbol, origin) {
                var symbolId = ts.getSymbolId(symbol);
                if (symbolToSortTextIdMap[symbolId] === 15 /* GlobalsOrKeywords */) {
                    // If an auto-importable symbol is available as a global, don't add the auto import
                    return;
                }
                symbolToOriginInfoMap[symbols.length] = origin;
                symbolToSortTextIdMap[symbolId] = importCompletionNode ? 11 /* LocationPriority */ : 16 /* AutoImportSuggestions */;
                symbols.push(symbol);
            }
            /**
             * Finds the first node that "embraces" the position, so that one may
             * accurately aggregate locals from the closest containing scope.
             */
            function getScopeNode(initialToken, position, sourceFile) {
                var scope = initialToken;
                while (scope && !ts.positionBelongsToNode(scope, position, sourceFile)) {
                    scope = scope.parent;
                }
                return scope;
            }
            function isCompletionListBlocker(contextToken) {
                var start = ts.timestamp();
                var result = isInStringOrRegularExpressionOrTemplateLiteral(contextToken) ||
                    isSolelyIdentifierDefinitionLocation(contextToken) ||
                    isDotOfNumericLiteral(contextToken) ||
                    isInJsxText(contextToken) ||
                    ts.isBigIntLiteral(contextToken);
                log("getCompletionsAtPosition: isCompletionListBlocker: " + (ts.timestamp() - start));
                return result;
            }
            function isInJsxText(contextToken) {
                if (contextToken.kind === 11 /* JsxText */) {
                    return true;
                }
                if (contextToken.kind === 31 /* GreaterThanToken */ && contextToken.parent) {
                    if (contextToken.parent.kind === 278 /* JsxOpeningElement */) {
                        // Two possibilities:
                        //   1. <div>/**/
                        //      - contextToken: GreaterThanToken (before cursor)
                        //      - location: JSXElement
                        //      - different parents (JSXOpeningElement, JSXElement)
                        //   2. <Component<string> /**/>
                        //      - contextToken: GreaterThanToken (before cursor)
                        //      - location: GreaterThanToken (after cursor)
                        //      - same parent (JSXOpeningElement)
                        return location.parent.kind !== 278 /* JsxOpeningElement */;
                    }
                    if (contextToken.parent.kind === 279 /* JsxClosingElement */ || contextToken.parent.kind === 277 /* JsxSelfClosingElement */) {
                        return !!contextToken.parent.parent && contextToken.parent.parent.kind === 276 /* JsxElement */;
                    }
                }
                return false;
            }
            function isNewIdentifierDefinitionLocation() {
                if (contextToken) {
                    var containingNodeKind = contextToken.parent.kind;
                    // Previous token may have been a keyword that was converted to an identifier.
                    switch (keywordForNode(contextToken)) {
                        case 27 /* CommaToken */:
                            return containingNodeKind === 206 /* CallExpression */ // func( a, |
                                || containingNodeKind === 169 /* Constructor */ // constructor( a, |   /* public, protected, private keywords are allowed here, so show completion */
                                || containingNodeKind === 207 /* NewExpression */ // new C(a, |
                                || containingNodeKind === 202 /* ArrayLiteralExpression */ // [a, |
                                || containingNodeKind === 219 /* BinaryExpression */ // const x = (a, |
                                || containingNodeKind === 177 /* FunctionType */ // var x: (s: string, list|
                                || containingNodeKind === 203 /* ObjectLiteralExpression */; // const obj = { x, |
                        case 20 /* OpenParenToken */:
                            return containingNodeKind === 206 /* CallExpression */ // func( |
                                || containingNodeKind === 169 /* Constructor */ // constructor( |
                                || containingNodeKind === 207 /* NewExpression */ // new C(a|
                                || containingNodeKind === 210 /* ParenthesizedExpression */ // const x = (a|
                                || containingNodeKind === 189 /* ParenthesizedType */; // function F(pred: (a| /* this can become an arrow function, where 'a' is the argument */
                        case 22 /* OpenBracketToken */:
                            return containingNodeKind === 202 /* ArrayLiteralExpression */ // [ |
                                || containingNodeKind === 174 /* IndexSignature */ // [ | : string ]
                                || containingNodeKind === 160 /* ComputedPropertyName */; // [ |    /* this can become an index signature */
                        case 140 /* ModuleKeyword */: // module |
                        case 141 /* NamespaceKeyword */: // namespace |
                            return true;
                        case 24 /* DotToken */:
                            return containingNodeKind === 259 /* ModuleDeclaration */; // module A.|
                        case 18 /* OpenBraceToken */:
                            return containingNodeKind === 255 /* ClassDeclaration */ // class A { |
                                || containingNodeKind === 203 /* ObjectLiteralExpression */; // const obj = { |
                        case 63 /* EqualsToken */:
                            return containingNodeKind === 252 /* VariableDeclaration */ // const x = a|
                                || containingNodeKind === 219 /* BinaryExpression */; // x = a|
                        case 15 /* TemplateHead */:
                            return containingNodeKind === 221 /* TemplateExpression */; // `aa ${|
                        case 16 /* TemplateMiddle */:
                            return containingNodeKind === 231 /* TemplateSpan */; // `aa ${10} dd ${|
                        case 123 /* PublicKeyword */:
                        case 121 /* PrivateKeyword */:
                        case 122 /* ProtectedKeyword */:
                            return containingNodeKind === 165 /* PropertyDeclaration */; // class A{ public |
                    }
                }
                return false;
            }
            function isInStringOrRegularExpressionOrTemplateLiteral(contextToken) {
                // To be "in" one of these literals, the position has to be:
                //   1. entirely within the token text.
                //   2. at the end position of an unterminated token.
                //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
                return (ts.isRegularExpressionLiteral(contextToken) || ts.isStringTextContainingNode(contextToken)) && (ts.rangeContainsPositionExclusive(ts.createTextRangeFromSpan(ts.createTextSpanFromNode(contextToken)), position) ||
                    position === contextToken.end && (!!contextToken.isUnterminated || ts.isRegularExpressionLiteral(contextToken)));
            }
            function tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols() {
                var typeLiteralNode = tryGetTypeLiteralNode(contextToken);
                if (!typeLiteralNode)
                    return 0 /* Continue */;
                var intersectionTypeNode = ts.isIntersectionTypeNode(typeLiteralNode.parent) ? typeLiteralNode.parent : undefined;
                var containerTypeNode = intersectionTypeNode || typeLiteralNode;
                var containerExpectedType = getConstraintOfTypeArgumentProperty(containerTypeNode, typeChecker);
                if (!containerExpectedType)
                    return 0 /* Continue */;
                var containerActualType = typeChecker.getTypeFromTypeNode(containerTypeNode);
                var members = getPropertiesForCompletion(containerExpectedType, typeChecker);
                var existingMembers = getPropertiesForCompletion(containerActualType, typeChecker);
                var existingMemberEscapedNames = new ts.Set();
                existingMembers.forEach(function (s) { return existingMemberEscapedNames.add(s.escapedName); });
                symbols = ts.concatenate(symbols, ts.filter(members, function (s) { return !existingMemberEscapedNames.has(s.escapedName); }));
                completionKind = 0 /* ObjectPropertyDeclaration */;
                isNewIdentifierLocation = true;
                return 1 /* Success */;
            }
            /**
             * Aggregates relevant symbols for completion in object literals and object binding patterns.
             * Relevant symbols are stored in the captured 'symbols' variable.
             *
             * @returns true if 'symbols' was successfully populated; false otherwise.
             */
            function tryGetObjectLikeCompletionSymbols() {
                var objectLikeContainer = tryGetObjectLikeCompletionContainer(contextToken);
                if (!objectLikeContainer)
                    return 0 /* Continue */;
                // We're looking up possible property names from contextual/inferred/declared type.
                completionKind = 0 /* ObjectPropertyDeclaration */;
                var typeMembers;
                var existingMembers;
                if (objectLikeContainer.kind === 203 /* ObjectLiteralExpression */) {
                    var instantiatedType = tryGetObjectLiteralContextualType(objectLikeContainer, typeChecker);
                    // Check completions for Object property value shorthand
                    if (instantiatedType === undefined) {
                        if (objectLikeContainer.flags & 16777216 /* InWithStatement */) {
                            return 2 /* Fail */;
                        }
                        isNonContextualObjectLiteral = true;
                        return 0 /* Continue */;
                    }
                    var completionsType = typeChecker.getContextualType(objectLikeContainer, 4 /* Completions */);
                    var hasStringIndexType = (completionsType || instantiatedType).getStringIndexType();
                    var hasNumberIndextype = (completionsType || instantiatedType).getNumberIndexType();
                    isNewIdentifierLocation = !!hasStringIndexType || !!hasNumberIndextype;
                    typeMembers = getPropertiesForObjectExpression(instantiatedType, completionsType, objectLikeContainer, typeChecker);
                    existingMembers = objectLikeContainer.properties;
                    if (typeMembers.length === 0) {
                        // Edge case: If NumberIndexType exists
                        if (!hasNumberIndextype) {
                            isNonContextualObjectLiteral = true;
                            return 0 /* Continue */;
                        }
                    }
                }
                else {
                    ts.Debug.assert(objectLikeContainer.kind === 199 /* ObjectBindingPattern */);
                    // We are *only* completing on properties from the type being destructured.
                    isNewIdentifierLocation = false;
                    var rootDeclaration = ts.getRootDeclaration(objectLikeContainer.parent);
                    if (!ts.isVariableLike(rootDeclaration))
                        return ts.Debug.fail("Root declaration is not variable-like.");
                    // We don't want to complete using the type acquired by the shape
                    // of the binding pattern; we are only interested in types acquired
                    // through type declaration or inference.
                    // Also proceed if rootDeclaration is a parameter and if its containing function expression/arrow function is contextually typed -
                    // type of parameter will flow in from the contextual type of the function
                    var canGetType = ts.hasInitializer(rootDeclaration) || ts.hasType(rootDeclaration) || rootDeclaration.parent.parent.kind === 242 /* ForOfStatement */;
                    if (!canGetType && rootDeclaration.kind === 162 /* Parameter */) {
                        if (ts.isExpression(rootDeclaration.parent)) {
                            canGetType = !!typeChecker.getContextualType(rootDeclaration.parent);
                        }
                        else if (rootDeclaration.parent.kind === 167 /* MethodDeclaration */ || rootDeclaration.parent.kind === 171 /* SetAccessor */) {
                            canGetType = ts.isExpression(rootDeclaration.parent.parent) && !!typeChecker.getContextualType(rootDeclaration.parent.parent);
                        }
                    }
                    if (canGetType) {
                        var typeForObject_1 = typeChecker.getTypeAtLocation(objectLikeContainer);
                        if (!typeForObject_1)
                            return 2 /* Fail */;
                        // In a binding pattern, get only known properties (unless in the same scope).
                        // Everywhere else we will get all possible properties.
                        var containerClass_1 = ts.getContainingClass(objectLikeContainer);
                        typeMembers = typeChecker.getPropertiesOfType(typeForObject_1).filter(function (symbol) {
                            // either public
                            return !(ts.getDeclarationModifierFlagsFromSymbol(symbol) & 24 /* NonPublicAccessibilityModifier */)
                                // or we're in it
                                || containerClass_1 && ts.contains(typeForObject_1.symbol.declarations, containerClass_1);
                        });
                        existingMembers = objectLikeContainer.elements;
                    }
                }
                if (typeMembers && typeMembers.length > 0) {
                    // Add filtered items to the completion list
                    symbols = ts.concatenate(symbols, filterObjectMembersList(typeMembers, ts.Debug.checkDefined(existingMembers)));
                }
                setSortTextToOptionalMember();
                return 1 /* Success */;
            }
            /**
             * Aggregates relevant symbols for completion in import clauses and export clauses
             * whose declarations have a module specifier; for instance, symbols will be aggregated for
             *
             *      import { | } from "moduleName";
             *      export { a as foo, | } from "moduleName";
             *
             * but not for
             *
             *      export { | };
             *
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetImportOrExportClauseCompletionSymbols() {
                // `import { |` or `import { a as 0, | }`
                var namedImportsOrExports = contextToken && (contextToken.kind === 18 /* OpenBraceToken */ || contextToken.kind === 27 /* CommaToken */)
                    ? ts.tryCast(contextToken.parent, ts.isNamedImportsOrExports) : undefined;
                if (!namedImportsOrExports)
                    return 0 /* Continue */;
                // try to show exported member for imported/re-exported module
                var moduleSpecifier = (namedImportsOrExports.kind === 267 /* NamedImports */ ? namedImportsOrExports.parent.parent : namedImportsOrExports.parent).moduleSpecifier;
                if (!moduleSpecifier)
                    return namedImportsOrExports.kind === 267 /* NamedImports */ ? 2 /* Fail */ : 0 /* Continue */;
                var moduleSpecifierSymbol = typeChecker.getSymbolAtLocation(moduleSpecifier); // TODO: GH#18217
                if (!moduleSpecifierSymbol)
                    return 2 /* Fail */;
                completionKind = 3 /* MemberLike */;
                isNewIdentifierLocation = false;
                var exports = typeChecker.getExportsAndPropertiesOfModule(moduleSpecifierSymbol);
                var existing = new ts.Set(namedImportsOrExports.elements.filter(function (n) { return !isCurrentlyEditingNode(n); }).map(function (n) { return (n.propertyName || n.name).escapedText; }));
                symbols = ts.concatenate(symbols, exports.filter(function (e) { return e.escapedName !== "default" /* Default */ && !existing.has(e.escapedName); }));
                return 1 /* Success */;
            }
            /**
             * Adds local declarations for completions in named exports:
             *
             *   export { | };
             *
             * Does not check for the absence of a module specifier (`export {} from "./other"`)
             * because `tryGetImportOrExportClauseCompletionSymbols` runs first and handles that,
             * preventing this function from running.
             */
            function tryGetLocalNamedExportCompletionSymbols() {
                var _a;
                var namedExports = contextToken && (contextToken.kind === 18 /* OpenBraceToken */ || contextToken.kind === 27 /* CommaToken */)
                    ? ts.tryCast(contextToken.parent, ts.isNamedExports)
                    : undefined;
                if (!namedExports) {
                    return 0 /* Continue */;
                }
                var localsContainer = ts.findAncestor(namedExports, ts.or(ts.isSourceFile, ts.isModuleDeclaration));
                completionKind = 5 /* None */;
                isNewIdentifierLocation = false;
                (_a = localsContainer.locals) === null || _a === void 0 ? void 0 : _a.forEach(function (symbol, name) {
                    var _a, _b;
                    symbols.push(symbol);
                    if ((_b = (_a = localsContainer.symbol) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has(name)) {
                        symbolToSortTextIdMap[ts.getSymbolId(symbol)] = 12 /* OptionalMember */;
                    }
                });
                return 1 /* Success */;
            }
            /**
             * Aggregates relevant symbols for completion in class declaration
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetClassLikeCompletionSymbols() {
                var decl = tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position);
                if (!decl)
                    return 0 /* Continue */;
                // We're looking up possible property names from parent type.
                completionKind = 3 /* MemberLike */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                keywordFilters = contextToken.kind === 41 /* AsteriskToken */ ? 0 /* None */ :
                    ts.isClassLike(decl) ? 2 /* ClassElementKeywords */ : 3 /* InterfaceElementKeywords */;
                // If you're in an interface you don't want to repeat things from super-interface. So just stop here.
                if (!ts.isClassLike(decl))
                    return 1 /* Success */;
                var classElement = contextToken.kind === 26 /* SemicolonToken */ ? contextToken.parent.parent : contextToken.parent;
                var classElementModifierFlags = ts.isClassElement(classElement) ? ts.getEffectiveModifierFlags(classElement) : 0 /* None */;
                // If this is context token is not something we are editing now, consider if this would lead to be modifier
                if (contextToken.kind === 79 /* Identifier */ && !isCurrentlyEditingNode(contextToken)) {
                    switch (contextToken.getText()) {
                        case "private":
                            classElementModifierFlags = classElementModifierFlags | 8 /* Private */;
                            break;
                        case "static":
                            classElementModifierFlags = classElementModifierFlags | 32 /* Static */;
                            break;
                        case "override":
                            classElementModifierFlags = classElementModifierFlags | 16384 /* Override */;
                            break;
                    }
                }
                if (ts.isClassStaticBlockDeclaration(classElement)) {
                    classElementModifierFlags |= 32 /* Static */;
                }
                // No member list for private methods
                if (!(classElementModifierFlags & 8 /* Private */)) {
                    // List of property symbols of base type that are not private and already implemented
                    var baseTypeNodes = ts.isClassLike(decl) && classElementModifierFlags & 16384 /* Override */ ? ts.singleElementArray(ts.getEffectiveBaseTypeNode(decl)) : ts.getAllSuperTypeNodes(decl);
                    var baseSymbols = ts.flatMap(baseTypeNodes, function (baseTypeNode) {
                        var type = typeChecker.getTypeAtLocation(baseTypeNode);
                        return classElementModifierFlags & 32 /* Static */ ?
                            (type === null || type === void 0 ? void 0 : type.symbol) && typeChecker.getPropertiesOfType(typeChecker.getTypeOfSymbolAtLocation(type.symbol, decl)) :
                            type && typeChecker.getPropertiesOfType(type);
                    });
                    symbols = ts.concatenate(symbols, filterClassMembersList(baseSymbols, decl.members, classElementModifierFlags));
                }
                return 1 /* Success */;
            }
            /**
             * Returns the immediate owning object literal or binding pattern of a context token,
             * on the condition that one exists and that the context implies completion should be given.
             */
            function tryGetObjectLikeCompletionContainer(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 18 /* OpenBraceToken */: // const x = { |
                        case 27 /* CommaToken */: // const x = { a: 0, |
                            if (ts.isObjectLiteralExpression(parent) || ts.isObjectBindingPattern(parent)) {
                                return parent;
                            }
                            break;
                        case 41 /* AsteriskToken */:
                            return ts.isMethodDeclaration(parent) ? ts.tryCast(parent.parent, ts.isObjectLiteralExpression) : undefined;
                        case 79 /* Identifier */:
                            return contextToken.text === "async" && ts.isShorthandPropertyAssignment(contextToken.parent)
                                ? contextToken.parent.parent : undefined;
                    }
                }
                return undefined;
            }
            function isConstructorParameterCompletion(node) {
                return !!node.parent && ts.isParameter(node.parent) && ts.isConstructorDeclaration(node.parent.parent)
                    && (ts.isParameterPropertyModifier(node.kind) || ts.isDeclarationName(node));
            }
            /**
             * Returns the immediate owning class declaration of a context token,
             * on the condition that one exists and that the context implies completion should be given.
             */
            function tryGetConstructorLikeCompletionContainer(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 20 /* OpenParenToken */:
                        case 27 /* CommaToken */:
                            return ts.isConstructorDeclaration(contextToken.parent) ? contextToken.parent : undefined;
                        default:
                            if (isConstructorParameterCompletion(contextToken)) {
                                return parent.parent;
                            }
                    }
                }
                return undefined;
            }
            function tryGetFunctionLikeBodyCompletionContainer(contextToken) {
                if (contextToken) {
                    var prev_1;
                    var container = ts.findAncestor(contextToken.parent, function (node) {
                        if (ts.isClassLike(node)) {
                            return "quit";
                        }
                        if (ts.isFunctionLikeDeclaration(node) && prev_1 === node.body) {
                            return true;
                        }
                        prev_1 = node;
                        return false;
                    });
                    return container && container;
                }
            }
            function tryGetContainingJsxElement(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 31 /* GreaterThanToken */: // End of a type argument list
                        case 30 /* LessThanSlashToken */:
                        case 43 /* SlashToken */:
                        case 79 /* Identifier */:
                        case 204 /* PropertyAccessExpression */:
                        case 284 /* JsxAttributes */:
                        case 283 /* JsxAttribute */:
                        case 285 /* JsxSpreadAttribute */:
                            if (parent && (parent.kind === 277 /* JsxSelfClosingElement */ || parent.kind === 278 /* JsxOpeningElement */)) {
                                if (contextToken.kind === 31 /* GreaterThanToken */) {
                                    var precedingToken = ts.findPrecedingToken(contextToken.pos, sourceFile, /*startNode*/ undefined);
                                    if (!parent.typeArguments || (precedingToken && precedingToken.kind === 43 /* SlashToken */))
                                        break;
                                }
                                return parent;
                            }
                            else if (parent.kind === 283 /* JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        // The context token is the closing } or " of an attribute, which means
                        // its parent is a JsxExpression, whose parent is a JsxAttribute,
                        // whose parent is a JsxOpeningLikeElement
                        case 10 /* StringLiteral */:
                            if (parent && ((parent.kind === 283 /* JsxAttribute */) || (parent.kind === 285 /* JsxSpreadAttribute */))) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        case 19 /* CloseBraceToken */:
                            if (parent &&
                                parent.kind === 286 /* JsxExpression */ &&
                                parent.parent && parent.parent.kind === 283 /* JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                //                  each JsxAttribute can have initializer as JsxExpression
                                return parent.parent.parent.parent;
                            }
                            if (parent && parent.kind === 285 /* JsxSpreadAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                    }
                }
                return undefined;
            }
            /**
             * @returns true if we are certain that the currently edited location must define a new location; false otherwise.
             */
            function isSolelyIdentifierDefinitionLocation(contextToken) {
                var parent = contextToken.parent;
                var containingNodeKind = parent.kind;
                switch (contextToken.kind) {
                    case 27 /* CommaToken */:
                        return containingNodeKind === 252 /* VariableDeclaration */ ||
                            isVariableDeclarationListButNotTypeArgument(contextToken) ||
                            containingNodeKind === 235 /* VariableStatement */ ||
                            containingNodeKind === 258 /* EnumDeclaration */ || // enum a { foo, |
                            isFunctionLikeButNotConstructor(containingNodeKind) ||
                            containingNodeKind === 256 /* InterfaceDeclaration */ || // interface A<T, |
                            containingNodeKind === 200 /* ArrayBindingPattern */ || // var [x, y|
                            containingNodeKind === 257 /* TypeAliasDeclaration */ || // type Map, K, |
                            // class A<T, |
                            // var C = class D<T, |
                            (ts.isClassLike(parent) &&
                                !!parent.typeParameters &&
                                parent.typeParameters.end >= contextToken.pos);
                    case 24 /* DotToken */:
                        return containingNodeKind === 200 /* ArrayBindingPattern */; // var [.|
                    case 58 /* ColonToken */:
                        return containingNodeKind === 201 /* BindingElement */; // var {x :html|
                    case 22 /* OpenBracketToken */:
                        return containingNodeKind === 200 /* ArrayBindingPattern */; // var [x|
                    case 20 /* OpenParenToken */:
                        return containingNodeKind === 290 /* CatchClause */ ||
                            isFunctionLikeButNotConstructor(containingNodeKind);
                    case 18 /* OpenBraceToken */:
                        return containingNodeKind === 258 /* EnumDeclaration */; // enum a { |
                    case 29 /* LessThanToken */:
                        return containingNodeKind === 255 /* ClassDeclaration */ || // class A< |
                            containingNodeKind === 224 /* ClassExpression */ || // var C = class D< |
                            containingNodeKind === 256 /* InterfaceDeclaration */ || // interface A< |
                            containingNodeKind === 257 /* TypeAliasDeclaration */ || // type List< |
                            ts.isFunctionLikeKind(containingNodeKind);
                    case 124 /* StaticKeyword */:
                        return containingNodeKind === 165 /* PropertyDeclaration */ && !ts.isClassLike(parent.parent);
                    case 25 /* DotDotDotToken */:
                        return containingNodeKind === 162 /* Parameter */ ||
                            (!!parent.parent && parent.parent.kind === 200 /* ArrayBindingPattern */); // var [...z|
                    case 123 /* PublicKeyword */:
                    case 121 /* PrivateKeyword */:
                    case 122 /* ProtectedKeyword */:
                        return containingNodeKind === 162 /* Parameter */ && !ts.isConstructorDeclaration(parent.parent);
                    case 127 /* AsKeyword */:
                        return containingNodeKind === 268 /* ImportSpecifier */ ||
                            containingNodeKind === 273 /* ExportSpecifier */ ||
                            containingNodeKind === 266 /* NamespaceImport */;
                    case 135 /* GetKeyword */:
                    case 147 /* SetKeyword */:
                        return !isFromObjectTypeDeclaration(contextToken);
                    case 84 /* ClassKeyword */:
                    case 92 /* EnumKeyword */:
                    case 118 /* InterfaceKeyword */:
                    case 98 /* FunctionKeyword */:
                    case 113 /* VarKeyword */:
                    case 100 /* ImportKeyword */:
                    case 119 /* LetKeyword */:
                    case 85 /* ConstKeyword */:
                    case 136 /* InferKeyword */:
                    case 150 /* TypeKeyword */: // type htm|
                        return true;
                    case 41 /* AsteriskToken */:
                        return ts.isFunctionLike(contextToken.parent) && !ts.isMethodDeclaration(contextToken.parent);
                }
                // If the previous token is keyword corresponding to class member completion keyword
                // there will be completion available here
                if (isClassMemberCompletionKeyword(keywordForNode(contextToken)) && isFromObjectTypeDeclaration(contextToken)) {
                    return false;
                }
                if (isConstructorParameterCompletion(contextToken)) {
                    // constructor parameter completion is available only if
                    // - its modifier of the constructor parameter or
                    // - its name of the parameter and not being edited
                    // eg. constructor(a |<- this shouldnt show completion
                    if (!ts.isIdentifier(contextToken) ||
                        ts.isParameterPropertyModifier(keywordForNode(contextToken)) ||
                        isCurrentlyEditingNode(contextToken)) {
                        return false;
                    }
                }
                // Previous token may have been a keyword that was converted to an identifier.
                switch (keywordForNode(contextToken)) {
                    case 126 /* AbstractKeyword */:
                    case 84 /* ClassKeyword */:
                    case 85 /* ConstKeyword */:
                    case 134 /* DeclareKeyword */:
                    case 92 /* EnumKeyword */:
                    case 98 /* FunctionKeyword */:
                    case 118 /* InterfaceKeyword */:
                    case 119 /* LetKeyword */:
                    case 121 /* PrivateKeyword */:
                    case 122 /* ProtectedKeyword */:
                    case 123 /* PublicKeyword */:
                    case 124 /* StaticKeyword */:
                    case 113 /* VarKeyword */:
                        return true;
                    case 130 /* AsyncKeyword */:
                        return ts.isPropertyDeclaration(contextToken.parent);
                }
                // If we are inside a class declaration, and `constructor` is totally not present,
                // but we request a completion manually at a whitespace...
                var ancestorClassLike = ts.findAncestor(contextToken.parent, ts.isClassLike);
                if (ancestorClassLike && contextToken === previousToken && isPreviousPropertyDeclarationTerminated(contextToken, position)) {
                    return false; // Don't block completions.
                }
                var ancestorPropertyDeclaraion = ts.getAncestor(contextToken.parent, 165 /* PropertyDeclaration */);
                // If we are inside a class declaration and typing `constructor` after property declaration...
                if (ancestorPropertyDeclaraion
                    && contextToken !== previousToken
                    && ts.isClassLike(previousToken.parent.parent)
                    // And the cursor is at the token...
                    && position <= previousToken.end) {
                    // If we are sure that the previous property declaration is terminated according to newline or semicolon...
                    if (isPreviousPropertyDeclarationTerminated(contextToken, previousToken.end)) {
                        return false; // Don't block completions.
                    }
                    else if (contextToken.kind !== 63 /* EqualsToken */
                        // Should not block: `class C { blah = c/**/ }`
                        // But should block: `class C { blah = somewhat c/**/ }` and `class C { blah: SomeType c/**/ }`
                        && (ts.isInitializedProperty(ancestorPropertyDeclaraion)
                            || ts.hasType(ancestorPropertyDeclaraion))) {
                        return true;
                    }
                }
                return ts.isDeclarationName(contextToken)
                    && !ts.isShorthandPropertyAssignment(contextToken.parent)
                    && !ts.isJsxAttribute(contextToken.parent)
                    // Don't block completions if we're in `class C /**/`, because we're *past* the end of the identifier and might want to complete `extends`.
                    // If `contextToken !== previousToken`, this is `class C ex/**/`.
                    && !(ts.isClassLike(contextToken.parent) && (contextToken !== previousToken || position > previousToken.end));
            }
            function isPreviousPropertyDeclarationTerminated(contextToken, position) {
                return contextToken.kind !== 63 /* EqualsToken */ &&
                    (contextToken.kind === 26 /* SemicolonToken */
                        || !ts.positionsAreOnSameLine(contextToken.end, position, sourceFile));
            }
            function isFunctionLikeButNotConstructor(kind) {
                return ts.isFunctionLikeKind(kind) && kind !== 169 /* Constructor */;
            }
            function isDotOfNumericLiteral(contextToken) {
                if (contextToken.kind === 8 /* NumericLiteral */) {
                    var text = contextToken.getFullText();
                    return text.charAt(text.length - 1) === ".";
                }
                return false;
            }
            function isVariableDeclarationListButNotTypeArgument(node) {
                return node.parent.kind === 253 /* VariableDeclarationList */
                    && !ts.isPossiblyTypeArgumentPosition(node, sourceFile, typeChecker);
            }
            /**
             * Filters out completion suggestions for named imports or exports.
             *
             * @returns Symbols to be suggested in an object binding pattern or object literal expression, barring those whose declarations
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterObjectMembersList(contextualMemberSymbols, existingMembers) {
                if (existingMembers.length === 0) {
                    return contextualMemberSymbols;
                }
                var membersDeclaredBySpreadAssignment = new ts.Set();
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_1 = existingMembers; _i < existingMembers_1.length; _i++) {
                    var m = existingMembers_1[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 291 /* PropertyAssignment */ &&
                        m.kind !== 292 /* ShorthandPropertyAssignment */ &&
                        m.kind !== 201 /* BindingElement */ &&
                        m.kind !== 167 /* MethodDeclaration */ &&
                        m.kind !== 170 /* GetAccessor */ &&
                        m.kind !== 171 /* SetAccessor */ &&
                        m.kind !== 293 /* SpreadAssignment */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    var existingName = void 0;
                    if (ts.isSpreadAssignment(m)) {
                        setMembersDeclaredBySpreadAssignment(m, membersDeclaredBySpreadAssignment);
                    }
                    else if (ts.isBindingElement(m) && m.propertyName) {
                        // include only identifiers in completion list
                        if (m.propertyName.kind === 79 /* Identifier */) {
                            existingName = m.propertyName.escapedText;
                        }
                    }
                    else {
                        // TODO: Account for computed property name
                        // NOTE: if one only performs this step when m.name is an identifier,
                        // things like '__proto__' are not filtered out.
                        var name = ts.getNameOfDeclaration(m);
                        existingName = name && ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
                    }
                    if (existingName !== undefined) {
                        existingMemberNames.add(existingName);
                    }
                }
                var filteredSymbols = contextualMemberSymbols.filter(function (m) { return !existingMemberNames.has(m.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function setMembersDeclaredBySpreadAssignment(declaration, membersDeclaredBySpreadAssignment) {
                var expression = declaration.expression;
                var symbol = typeChecker.getSymbolAtLocation(expression);
                var type = symbol && typeChecker.getTypeOfSymbolAtLocation(symbol, expression);
                var properties = type && type.properties;
                if (properties) {
                    properties.forEach(function (property) {
                        membersDeclaredBySpreadAssignment.add(property.name);
                    });
                }
            }
            // Set SortText to OptionalMember if it is an optional member
            function setSortTextToOptionalMember() {
                symbols.forEach(function (m) {
                    var _a;
                    if (m.flags & 16777216 /* Optional */) {
                        var symbolId = ts.getSymbolId(m);
                        symbolToSortTextIdMap[symbolId] = (_a = symbolToSortTextIdMap[symbolId]) !== null && _a !== void 0 ? _a : 12 /* OptionalMember */;
                    }
                });
            }
            // Set SortText to MemberDeclaredBySpreadAssignment if it is fulfilled by spread assignment
            function setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, contextualMemberSymbols) {
                if (membersDeclaredBySpreadAssignment.size === 0) {
                    return;
                }
                for (var _i = 0, contextualMemberSymbols_1 = contextualMemberSymbols; _i < contextualMemberSymbols_1.length; _i++) {
                    var contextualMemberSymbol = contextualMemberSymbols_1[_i];
                    if (membersDeclaredBySpreadAssignment.has(contextualMemberSymbol.name)) {
                        symbolToSortTextIdMap[ts.getSymbolId(contextualMemberSymbol)] = 13 /* MemberDeclaredBySpreadAssignment */;
                    }
                }
            }
            /**
             * Filters out completion suggestions for class elements.
             *
             * @returns Symbols to be suggested in an class element depending on existing memebers and symbol flags
             */
            function filterClassMembersList(baseSymbols, existingMembers, currentClassElementModifierFlags) {
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_2 = existingMembers; _i < existingMembers_2.length; _i++) {
                    var m = existingMembers_2[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 165 /* PropertyDeclaration */ &&
                        m.kind !== 167 /* MethodDeclaration */ &&
                        m.kind !== 170 /* GetAccessor */ &&
                        m.kind !== 171 /* SetAccessor */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    // Dont filter member even if the name matches if it is declared private in the list
                    if (ts.hasEffectiveModifier(m, 8 /* Private */)) {
                        continue;
                    }
                    // do not filter it out if the static presence doesnt match
                    if (ts.isStatic(m) !== !!(currentClassElementModifierFlags & 32 /* Static */)) {
                        continue;
                    }
                    var existingName = ts.getPropertyNameForPropertyNameNode(m.name);
                    if (existingName) {
                        existingMemberNames.add(existingName);
                    }
                }
                return baseSymbols.filter(function (propertySymbol) {
                    return !existingMemberNames.has(propertySymbol.escapedName) &&
                        !!propertySymbol.declarations &&
                        !(ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & 8 /* Private */) &&
                        !(propertySymbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(propertySymbol.valueDeclaration));
                });
            }
            /**
             * Filters out completion suggestions from 'symbols' according to existing JSX attributes.
             *
             * @returns Symbols to be suggested in a JSX element, barring those whose attributes
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterJsxAttributes(symbols, attributes) {
                var seenNames = new ts.Set();
                var membersDeclaredBySpreadAssignment = new ts.Set();
                for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                    var attr = attributes_1[_i];
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(attr)) {
                        continue;
                    }
                    if (attr.kind === 283 /* JsxAttribute */) {
                        seenNames.add(attr.name.escapedText);
                    }
                    else if (ts.isJsxSpreadAttribute(attr)) {
                        setMembersDeclaredBySpreadAssignment(attr, membersDeclaredBySpreadAssignment);
                    }
                }
                var filteredSymbols = symbols.filter(function (a) { return !seenNames.has(a.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function isCurrentlyEditingNode(node) {
                return node.getStart(sourceFile) <= position && position <= node.getEnd();
            }
        }
        function getRelevantTokens(position, sourceFile) {
            var previousToken = ts.findPrecedingToken(position, sourceFile);
            if (previousToken && position <= previousToken.end && (ts.isMemberName(previousToken) || ts.isKeyword(previousToken.kind))) {
                var contextToken = ts.findPrecedingToken(previousToken.getFullStart(), sourceFile, /*startNode*/ undefined); // TODO: GH#18217
                return { contextToken: contextToken, previousToken: previousToken };
            }
            return { contextToken: previousToken, previousToken: previousToken };
        }
        function getAutoImportSymbolFromCompletionEntryData(name, data, program, host) {
            var containingProgram = data.isPackageJsonImport ? host.getPackageJsonAutoImportProvider() : program;
            var checker = containingProgram.getTypeChecker();
            var moduleSymbol = data.ambientModuleName ? checker.tryFindAmbientModule(data.ambientModuleName) :
                data.fileName ? checker.getMergedSymbol(ts.Debug.checkDefined(containingProgram.getSourceFile(data.fileName)).symbol) :
                    undefined;
            if (!moduleSymbol)
                return undefined;
            var symbol = data.exportName === "export=" /* ExportEquals */
                ? checker.resolveExternalModuleSymbol(moduleSymbol)
                : checker.tryGetMemberInModuleExportsAndProperties(data.exportName, moduleSymbol);
            if (!symbol)
                return undefined;
            var isDefaultExport = data.exportName === "default" /* Default */;
            symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(symbol) || symbol;
            return {
                symbol: symbol,
                origin: {
                    kind: data.moduleSpecifier ? 32 /* ResolvedExport */ : 4 /* Export */,
                    moduleSymbol: moduleSymbol,
                    symbolName: name,
                    isDefaultExport: isDefaultExport,
                    exportName: data.exportName,
                    fileName: data.fileName,
                    isFromPackageJson: !!data.isPackageJsonImport,
                }
            };
        }
        function getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, jsxIdentifierExpected) {
            var name = originIncludesSymbolName(origin) ? origin.symbolName : symbol.name;
            if (name === undefined
                // If the symbol is external module, don't show it in the completion list
                // (i.e declare module "http" { const x; } | // <= request completion here, "http" should not be there)
                || symbol.flags & 1536 /* Module */ && ts.isSingleOrDoubleQuote(name.charCodeAt(0))
                // If the symbol is the internal name of an ES symbol, it is not a valid entry. Internal names for ES symbols start with "__@"
                || ts.isKnownSymbol(symbol)) {
                return undefined;
            }
            var validNameResult = { name: name, needsConvertPropertyAccess: false };
            if (ts.isIdentifierText(name, target, jsxIdentifierExpected ? 1 /* JSX */ : 0 /* Standard */) || symbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
                return validNameResult;
            }
            switch (kind) {
                case 3 /* MemberLike */:
                    return undefined;
                case 0 /* ObjectPropertyDeclaration */:
                    // TODO: GH#18169
                    return { name: JSON.stringify(name), needsConvertPropertyAccess: false };
                case 2 /* PropertyAccess */:
                case 1 /* Global */: // For a 'this.' completion it will be in a global context, but may have a non-identifier name.
                    // Don't add a completion for a name starting with a space. See https://github.com/Microsoft/TypeScript/pull/20547
                    return name.charCodeAt(0) === 32 /* space */ ? undefined : { name: name, needsConvertPropertyAccess: true };
                case 5 /* None */:
                case 4 /* String */:
                    return validNameResult;
                default:
                    ts.Debug.assertNever(kind);
            }
        }
        // A cache of completion entries for keywords, these do not change between sessions
        var _keywordCompletions = [];
        var allKeywordsCompletions = ts.memoize(function () {
            var res = [];
            for (var i = 81 /* FirstKeyword */; i <= 158 /* LastKeyword */; i++) {
                res.push({
                    name: ts.tokenToString(i),
                    kind: "keyword" /* keyword */,
                    kindModifiers: "" /* none */,
                    sortText: SortText.GlobalsOrKeywords
                });
            }
            return res;
        });
        function getKeywordCompletions(keywordFilter, filterOutTsOnlyKeywords) {
            if (!filterOutTsOnlyKeywords)
                return getTypescriptKeywordCompletions(keywordFilter);
            var index = keywordFilter + 7 /* Last */ + 1;
            return _keywordCompletions[index] ||
                (_keywordCompletions[index] = getTypescriptKeywordCompletions(keywordFilter)
                    .filter(function (entry) { return !isTypeScriptOnlyKeyword(ts.stringToToken(entry.name)); }));
        }
        function getTypescriptKeywordCompletions(keywordFilter) {
            return _keywordCompletions[keywordFilter] || (_keywordCompletions[keywordFilter] = allKeywordsCompletions().filter(function (entry) {
                var kind = ts.stringToToken(entry.name);
                switch (keywordFilter) {
                    case 0 /* None */:
                        return false;
                    case 1 /* All */:
                        return isFunctionLikeBodyKeyword(kind)
                            || kind === 134 /* DeclareKeyword */
                            || kind === 140 /* ModuleKeyword */
                            || kind === 150 /* TypeKeyword */
                            || kind === 141 /* NamespaceKeyword */
                            || ts.isTypeKeyword(kind) && kind !== 151 /* UndefinedKeyword */;
                    case 5 /* FunctionLikeBodyKeywords */:
                        return isFunctionLikeBodyKeyword(kind);
                    case 2 /* ClassElementKeywords */:
                        return isClassMemberCompletionKeyword(kind);
                    case 3 /* InterfaceElementKeywords */:
                        return isInterfaceOrTypeLiteralCompletionKeyword(kind);
                    case 4 /* ConstructorParameterKeywords */:
                        return ts.isParameterPropertyModifier(kind);
                    case 6 /* TypeAssertionKeywords */:
                        return ts.isTypeKeyword(kind) || kind === 85 /* ConstKeyword */;
                    case 7 /* TypeKeywords */:
                        return ts.isTypeKeyword(kind);
                    default:
                        return ts.Debug.assertNever(keywordFilter);
                }
            }));
        }
        function isTypeScriptOnlyKeyword(kind) {
            switch (kind) {
                case 126 /* AbstractKeyword */:
                case 129 /* AnyKeyword */:
                case 156 /* BigIntKeyword */:
                case 132 /* BooleanKeyword */:
                case 134 /* DeclareKeyword */:
                case 92 /* EnumKeyword */:
                case 155 /* GlobalKeyword */:
                case 117 /* ImplementsKeyword */:
                case 136 /* InferKeyword */:
                case 118 /* InterfaceKeyword */:
                case 138 /* IsKeyword */:
                case 139 /* KeyOfKeyword */:
                case 140 /* ModuleKeyword */:
                case 141 /* NamespaceKeyword */:
                case 142 /* NeverKeyword */:
                case 145 /* NumberKeyword */:
                case 146 /* ObjectKeyword */:
                case 157 /* OverrideKeyword */:
                case 121 /* PrivateKeyword */:
                case 122 /* ProtectedKeyword */:
                case 123 /* PublicKeyword */:
                case 143 /* ReadonlyKeyword */:
                case 148 /* StringKeyword */:
                case 149 /* SymbolKeyword */:
                case 150 /* TypeKeyword */:
                case 152 /* UniqueKeyword */:
                case 153 /* UnknownKeyword */:
                    return true;
                default:
                    return false;
            }
        }
        function isInterfaceOrTypeLiteralCompletionKeyword(kind) {
            return kind === 143 /* ReadonlyKeyword */;
        }
        function isClassMemberCompletionKeyword(kind) {
            switch (kind) {
                case 126 /* AbstractKeyword */:
                case 133 /* ConstructorKeyword */:
                case 135 /* GetKeyword */:
                case 147 /* SetKeyword */:
                case 130 /* AsyncKeyword */:
                case 134 /* DeclareKeyword */:
                case 157 /* OverrideKeyword */:
                    return true;
                default:
                    return ts.isClassMemberModifier(kind);
            }
        }
        function isFunctionLikeBodyKeyword(kind) {
            return kind === 130 /* AsyncKeyword */
                || kind === 131 /* AwaitKeyword */
                || kind === 127 /* AsKeyword */
                || !ts.isContextualKeyword(kind) && !isClassMemberCompletionKeyword(kind);
        }
        function keywordForNode(node) {
            return ts.isIdentifier(node) ? node.originalKeywordKind || 0 /* Unknown */ : node.kind;
        }
        /** Get the corresponding JSDocTag node if the position is in a jsDoc comment */
        function getJsDocTagAtPosition(node, position) {
            var jsdoc = ts.findAncestor(node, ts.isJSDoc);
            return jsdoc && jsdoc.tags && (ts.rangeContainsPosition(jsdoc, position) ? ts.findLast(jsdoc.tags, function (tag) { return tag.pos < position; }) : undefined);
        }
        function getPropertiesForObjectExpression(contextualType, completionsType, obj, checker) {
            var hasCompletionsType = completionsType && completionsType !== contextualType;
            var type = hasCompletionsType && !(completionsType.flags & 3 /* AnyOrUnknown */)
                ? checker.getUnionType([contextualType, completionsType])
                : contextualType;
            var properties = type.isUnion()
                ? checker.getAllPossiblePropertiesOfTypes(type.types.filter(function (memberType) {
                    // If we're providing completions for an object literal, skip primitive, array-like, or callable types since those shouldn't be implemented by object literals.
                    return !(memberType.flags & 131068 /* Primitive */ ||
                        checker.isArrayLikeType(memberType) ||
                        ts.typeHasCallOrConstructSignatures(memberType, checker) ||
                        checker.isTypeInvalidDueToUnionDiscriminant(memberType, obj));
                }))
                : type.getApparentProperties();
            return hasCompletionsType ? properties.filter(hasDeclarationOtherThanSelf) : properties;
            // Filter out members whose only declaration is the object literal itself to avoid
            // self-fulfilling completions like:
            //
            // function f<T>(x: T) {}
            // f({ abc/**/: "" }) // `abc` is a member of `T` but only because it declares itself
            function hasDeclarationOtherThanSelf(member) {
                return ts.some(member.declarations, function (decl) { return decl.parent !== obj; });
            }
        }
        Completions.getPropertiesForObjectExpression = getPropertiesForObjectExpression;
        /**
         * Gets all properties on a type, but if that type is a union of several types,
         * excludes array-like types or callable/constructable types.
         */
        function getPropertiesForCompletion(type, checker) {
            return type.isUnion()
                ? ts.Debug.checkEachDefined(checker.getAllPossiblePropertiesOfTypes(type.types), "getAllPossiblePropertiesOfTypes() should all be defined")
                : ts.Debug.checkEachDefined(type.getApparentProperties(), "getApparentProperties() should all be defined");
        }
        /**
         * Returns the immediate owning class declaration of a context token,
         * on the condition that one exists and that the context implies completion should be given.
         */
        function tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position) {
            // class c { method() { } | method2() { } }
            switch (location.kind) {
                case 343 /* SyntaxList */:
                    return ts.tryCast(location.parent, ts.isObjectTypeDeclaration);
                case 1 /* EndOfFileToken */:
                    var cls = ts.tryCast(ts.lastOrUndefined(ts.cast(location.parent, ts.isSourceFile).statements), ts.isObjectTypeDeclaration);
                    if (cls && !ts.findChildOfKind(cls, 19 /* CloseBraceToken */, sourceFile)) {
                        return cls;
                    }
                    break;
                case 79 /* Identifier */: {
                    // class c { public prop = c| }
                    if (ts.isPropertyDeclaration(location.parent) && location.parent.initializer === location) {
                        return undefined;
                    }
                    // class c extends React.Component { a: () => 1\n compon| }
                    if (isFromObjectTypeDeclaration(location)) {
                        return ts.findAncestor(location, ts.isObjectTypeDeclaration);
                    }
                }
            }
            if (!contextToken)
                return undefined;
            // class C { blah; constructor/**/ } and so on
            if (location.kind === 133 /* ConstructorKeyword */
                // class C { blah \n constructor/**/ }
                || (ts.isIdentifier(contextToken) && ts.isPropertyDeclaration(contextToken.parent) && ts.isClassLike(location))) {
                return ts.findAncestor(contextToken, ts.isClassLike);
            }
            switch (contextToken.kind) {
                case 63 /* EqualsToken */: // class c { public prop = | /* global completions */ }
                    return undefined;
                case 26 /* SemicolonToken */: // class c {getValue(): number; | }
                case 19 /* CloseBraceToken */: // class c { method() { } | }
                    // class c { method() { } b| }
                    return isFromObjectTypeDeclaration(location) && location.parent.name === location
                        ? location.parent.parent
                        : ts.tryCast(location, ts.isObjectTypeDeclaration);
                case 18 /* OpenBraceToken */: // class c { |
                case 27 /* CommaToken */: // class c {getValue(): number, | }
                    return ts.tryCast(contextToken.parent, ts.isObjectTypeDeclaration);
                default:
                    if (!isFromObjectTypeDeclaration(contextToken)) {
                        // class c extends React.Component { a: () => 1\n| }
                        if (ts.getLineAndCharacterOfPosition(sourceFile, contextToken.getEnd()).line !== ts.getLineAndCharacterOfPosition(sourceFile, position).line && ts.isObjectTypeDeclaration(location)) {
                            return location;
                        }
                        return undefined;
                    }
                    var isValidKeyword = ts.isClassLike(contextToken.parent.parent) ? isClassMemberCompletionKeyword : isInterfaceOrTypeLiteralCompletionKeyword;
                    return (isValidKeyword(contextToken.kind) || contextToken.kind === 41 /* AsteriskToken */ || ts.isIdentifier(contextToken) && isValidKeyword(ts.stringToToken(contextToken.text))) // TODO: GH#18217
                        ? contextToken.parent.parent : undefined;
            }
        }
        function tryGetTypeLiteralNode(node) {
            if (!node)
                return undefined;
            var parent = node.parent;
            switch (node.kind) {
                case 18 /* OpenBraceToken */:
                    if (ts.isTypeLiteralNode(parent)) {
                        return parent;
                    }
                    break;
                case 26 /* SemicolonToken */:
                case 27 /* CommaToken */:
                case 79 /* Identifier */:
                    if (parent.kind === 164 /* PropertySignature */ && ts.isTypeLiteralNode(parent.parent)) {
                        return parent.parent;
                    }
                    break;
            }
            return undefined;
        }
        function getConstraintOfTypeArgumentProperty(node, checker) {
            if (!node)
                return undefined;
            if (ts.isTypeNode(node) && ts.isTypeReferenceType(node.parent)) {
                return checker.getTypeArgumentConstraint(node);
            }
            var t = getConstraintOfTypeArgumentProperty(node.parent, checker);
            if (!t)
                return undefined;
            switch (node.kind) {
                case 164 /* PropertySignature */:
                    return checker.getTypeOfPropertyOfContextualType(t, node.symbol.escapedName);
                case 186 /* IntersectionType */:
                case 180 /* TypeLiteral */:
                case 185 /* UnionType */:
                    return t;
            }
        }
        // TODO: GH#19856 Would like to return `node is Node & { parent: (ClassElement | TypeElement) & { parent: ObjectTypeDeclaration } }` but then compilation takes > 10 minutes
        function isFromObjectTypeDeclaration(node) {
            return node.parent && ts.isClassOrTypeElement(node.parent) && ts.isObjectTypeDeclaration(node.parent.parent);
        }
        function isValidTrigger(sourceFile, triggerCharacter, contextToken, position) {
            switch (triggerCharacter) {
                case ".":
                case "@":
                    return true;
                case '"':
                case "'":
                case "`":
                    // Only automatically bring up completions if this is an opening quote.
                    return !!contextToken && ts.isStringLiteralOrTemplate(contextToken) && position === contextToken.getStart(sourceFile) + 1;
                case "#":
                    return !!contextToken && ts.isPrivateIdentifier(contextToken) && !!ts.getContainingClass(contextToken);
                case "<":
                    // Opening JSX tag
                    return !!contextToken && contextToken.kind === 29 /* LessThanToken */ && (!ts.isBinaryExpression(contextToken.parent) || binaryExpressionMayBeOpenTag(contextToken.parent));
                case "/":
                    return !!contextToken && (ts.isStringLiteralLike(contextToken)
                        ? !!ts.tryGetImportFromModuleSpecifier(contextToken)
                        : contextToken.kind === 43 /* SlashToken */ && ts.isJsxClosingElement(contextToken.parent));
                case " ":
                    return !!contextToken && ts.isImportKeyword(contextToken) && contextToken.parent.kind === 300 /* SourceFile */;
                default:
                    return ts.Debug.assertNever(triggerCharacter);
            }
        }
        function binaryExpressionMayBeOpenTag(_a) {
            var left = _a.left;
            return ts.nodeIsMissing(left);
        }
        /** Determines if a type is exactly the same type resolved by the global 'self', 'global', or 'globalThis'. */
        function isProbablyGlobalType(type, sourceFile, checker) {
            // The type of `self` and `window` is the same in lib.dom.d.ts, but `window` does not exist in
            // lib.webworker.d.ts, so checking against `self` is also a check against `window` when it exists.
            var selfSymbol = checker.resolveName("self", /*location*/ undefined, 111551 /* Value */, /*excludeGlobals*/ false);
            if (selfSymbol && checker.getTypeOfSymbolAtLocation(selfSymbol, sourceFile) === type) {
                return true;
            }
            var globalSymbol = checker.resolveName("global", /*location*/ undefined, 111551 /* Value */, /*excludeGlobals*/ false);
            if (globalSymbol && checker.getTypeOfSymbolAtLocation(globalSymbol, sourceFile) === type) {
                return true;
            }
            var globalThisSymbol = checker.resolveName("globalThis", /*location*/ undefined, 111551 /* Value */, /*excludeGlobals*/ false);
            if (globalThisSymbol && checker.getTypeOfSymbolAtLocation(globalThisSymbol, sourceFile) === type) {
                return true;
            }
            return false;
        }
        function isStaticProperty(symbol) {
            return !!(symbol.valueDeclaration && ts.getEffectiveModifierFlags(symbol.valueDeclaration) & 32 /* Static */ && ts.isClassLike(symbol.valueDeclaration.parent));
        }
        function tryGetObjectLiteralContextualType(node, typeChecker) {
            var type = typeChecker.getContextualType(node);
            if (type) {
                return type;
            }
            if (ts.isBinaryExpression(node.parent) && node.parent.operatorToken.kind === 63 /* EqualsToken */ && node === node.parent.left) {
                // Object literal is assignment pattern: ({ | } = x)
                return typeChecker.getTypeAtLocation(node.parent);
            }
            return undefined;
        }
        function getImportCompletionNode(contextToken) {
            var candidate = getCandidate();
            return candidate === 154 /* FromKeyword */ || candidate && ts.rangeIsOnSingleLine(candidate, candidate.getSourceFile()) ? candidate : undefined;
            function getCandidate() {
                var parent = contextToken.parent;
                if (ts.isImportEqualsDeclaration(parent)) {
                    return isModuleSpecifierMissingOrEmpty(parent.moduleReference) ? parent : undefined;
                }
                if (ts.isNamedImports(parent) || ts.isNamespaceImport(parent)) {
                    if (isModuleSpecifierMissingOrEmpty(parent.parent.parent.moduleSpecifier) && (ts.isNamespaceImport(parent) || parent.elements.length < 2) && !parent.parent.name) {
                        // At `import { ... } |` or `import * as Foo |`, the only possible completion is `from`
                        return contextToken.kind === 19 /* CloseBraceToken */ || contextToken.kind === 79 /* Identifier */
                            ? 154 /* FromKeyword */
                            : parent.parent.parent;
                    }
                    return undefined;
                }
                if (ts.isImportKeyword(contextToken) && ts.isSourceFile(parent)) {
                    // A lone import keyword with nothing following it does not parse as a statement at all
                    return contextToken;
                }
                if (ts.isImportKeyword(contextToken) && ts.isImportDeclaration(parent)) {
                    // `import s| from`
                    return isModuleSpecifierMissingOrEmpty(parent.moduleSpecifier) ? parent : undefined;
                }
                return undefined;
            }
        }
        function isModuleSpecifierMissingOrEmpty(specifier) {
            var _a;
            if (ts.nodeIsMissing(specifier))
                return true;
            return !((_a = ts.tryCast(ts.isExternalModuleReference(specifier) ? specifier.expression : specifier, ts.isStringLiteralLike)) === null || _a === void 0 ? void 0 : _a.text);
        }
        function getVariableDeclaration(property) {
            var variableDeclaration = ts.findAncestor(property, function (node) {
                return ts.isFunctionBlock(node) || isArrowFunctionBody(node) || ts.isBindingPattern(node)
                    ? "quit"
                    : ts.isVariableDeclaration(node);
            });
            return variableDeclaration;
        }
        function isArrowFunctionBody(node) {
            return node.parent && ts.isArrowFunction(node.parent) && node.parent.body === node;
        }
        ;
        /** True if symbol is a type or a module containing at least one type. */
        function symbolCanBeReferencedAtTypeLocation(symbol, checker, seenModules) {
            if (seenModules === void 0) { seenModules = new ts.Map(); }
            var sym = ts.skipAlias(symbol.exportSymbol || symbol, checker);
            return !!(sym.flags & 788968 /* Type */) || checker.isUnknownSymbol(sym) ||
                !!(sym.flags & 1536 /* Module */) && ts.addToSeen(seenModules, ts.getSymbolId(sym)) &&
                    checker.getExportsOfModule(sym).some(function (e) { return symbolCanBeReferencedAtTypeLocation(e, checker, seenModules); });
        }
        function isDeprecated(symbol, checker) {
            var declarations = ts.skipAlias(symbol, checker).declarations;
            return !!ts.length(declarations) && ts.every(declarations, ts.isDeprecatedDeclaration);
        }
        /**
         * True if the first character of `lowercaseCharacters` is the first character
         * of some "word" in `identiferString` (where the string is split into "words"
         * by camelCase and snake_case segments), then if the remaining characters of
         * `lowercaseCharacters` appear, in order, in the rest of `identifierString`.
         *
         * True:
         * 'state' in 'useState'
         * 'sae' in 'useState'
         * 'viable' in 'ENVIRONMENT_VARIABLE'
         *
         * False:
         * 'staet' in 'useState'
         * 'tate' in 'useState'
         * 'ment' in 'ENVIRONMENT_VARIABLE'
         */
        function charactersFuzzyMatchInString(identifierString, lowercaseCharacters) {
            if (lowercaseCharacters.length === 0) {
                return true;
            }
            var matchedFirstCharacter = false;
            var prevChar;
            var characterIndex = 0;
            var len = identifierString.length;
            for (var strIndex = 0; strIndex < len; strIndex++) {
                var strChar = identifierString.charCodeAt(strIndex);
                var testChar = lowercaseCharacters.charCodeAt(characterIndex);
                if (strChar === testChar || strChar === toUpperCharCode(testChar)) {
                    matchedFirstCharacter || (matchedFirstCharacter = prevChar === undefined || // Beginning of word
                        97 /* a */ <= prevChar && prevChar <= 122 /* z */ && 65 /* A */ <= strChar && strChar <= 90 /* Z */ || // camelCase transition
                        prevChar === 95 /* _ */ && strChar !== 95 /* _ */); // snake_case transition
                    if (matchedFirstCharacter) {
                        characterIndex++;
                    }
                    if (characterIndex === lowercaseCharacters.length) {
                        return true;
                    }
                }
                prevChar = strChar;
            }
            // Did not find all characters
            return false;
        }
        function toUpperCharCode(charCode) {
            if (97 /* a */ <= charCode && charCode <= 122 /* z */) {
                return charCode - 32;
            }
            return charCode;
        }
    })(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    /* @internal */
    var DocumentHighlights;
    (function (DocumentHighlights) {
        function getDocumentHighlights(program, cancellationToken, sourceFile, position, sourceFilesToSearch) {
            var node = ts.getTouchingPropertyName(sourceFile, position);
            if (node.parent && (ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node || ts.isJsxClosingElement(node.parent))) {
                // For a JSX element, just highlight the matching tag, not all references.
                var _a = node.parent.parent, openingElement = _a.openingElement, closingElement = _a.closingElement;
                var highlightSpans = [openingElement, closingElement].map(function (_a) {
                    var tagName = _a.tagName;
                    return getHighlightSpanForNode(tagName, sourceFile);
                });
                return [{ fileName: sourceFile.fileName, highlightSpans: highlightSpans }];
            }
            return getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) || getSyntacticDocumentHighlights(node, sourceFile);
        }
        DocumentHighlights.getDocumentHighlights = getDocumentHighlights;
        function getHighlightSpanForNode(node, sourceFile) {
            return {
                fileName: sourceFile.fileName,
                textSpan: ts.createTextSpanFromNode(node, sourceFile),
                kind: "none" /* none */
            };
        }
        function getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) {
            var sourceFilesSet = new ts.Set(sourceFilesToSearch.map(function (f) { return f.fileName; }));
            var referenceEntries = ts.FindAllReferences.getReferenceEntriesForNode(position, node, program, sourceFilesToSearch, cancellationToken, /*options*/ undefined, sourceFilesSet);
            if (!referenceEntries)
                return undefined;
            var map = ts.arrayToMultiMap(referenceEntries.map(ts.FindAllReferences.toHighlightSpan), function (e) { return e.fileName; }, function (e) { return e.span; });
            var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
            return ts.mapDefined(ts.arrayFrom(map.entries()), function (_a) {
                var fileName = _a[0], highlightSpans = _a[1];
                if (!sourceFilesSet.has(fileName)) {
                    if (!program.redirectTargetsMap.has(ts.toPath(fileName, program.getCurrentDirectory(), getCanonicalFileName))) {
                        return undefined;
                    }
                    var redirectTarget_1 = program.getSourceFile(fileName);
                    var redirect = ts.find(sourceFilesToSearch, function (f) { return !!f.redirectInfo && f.redirectInfo.redirectTarget === redirectTarget_1; });
                    fileName = redirect.fileName;
                    ts.Debug.assert(sourceFilesSet.has(fileName));
                }
                return { fileName: fileName, highlightSpans: highlightSpans };
            });
        }
        function getSyntacticDocumentHighlights(node, sourceFile) {
            var highlightSpans = getHighlightSpans(node, sourceFile);
            return highlightSpans && [{ fileName: sourceFile.fileName, highlightSpans: highlightSpans }];
        }
        function getHighlightSpans(node, sourceFile) {
            switch (node.kind) {
                case 99 /* IfKeyword */:
                case 91 /* ElseKeyword */:
                    return ts.isIfStatement(node.parent) ? getIfElseOccurrences(node.parent, sourceFile) : undefined;
                case 105 /* ReturnKeyword */:
                    return useParent(node.parent, ts.isReturnStatement, getReturnOccurrences);
                case 109 /* ThrowKeyword */:
                    return useParent(node.parent, ts.isThrowStatement, getThrowOccurrences);
                case 111 /* TryKeyword */:
                case 83 /* CatchKeyword */:
                case 96 /* FinallyKeyword */:
                    var tryStatement = node.kind === 83 /* CatchKeyword */ ? node.parent.parent : node.parent;
                    return useParent(tryStatement, ts.isTryStatement, getTryCatchFinallyOccurrences);
                case 107 /* SwitchKeyword */:
                    return useParent(node.parent, ts.isSwitchStatement, getSwitchCaseDefaultOccurrences);
                case 82 /* CaseKeyword */:
                case 88 /* DefaultKeyword */: {
                    if (ts.isDefaultClause(node.parent) || ts.isCaseClause(node.parent)) {
                        return useParent(node.parent.parent.parent, ts.isSwitchStatement, getSwitchCaseDefaultOccurrences);
                    }
                    return undefined;
                }
                case 81 /* BreakKeyword */:
                case 86 /* ContinueKeyword */:
                    return useParent(node.parent, ts.isBreakOrContinueStatement, getBreakOrContinueStatementOccurrences);
                case 97 /* ForKeyword */:
                case 115 /* WhileKeyword */:
                case 90 /* DoKeyword */:
                    return useParent(node.parent, function (n) { return ts.isIterationStatement(n, /*lookInLabeledStatements*/ true); }, getLoopBreakContinueOccurrences);
                case 133 /* ConstructorKeyword */:
                    return getFromAllDeclarations(ts.isConstructorDeclaration, [133 /* ConstructorKeyword */]);
                case 135 /* GetKeyword */:
                case 147 /* SetKeyword */:
                    return getFromAllDeclarations(ts.isAccessor, [135 /* GetKeyword */, 147 /* SetKeyword */]);
                case 131 /* AwaitKeyword */:
                    return useParent(node.parent, ts.isAwaitExpression, getAsyncAndAwaitOccurrences);
                case 130 /* AsyncKeyword */:
                    return highlightSpans(getAsyncAndAwaitOccurrences(node));
                case 125 /* YieldKeyword */:
                    return highlightSpans(getYieldOccurrences(node));
                default:
                    return ts.isModifierKind(node.kind) && (ts.isDeclaration(node.parent) || ts.isVariableStatement(node.parent))
                        ? highlightSpans(getModifierOccurrences(node.kind, node.parent))
                        : undefined;
            }
            function getFromAllDeclarations(nodeTest, keywords) {
                return useParent(node.parent, nodeTest, function (decl) { return ts.mapDefined(decl.symbol.declarations, function (d) {
                    return nodeTest(d) ? ts.find(d.getChildren(sourceFile), function (c) { return ts.contains(keywords, c.kind); }) : undefined;
                }); });
            }
            function useParent(node, nodeTest, getNodes) {
                return nodeTest(node) ? highlightSpans(getNodes(node, sourceFile)) : undefined;
            }
            function highlightSpans(nodes) {
                return nodes && nodes.map(function (node) { return getHighlightSpanForNode(node, sourceFile); });
            }
        }
        /**
         * Aggregates all throw-statements within this node *without* crossing
         * into function boundaries and try-blocks with catch-clauses.
         */
        function aggregateOwnedThrowStatements(node) {
            if (ts.isThrowStatement(node)) {
                return [node];
            }
            else if (ts.isTryStatement(node)) {
                // Exceptions thrown within a try block lacking a catch clause are "owned" in the current context.
                return ts.concatenate(node.catchClause ? aggregateOwnedThrowStatements(node.catchClause) : node.tryBlock && aggregateOwnedThrowStatements(node.tryBlock), node.finallyBlock && aggregateOwnedThrowStatements(node.finallyBlock));
            }
            // Do not cross function boundaries.
            return ts.isFunctionLike(node) ? undefined : flatMapChildren(node, aggregateOwnedThrowStatements);
        }
        /**
         * For lack of a better name, this function takes a throw statement and returns the
         * nearest ancestor that is a try-block (whose try statement has a catch clause),
         * function-block, or source file.
         */
        function getThrowStatementOwner(throwStatement) {
            var child = throwStatement;
            while (child.parent) {
                var parent = child.parent;
                if (ts.isFunctionBlock(parent) || parent.kind === 300 /* SourceFile */) {
                    return parent;
                }
                // A throw-statement is only owned by a try-statement if the try-statement has
                // a catch clause, and if the throw-statement occurs within the try block.
                if (ts.isTryStatement(parent) && parent.tryBlock === child && parent.catchClause) {
                    return child;
                }
                child = parent;
            }
            return undefined;
        }
        function aggregateAllBreakAndContinueStatements(node) {
            return ts.isBreakOrContinueStatement(node) ? [node] : ts.isFunctionLike(node) ? undefined : flatMapChildren(node, aggregateAllBreakAndContinueStatements);
        }
        function flatMapChildren(node, cb) {
            var result = [];
            node.forEachChild(function (child) {
                var value = cb(child);
                if (value !== undefined) {
                    result.push.apply(result, ts.toArray(value));
                }
            });
            return result;
        }
        function ownsBreakOrContinueStatement(owner, statement) {
            var actualOwner = getBreakOrContinueOwner(statement);
            return !!actualOwner && actualOwner === owner;
        }
        function getBreakOrContinueOwner(statement) {
            return ts.findAncestor(statement, function (node) {
                switch (node.kind) {
                    case 247 /* SwitchStatement */:
                        if (statement.kind === 243 /* ContinueStatement */) {
                            return false;
                        }
                    // falls through
                    case 240 /* ForStatement */:
                    case 241 /* ForInStatement */:
                    case 242 /* ForOfStatement */:
                    case 239 /* WhileStatement */:
                    case 238 /* DoStatement */:
                        return !statement.label || isLabeledBy(node, statement.label.escapedText);
                    default:
                        // Don't cross function boundaries.
                        // TODO: GH#20090
                        return ts.isFunctionLike(node) && "quit";
                }
            });
        }
        function getModifierOccurrences(modifier, declaration) {
            return ts.mapDefined(getNodesToSearchForModifier(declaration, ts.modifierToFlag(modifier)), function (node) { return ts.findModifier(node, modifier); });
        }
        function getNodesToSearchForModifier(declaration, modifierFlag) {
            // Types of node whose children might have modifiers.
            var container = declaration.parent;
            switch (container.kind) {
                case 260 /* ModuleBlock */:
                case 300 /* SourceFile */:
                case 233 /* Block */:
                case 287 /* CaseClause */:
                case 288 /* DefaultClause */:
                    // Container is either a class declaration or the declaration is a classDeclaration
                    if (modifierFlag & 128 /* Abstract */ && ts.isClassDeclaration(declaration)) {
                        return __spreadArray(__spreadArray([], declaration.members, true), [declaration], false);
                    }
                    else {
                        return container.statements;
                    }
                case 169 /* Constructor */:
                case 167 /* MethodDeclaration */:
                case 254 /* FunctionDeclaration */:
                    return __spreadArray(__spreadArray([], container.parameters, true), (ts.isClassLike(container.parent) ? container.parent.members : []), true);
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                case 256 /* InterfaceDeclaration */:
                case 180 /* TypeLiteral */:
                    var nodes = container.members;
                    // If we're an accessibility modifier, we're in an instance member and should search
                    // the constructor's parameter list for instance members as well.
                    if (modifierFlag & (28 /* AccessibilityModifier */ | 64 /* Readonly */)) {
                        var constructor = ts.find(container.members, ts.isConstructorDeclaration);
                        if (constructor) {
                            return __spreadArray(__spreadArray([], nodes, true), constructor.parameters, true);
                        }
                    }
                    else if (modifierFlag & 128 /* Abstract */) {
                        return __spreadArray(__spreadArray([], nodes, true), [container], false);
                    }
                    return nodes;
                // Syntactically invalid positions that the parser might produce anyway
                case 203 /* ObjectLiteralExpression */:
                    return undefined;
                default:
                    ts.Debug.assertNever(container, "Invalid container kind.");
            }
        }
        function pushKeywordIf(keywordList, token) {
            var expected = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                expected[_i - 2] = arguments[_i];
            }
            if (token && ts.contains(expected, token.kind)) {
                keywordList.push(token);
                return true;
            }
            return false;
        }
        function getLoopBreakContinueOccurrences(loopNode) {
            var keywords = [];
            if (pushKeywordIf(keywords, loopNode.getFirstToken(), 97 /* ForKeyword */, 115 /* WhileKeyword */, 90 /* DoKeyword */)) {
                // If we succeeded and got a do-while loop, then start looking for a 'while' keyword.
                if (loopNode.kind === 238 /* DoStatement */) {
                    var loopTokens = loopNode.getChildren();
                    for (var i = loopTokens.length - 1; i >= 0; i--) {
                        if (pushKeywordIf(keywords, loopTokens[i], 115 /* WhileKeyword */)) {
                            break;
                        }
                    }
                }
            }
            ts.forEach(aggregateAllBreakAndContinueStatements(loopNode.statement), function (statement) {
                if (ownsBreakOrContinueStatement(loopNode, statement)) {
                    pushKeywordIf(keywords, statement.getFirstToken(), 81 /* BreakKeyword */, 86 /* ContinueKeyword */);
                }
            });
            return keywords;
        }
        function getBreakOrContinueStatementOccurrences(breakOrContinueStatement) {
            var owner = getBreakOrContinueOwner(breakOrContinueStatement);
            if (owner) {
                switch (owner.kind) {
                    case 240 /* ForStatement */:
                    case 241 /* ForInStatement */:
                    case 242 /* ForOfStatement */:
                    case 238 /* DoStatement */:
                    case 239 /* WhileStatement */:
                        return getLoopBreakContinueOccurrences(owner);
                    case 247 /* SwitchStatement */:
                        return getSwitchCaseDefaultOccurrences(owner);
                }
            }
            return undefined;
        }
        function getSwitchCaseDefaultOccurrences(switchStatement) {
            var keywords = [];
            pushKeywordIf(keywords, switchStatement.getFirstToken(), 107 /* SwitchKeyword */);
            // Go through each clause in the switch statement, collecting the 'case'/'default' keywords.
            ts.forEach(switchStatement.caseBlock.clauses, function (clause) {
                pushKeywordIf(keywords, clause.getFirstToken(), 82 /* CaseKeyword */, 88 /* DefaultKeyword */);
                ts.forEach(aggregateAllBreakAndContinueStatements(clause), function (statement) {
                    if (ownsBreakOrContinueStatement(switchStatement, statement)) {
                        pushKeywordIf(keywords, statement.getFirstToken(), 81 /* BreakKeyword */);
                    }
                });
            });
            return keywords;
        }
        function getTryCatchFinallyOccurrences(tryStatement, sourceFile) {
            var keywords = [];
            pushKeywordIf(keywords, tryStatement.getFirstToken(), 111 /* TryKeyword */);
            if (tryStatement.catchClause) {
                pushKeywordIf(keywords, tryStatement.catchClause.getFirstToken(), 83 /* CatchKeyword */);
            }
            if (tryStatement.finallyBlock) {
                var finallyKeyword = ts.findChildOfKind(tryStatement, 96 /* FinallyKeyword */, sourceFile);
                pushKeywordIf(keywords, finallyKeyword, 96 /* FinallyKeyword */);
            }
            return keywords;
        }
        function getThrowOccurrences(throwStatement, sourceFile) {
            var owner = getThrowStatementOwner(throwStatement);
            if (!owner) {
                return undefined;
            }
            var keywords = [];
            ts.forEach(aggregateOwnedThrowStatements(owner), function (throwStatement) {
                keywords.push(ts.findChildOfKind(throwStatement, 109 /* ThrowKeyword */, sourceFile));
            });
            // If the "owner" is a function, then we equate 'return' and 'throw' statements in their
            // ability to "jump out" of the function, and include occurrences for both.
            if (ts.isFunctionBlock(owner)) {
                ts.forEachReturnStatement(owner, function (returnStatement) {
                    keywords.push(ts.findChildOfKind(returnStatement, 105 /* ReturnKeyword */, sourceFile));
                });
            }
            return keywords;
        }
        function getReturnOccurrences(returnStatement, sourceFile) {
            var func = ts.getContainingFunction(returnStatement);
            if (!func) {
                return undefined;
            }
            var keywords = [];
            ts.forEachReturnStatement(ts.cast(func.body, ts.isBlock), function (returnStatement) {
                keywords.push(ts.findChildOfKind(returnStatement, 105 /* ReturnKeyword */, sourceFile));
            });
            // Include 'throw' statements that do not occur within a try block.
            ts.forEach(aggregateOwnedThrowStatements(func.body), function (throwStatement) {
                keywords.push(ts.findChildOfKind(throwStatement, 109 /* ThrowKeyword */, sourceFile));
            });
            return keywords;
        }
        function getAsyncAndAwaitOccurrences(node) {
            var func = ts.getContainingFunction(node);
            if (!func) {
                return undefined;
            }
            var keywords = [];
            if (func.modifiers) {
                func.modifiers.forEach(function (modifier) {
                    pushKeywordIf(keywords, modifier, 130 /* AsyncKeyword */);
                });
            }
            ts.forEachChild(func, function (child) {
                traverseWithoutCrossingFunction(child, function (node) {
                    if (ts.isAwaitExpression(node)) {
                        pushKeywordIf(keywords, node.getFirstToken(), 131 /* AwaitKeyword */);
                    }
                });
            });
            return keywords;
        }
        function getYieldOccurrences(node) {
            var func = ts.getContainingFunction(node);
            if (!func) {
                return undefined;
            }
            var keywords = [];
            ts.forEachChild(func, function (child) {
                traverseWithoutCrossingFunction(child, function (node) {
                    if (ts.isYieldExpression(node)) {
                        pushKeywordIf(keywords, node.getFirstToken(), 125 /* YieldKeyword */);
                    }
                });
            });
            return keywords;
        }
        // Do not cross function/class/interface/module/type boundaries.
        function traverseWithoutCrossingFunction(node, cb) {
            cb(node);
            if (!ts.isFunctionLike(node) && !ts.isClassLike(node) && !ts.isInterfaceDeclaration(node) && !ts.isModuleDeclaration(node) && !ts.isTypeAliasDeclaration(node) && !ts.isTypeNode(node)) {
                ts.forEachChild(node, function (child) { return traverseWithoutCrossingFunction(child, cb); });
            }
        }
        function getIfElseOccurrences(ifStatement, sourceFile) {
            var keywords = getIfElseKeywords(ifStatement, sourceFile);
            var result = [];
            // We'd like to highlight else/ifs together if they are only separated by whitespace
            // (i.e. the keywords are separated by no comments, no newlines).
            for (var i = 0; i < keywords.length; i++) {
                if (keywords[i].kind === 91 /* ElseKeyword */ && i < keywords.length - 1) {
                    var elseKeyword = keywords[i];
                    var ifKeyword = keywords[i + 1]; // this *should* always be an 'if' keyword.
                    var shouldCombineElseAndIf = true;
                    // Avoid recalculating getStart() by iterating backwards.
                    for (var j = ifKeyword.getStart(sourceFile) - 1; j >= elseKeyword.end; j--) {
                        if (!ts.isWhiteSpaceSingleLine(sourceFile.text.charCodeAt(j))) {
                            shouldCombineElseAndIf = false;
                            break;
                        }
                    }
                    if (shouldCombineElseAndIf) {
                        result.push({
                            fileName: sourceFile.fileName,
                            textSpan: ts.createTextSpanFromBounds(elseKeyword.getStart(), ifKeyword.end),
                            kind: "reference" /* reference */
                        });
                        i++; // skip the next keyword
                        continue;
                    }
                }
                // Ordinary case: just highlight the keyword.
                result.push(getHighlightSpanForNode(keywords[i], sourceFile));
            }
            return result;
        }
        function getIfElseKeywords(ifStatement, sourceFile) {
            var keywords = [];
            // Traverse upwards through all parent if-statements linked by their else-branches.
            while (ts.isIfStatement(ifStatement.parent) && ifStatement.parent.elseStatement === ifStatement) {
                ifStatement = ifStatement.parent;
            }
            // Now traverse back down through the else branches, aggregating if/else keywords of if-statements.
            while (true) {
                var children = ifStatement.getChildren(sourceFile);
                pushKeywordIf(keywords, children[0], 99 /* IfKeyword */);
                // Generally the 'else' keyword is second-to-last, so we traverse backwards.
                for (var i = children.length - 1; i >= 0; i--) {
                    if (pushKeywordIf(keywords, children[i], 91 /* ElseKeyword */)) {
                        break;
                    }
                }
                if (!ifStatement.elseStatement || !ts.isIfStatement(ifStatement.elseStatement)) {
                    break;
                }
                ifStatement = ifStatement.elseStatement;
            }
            return keywords;
        }
        /**
         * Whether or not a 'node' is preceded by a label of the given string.
         * Note: 'node' cannot be a SourceFile.
         */
        function isLabeledBy(node, labelName) {
            return !!ts.findAncestor(node.parent, function (owner) { return !ts.isLabeledStatement(owner) ? "quit" : owner.label.escapedText === labelName; });
        }
    })(DocumentHighlights = ts.DocumentHighlights || (ts.DocumentHighlights = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    function isDocumentRegistryEntry(entry) {
        return !!entry.sourceFile;
    }
    function createDocumentRegistry(useCaseSensitiveFileNames, currentDirectory) {
        return createDocumentRegistryInternal(useCaseSensitiveFileNames, currentDirectory);
    }
    ts.createDocumentRegistry = createDocumentRegistry;
    /*@internal*/
    function createDocumentRegistryInternal(useCaseSensitiveFileNames, currentDirectory, externalCache) {
        if (currentDirectory === void 0) { currentDirectory = ""; }
        // Maps from compiler setting target (ES3, ES5, etc.) to all the cached documents we have
        // for those settings.
        var buckets = new ts.Map();
        var getCanonicalFileName = ts.createGetCanonicalFileName(!!useCaseSensitiveFileNames);
        function reportStats() {
            var bucketInfoArray = ts.arrayFrom(buckets.keys()).filter(function (name) { return name && name.charAt(0) === "_"; }).map(function (name) {
                var entries = buckets.get(name);
                var sourceFiles = [];
                entries.forEach(function (entry, name) {
                    if (isDocumentRegistryEntry(entry)) {
                        sourceFiles.push({
                            name: name,
                            scriptKind: entry.sourceFile.scriptKind,
                            refCount: entry.languageServiceRefCount
                        });
                    }
                    else {
                        entry.forEach(function (value, scriptKind) { return sourceFiles.push({ name: name, scriptKind: scriptKind, refCount: value.languageServiceRefCount }); });
                    }
                });
                sourceFiles.sort(function (x, y) { return y.refCount - x.refCount; });
                return {
                    bucket: name,
                    sourceFiles: sourceFiles
                };
            });
            return JSON.stringify(bucketInfoArray, undefined, 2);
        }
        function acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
            var path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
            var key = getKeyForCompilationSettings(compilationSettings);
            return acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind);
        }
        function acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
            return acquireOrUpdateDocument(fileName, path, compilationSettings, key, scriptSnapshot, version, /*acquiring*/ true, scriptKind);
        }
        function updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
            var path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
            var key = getKeyForCompilationSettings(compilationSettings);
            return updateDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind);
        }
        function updateDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
            return acquireOrUpdateDocument(fileName, path, compilationSettings, key, scriptSnapshot, version, /*acquiring*/ false, scriptKind);
        }
        function getDocumentRegistryEntry(bucketEntry, scriptKind) {
            var entry = isDocumentRegistryEntry(bucketEntry) ? bucketEntry : bucketEntry.get(ts.Debug.checkDefined(scriptKind, "If there are more than one scriptKind's for same document the scriptKind should be provided"));
            ts.Debug.assert(scriptKind === undefined || !entry || entry.sourceFile.scriptKind === scriptKind, "Script kind should match provided ScriptKind:" + scriptKind + " and sourceFile.scriptKind: " + (entry === null || entry === void 0 ? void 0 : entry.sourceFile.scriptKind) + ", !entry: " + !entry);
            return entry;
        }
        function acquireOrUpdateDocument(fileName, path, compilationSettings, key, scriptSnapshot, version, acquiring, scriptKind) {
            scriptKind = ts.ensureScriptKind(fileName, scriptKind);
            var scriptTarget = scriptKind === 6 /* JSON */ ? 100 /* JSON */ : compilationSettings.target || 1 /* ES5 */;
            var bucket = ts.getOrUpdate(buckets, key, function () { return new ts.Map(); });
            var bucketEntry = bucket.get(path);
            var entry = bucketEntry && getDocumentRegistryEntry(bucketEntry, scriptKind);
            if (!entry && externalCache) {
                var sourceFile = externalCache.getDocument(key, path);
                if (sourceFile) {
                    ts.Debug.assert(acquiring);
                    entry = {
                        sourceFile: sourceFile,
                        languageServiceRefCount: 0
                    };
                    setBucketEntry();
                }
            }
            if (!entry) {
                // Have never seen this file with these settings.  Create a new source file for it.
                var sourceFile = ts.createLanguageServiceSourceFile(fileName, scriptSnapshot, scriptTarget, version, /*setNodeParents*/ false, scriptKind);
                if (externalCache) {
                    externalCache.setDocument(key, path, sourceFile);
                }
                entry = {
                    sourceFile: sourceFile,
                    languageServiceRefCount: 1,
                };
                setBucketEntry();
            }
            else {
                // We have an entry for this file.  However, it may be for a different version of
                // the script snapshot.  If so, update it appropriately.  Otherwise, we can just
                // return it as is.
                if (entry.sourceFile.version !== version) {
                    entry.sourceFile = ts.updateLanguageServiceSourceFile(entry.sourceFile, scriptSnapshot, version, scriptSnapshot.getChangeRange(entry.sourceFile.scriptSnapshot)); // TODO: GH#18217
                    if (externalCache) {
                        externalCache.setDocument(key, path, entry.sourceFile);
                    }
                }
                // If we're acquiring, then this is the first time this LS is asking for this document.
                // Increase our ref count so we know there's another LS using the document.  If we're
                // not acquiring, then that means the LS is 'updating' the file instead, and that means
                // it has already acquired the document previously.  As such, we do not need to increase
                // the ref count.
                if (acquiring) {
                    entry.languageServiceRefCount++;
                }
            }
            ts.Debug.assert(entry.languageServiceRefCount !== 0);
            return entry.sourceFile;
            function setBucketEntry() {
                if (!bucketEntry) {
                    bucket.set(path, entry);
                }
                else if (isDocumentRegistryEntry(bucketEntry)) {
                    var scriptKindMap = new ts.Map();
                    scriptKindMap.set(bucketEntry.sourceFile.scriptKind, bucketEntry);
                    scriptKindMap.set(scriptKind, entry);
                    bucket.set(path, scriptKindMap);
                }
                else {
                    bucketEntry.set(scriptKind, entry);
                }
            }
        }
        function releaseDocument(fileName, compilationSettings, scriptKind) {
            var path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
            var key = getKeyForCompilationSettings(compilationSettings);
            return releaseDocumentWithKey(path, key, scriptKind);
        }
        function releaseDocumentWithKey(path, key, scriptKind) {
            var bucket = ts.Debug.checkDefined(buckets.get(key));
            var bucketEntry = bucket.get(path);
            var entry = getDocumentRegistryEntry(bucketEntry, scriptKind);
            entry.languageServiceRefCount--;
            ts.Debug.assert(entry.languageServiceRefCount >= 0);
            if (entry.languageServiceRefCount === 0) {
                if (isDocumentRegistryEntry(bucketEntry)) {
                    bucket.delete(path);
                }
                else {
                    bucketEntry.delete(scriptKind);
                    if (bucketEntry.size === 1) {
                        bucket.set(path, ts.firstDefinedIterator(bucketEntry.values(), ts.identity));
                    }
                }
            }
        }
        function getLanguageServiceRefCounts(path, scriptKind) {
            return ts.arrayFrom(buckets.entries(), function (_a) {
                var key = _a[0], bucket = _a[1];
                var bucketEntry = bucket.get(path);
                var entry = bucketEntry && getDocumentRegistryEntry(bucketEntry, scriptKind);
                return [key, entry && entry.languageServiceRefCount];
            });
        }
        return {
            acquireDocument: acquireDocument,
            acquireDocumentWithKey: acquireDocumentWithKey,
            updateDocument: updateDocument,
            updateDocumentWithKey: updateDocumentWithKey,
            releaseDocument: releaseDocument,
            releaseDocumentWithKey: releaseDocumentWithKey,
            getLanguageServiceRefCounts: getLanguageServiceRefCounts,
            reportStats: reportStats,
            getKeyForCompilationSettings: getKeyForCompilationSettings
        };
    }
    ts.createDocumentRegistryInternal = createDocumentRegistryInternal;
    function getKeyForCompilationSettings(settings) {
        return ts.sourceFileAffectingCompilerOptions.map(function (option) { return ts.getCompilerOptionValue(settings, option); }).join("|");
    }
})(ts || (ts = {}));
/* Code for finding imports of an exported symbol. Used only by FindAllReferences. */
/* @internal */
var ts;
(function (ts) {
    var FindAllReferences;
    (function (FindAllReferences) {
        /** Creates the imports map and returns an ImportTracker that uses it. Call this lazily to avoid calling `getDirectImportsMap` unnecessarily.  */
        function createImportTracker(sourceFiles, sourceFilesSet, checker, cancellationToken) {
            var allDirectImports = getDirectImportsMap(sourceFiles, checker, cancellationToken);
            return function (exportSymbol, exportInfo, isForRename) {
                var _a = getImportersForExport(sourceFiles, sourceFilesSet, allDirectImports, exportInfo, checker, cancellationToken), directImports = _a.directImports, indirectUsers = _a.indirectUsers;
                return __assign({ indirectUsers: indirectUsers }, getSearchesFromDirectImports(directImports, exportSymbol, exportInfo.exportKind, checker, isForRename));
            };
        }
        FindAllReferences.createImportTracker = createImportTracker;
        var ExportKind;
        (function (ExportKind) {
            ExportKind[ExportKind["Named"] = 0] = "Named";
            ExportKind[ExportKind["Default"] = 1] = "Default";
            ExportKind[ExportKind["ExportEquals"] = 2] = "ExportEquals";
        })(ExportKind = FindAllReferences.ExportKind || (FindAllReferences.ExportKind = {}));
        var ImportExport;
        (function (ImportExport) {
            ImportExport[ImportExport["Import"] = 0] = "Import";
            ImportExport[ImportExport["Export"] = 1] = "Export";
        })(ImportExport = FindAllReferences.ImportExport || (FindAllReferences.ImportExport = {}));
        /** Returns import statements that directly reference the exporting module, and a list of files that may access the module through a namespace. */
        function getImportersForExport(sourceFiles, sourceFilesSet, allDirectImports, _a, checker, cancellationToken) {
            var exportingModuleSymbol = _a.exportingModuleSymbol, exportKind = _a.exportKind;
            var markSeenDirectImport = ts.nodeSeenTracker();
            var markSeenIndirectUser = ts.nodeSeenTracker();
            var directImports = [];
            var isAvailableThroughGlobal = !!exportingModuleSymbol.globalExports;
            var indirectUserDeclarations = isAvailableThroughGlobal ? undefined : [];
            handleDirectImports(exportingModuleSymbol);
            return { directImports: directImports, indirectUsers: getIndirectUsers() };
            function getIndirectUsers() {
                if (isAvailableThroughGlobal) {
                    // It has `export as namespace`, so anything could potentially use it.
                    return sourceFiles;
                }
                // Module augmentations may use this module's exports without importing it.
                if (exportingModuleSymbol.declarations) {
                    for (var _i = 0, _a = exportingModuleSymbol.declarations; _i < _a.length; _i++) {
                        var decl = _a[_i];
                        if (ts.isExternalModuleAugmentation(decl) && sourceFilesSet.has(decl.getSourceFile().fileName)) {
                            addIndirectUser(decl);
                        }
                    }
                }
                // This may return duplicates (if there are multiple module declarations in a single source file, all importing the same thing as a namespace), but `State.markSearchedSymbol` will handle that.
                return indirectUserDeclarations.map(ts.getSourceFileOfNode);
            }
            function handleDirectImports(exportingModuleSymbol) {
                var theseDirectImports = getDirectImports(exportingModuleSymbol);
                if (theseDirectImports) {
                    for (var _i = 0, theseDirectImports_1 = theseDirectImports; _i < theseDirectImports_1.length; _i++) {
                        var direct = theseDirectImports_1[_i];
                        if (!markSeenDirectImport(direct)) {
                            continue;
                        }
                        if (cancellationToken)
                            cancellationToken.throwIfCancellationRequested();
                        switch (direct.kind) {
                            case 206 /* CallExpression */:
                                if (ts.isImportCall(direct)) {
                                    handleImportCall(direct);
                                    break;
                                }
                                if (!isAvailableThroughGlobal) {
                                    var parent = direct.parent;
                                    if (exportKind === 2 /* ExportEquals */ && parent.kind === 252 /* VariableDeclaration */) {
                                        var name = parent.name;
                                        if (name.kind === 79 /* Identifier */) {
                                            directImports.push(name);
                                            break;
                                        }
                                    }
                                }
                                break;
                            case 79 /* Identifier */: // for 'const x = require("y");
                                break; // TODO: GH#23879
                            case 263 /* ImportEqualsDeclaration */:
                                handleNamespaceImport(direct, direct.name, ts.hasSyntacticModifier(direct, 1 /* Export */), /*alreadyAddedDirect*/ false);
                                break;
                            case 264 /* ImportDeclaration */:
                                directImports.push(direct);
                                var namedBindings = direct.importClause && direct.importClause.namedBindings;
                                if (namedBindings && namedBindings.kind === 266 /* NamespaceImport */) {
                                    handleNamespaceImport(direct, namedBindings.name, /*isReExport*/ false, /*alreadyAddedDirect*/ true);
                                }
                                else if (!isAvailableThroughGlobal && ts.isDefaultImport(direct)) {
                                    addIndirectUser(getSourceFileLikeForImportDeclaration(direct)); // Add a check for indirect uses to handle synthetic default imports
                                }
                                break;
                            case 270 /* ExportDeclaration */:
                                if (!direct.exportClause) {
                                    // This is `export * from "foo"`, so imports of this module may import the export too.
                                    handleDirectImports(getContainingModuleSymbol(direct, checker));
                                }
                                else if (direct.exportClause.kind === 272 /* NamespaceExport */) {
                                    // `export * as foo from "foo"` add to indirect uses
                                    addIndirectUser(getSourceFileLikeForImportDeclaration(direct), /** addTransitiveDependencies */ true);
                                }
                                else {
                                    // This is `export { foo } from "foo"` and creates an alias symbol, so recursive search will get handle re-exports.
                                    directImports.push(direct);
                                }
                                break;
                            case 198 /* ImportType */:
                                // Only check for typeof import('xyz')
                                if (direct.isTypeOf && !direct.qualifier && isExported(direct)) {
                                    addIndirectUser(direct.getSourceFile(), /** addTransitiveDependencies */ true);
                                }
                                directImports.push(direct);
                                break;
                            default:
                                ts.Debug.failBadSyntaxKind(direct, "Unexpected import kind.");
                        }
                    }
                }
            }
            function handleImportCall(importCall) {
                var top = ts.findAncestor(importCall, isAmbientModuleDeclaration) || importCall.getSourceFile();
                addIndirectUser(top, /** addTransitiveDependencies */ !!isExported(importCall, /** stopAtAmbientModule */ true));
            }
            function isExported(node, stopAtAmbientModule) {
                if (stopAtAmbientModule === void 0) { stopAtAmbientModule = false; }
                return ts.findAncestor(node, function (node) {
                    if (stopAtAmbientModule && isAmbientModuleDeclaration(node))
                        return "quit";
                    return ts.some(node.modifiers, function (mod) { return mod.kind === 93 /* ExportKeyword */; });
                });
            }
            function handleNamespaceImport(importDeclaration, name, isReExport, alreadyAddedDirect) {
                if (exportKind === 2 /* ExportEquals */) {
                    // This is a direct import, not import-as-namespace.
                    if (!alreadyAddedDirect)
                        directImports.push(importDeclaration);
                }
                else if (!isAvailableThroughGlobal) {
                    var sourceFileLike = getSourceFileLikeForImportDeclaration(importDeclaration);
                    ts.Debug.assert(sourceFileLike.kind === 300 /* SourceFile */ || sourceFileLike.kind === 259 /* ModuleDeclaration */);
                    if (isReExport || findNamespaceReExports(sourceFileLike, name, checker)) {
                        addIndirectUser(sourceFileLike, /** addTransitiveDependencies */ true);
                    }
                    else {
                        addIndirectUser(sourceFileLike);
                    }
                }
            }
            /** Adds a module and all of its transitive dependencies as possible indirect users. */
            function addIndirectUser(sourceFileLike, addTransitiveDependencies) {
                if (addTransitiveDependencies === void 0) { addTransitiveDependencies = false; }
                ts.Debug.assert(!isAvailableThroughGlobal);
                var isNew = markSeenIndirectUser(sourceFileLike);
                if (!isNew)
                    return;
                indirectUserDeclarations.push(sourceFileLike); // TODO: GH#18217
                if (!addTransitiveDependencies)
                    return;
                var moduleSymbol = checker.getMergedSymbol(sourceFileLike.symbol);
                if (!moduleSymbol)
                    return;
                ts.Debug.assert(!!(moduleSymbol.flags & 1536 /* Module */));
                var directImports = getDirectImports(moduleSymbol);
                if (directImports) {
                    for (var _i = 0, directImports_1 = directImports; _i < directImports_1.length; _i++) {
                        var directImport = directImports_1[_i];
                        if (!ts.isImportTypeNode(directImport)) {
                            addIndirectUser(getSourceFileLikeForImportDeclaration(directImport), /** addTransitiveDependencies */ true);
                        }
                    }
                }
            }
            function getDirectImports(moduleSymbol) {
                return allDirectImports.get(ts.getSymbolId(moduleSymbol).toString());
            }
        }
        /**
         * Given the set of direct imports of a module, we need to find which ones import the particular exported symbol.
         * The returned `importSearches` will result in the entire source file being searched.
         * But re-exports will be placed in 'singleReferences' since they cannot be locally referenced.
         */
        function getSearchesFromDirectImports(directImports, exportSymbol, exportKind, checker, isForRename) {
            var importSearches = [];
            var singleReferences = [];
            function addSearch(location, symbol) {
                importSearches.push([location, symbol]);
            }
            if (directImports) {
                for (var _i = 0, directImports_2 = directImports; _i < directImports_2.length; _i++) {
                    var decl = directImports_2[_i];
                    handleImport(decl);
                }
            }
            return { importSearches: importSearches, singleReferences: singleReferences };
            function handleImport(decl) {
                if (decl.kind === 263 /* ImportEqualsDeclaration */) {
                    if (isExternalModuleImportEquals(decl)) {
                        handleNamespaceImportLike(decl.name);
                    }
                    return;
                }
                if (decl.kind === 79 /* Identifier */) {
                    handleNamespaceImportLike(decl);
                    return;
                }
                if (decl.kind === 198 /* ImportType */) {
                    if (decl.qualifier) {
                        var firstIdentifier = ts.getFirstIdentifier(decl.qualifier);
                        if (firstIdentifier.escapedText === ts.symbolName(exportSymbol)) {
                            singleReferences.push(firstIdentifier);
                        }
                    }
                    else if (exportKind === 2 /* ExportEquals */) {
                        singleReferences.push(decl.argument.literal);
                    }
                    return;
                }
                // Ignore if there's a grammar error
                if (decl.moduleSpecifier.kind !== 10 /* StringLiteral */) {
                    return;
                }
                if (decl.kind === 270 /* ExportDeclaration */) {
                    if (decl.exportClause && ts.isNamedExports(decl.exportClause)) {
                        searchForNamedImport(decl.exportClause);
                    }
                    return;
                }
                var _a = decl.importClause || { name: undefined, namedBindings: undefined }, name = _a.name, namedBindings = _a.namedBindings;
                if (namedBindings) {
                    switch (namedBindings.kind) {
                        case 266 /* NamespaceImport */:
                            handleNamespaceImportLike(namedBindings.name);
                            break;
                        case 267 /* NamedImports */:
                            // 'default' might be accessed as a named import `{ default as foo }`.
                            if (exportKind === 0 /* Named */ || exportKind === 1 /* Default */) {
                                searchForNamedImport(namedBindings);
                            }
                            break;
                        default:
                            ts.Debug.assertNever(namedBindings);
                    }
                }
                // `export =` might be imported by a default import if `--allowSyntheticDefaultImports` is on, so this handles both ExportKind.Default and ExportKind.ExportEquals.
                // If a default import has the same name as the default export, allow to rename it.
                // Given `import f` and `export default function f`, we will rename both, but for `import g` we will rename just that.
                if (name && (exportKind === 1 /* Default */ || exportKind === 2 /* ExportEquals */) && (!isForRename || name.escapedText === ts.symbolEscapedNameNoDefault(exportSymbol))) {
                    var defaultImportAlias = checker.getSymbolAtLocation(name);
                    addSearch(name, defaultImportAlias);
                }
            }
            /**
             * `import x = require("./x")` or `import * as x from "./x"`.
             * An `export =` may be imported by this syntax, so it may be a direct import.
             * If it's not a direct import, it will be in `indirectUsers`, so we don't have to do anything here.
             */
            function handleNamespaceImportLike(importName) {
                // Don't rename an import that already has a different name than the export.
                if (exportKind === 2 /* ExportEquals */ && (!isForRename || isNameMatch(importName.escapedText))) {
                    addSearch(importName, checker.getSymbolAtLocation(importName));
                }
            }
            function searchForNamedImport(namedBindings) {
                if (!namedBindings) {
                    return;
                }
                for (var _i = 0, _a = namedBindings.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    var name = element.name, propertyName = element.propertyName;
                    if (!isNameMatch((propertyName || name).escapedText)) {
                        continue;
                    }
                    if (propertyName) {
                        // This is `import { foo as bar } from "./a"` or `export { foo as bar } from "./a"`. `foo` isn't a local in the file, so just add it as a single reference.
                        singleReferences.push(propertyName);
                        // If renaming `{ foo as bar }`, don't touch `bar`, just `foo`.
                        // But do rename `foo` in ` { default as foo }` if that's the original export name.
                        if (!isForRename || name.escapedText === exportSymbol.escapedName) {
                            // Search locally for `bar`.
                            addSearch(name, checker.getSymbolAtLocation(name));
                        }
                    }
                    else {
                        var localSymbol = element.kind === 273 /* ExportSpecifier */ && element.propertyName
                            ? checker.getExportSpecifierLocalTargetSymbol(element) // For re-exporting under a different name, we want to get the re-exported symbol.
                            : checker.getSymbolAtLocation(name);
                        addSearch(name, localSymbol);
                    }
                }
            }
            function isNameMatch(name) {
                // Use name of "default" even in `export =` case because we may have allowSyntheticDefaultImports
                return name === exportSymbol.escapedName || exportKind !== 0 /* Named */ && name === "default" /* Default */;
            }
        }
        /** Returns 'true' is the namespace 'name' is re-exported from this module, and 'false' if it is only used locally. */
        function findNamespaceReExports(sourceFileLike, name, checker) {
            var namespaceImportSymbol = checker.getSymbolAtLocation(name);
            return !!forEachPossibleImportOrExportStatement(sourceFileLike, function (statement) {
                if (!ts.isExportDeclaration(statement))
                    return;
                var exportClause = statement.exportClause, moduleSpecifier = statement.moduleSpecifier;
                return !moduleSpecifier && exportClause && ts.isNamedExports(exportClause) &&
                    exportClause.elements.some(function (element) { return checker.getExportSpecifierLocalTargetSymbol(element) === namespaceImportSymbol; });
            });
        }
        function findModuleReferences(program, sourceFiles, searchModuleSymbol) {
            var refs = [];
            var checker = program.getTypeChecker();
            for (var _i = 0, sourceFiles_1 = sourceFiles; _i < sourceFiles_1.length; _i++) {
                var referencingFile = sourceFiles_1[_i];
                var searchSourceFile = searchModuleSymbol.valueDeclaration;
                if ((searchSourceFile === null || searchSourceFile === void 0 ? void 0 : searchSourceFile.kind) === 300 /* SourceFile */) {
                    for (var _a = 0, _b = referencingFile.referencedFiles; _a < _b.length; _a++) {
                        var ref = _b[_a];
                        if (program.getSourceFileFromReference(referencingFile, ref) === searchSourceFile) {
                            refs.push({ kind: "reference", referencingFile: referencingFile, ref: ref });
                        }
                    }
                    for (var _c = 0, _d = referencingFile.typeReferenceDirectives; _c < _d.length; _c++) {
                        var ref = _d[_c];
                        var referenced = program.getResolvedTypeReferenceDirectives().get(ref.fileName);
                        if (referenced !== undefined && referenced.resolvedFileName === searchSourceFile.fileName) {
                            refs.push({ kind: "reference", referencingFile: referencingFile, ref: ref });
                        }
                    }
                }
                forEachImport(referencingFile, function (_importDecl, moduleSpecifier) {
                    var moduleSymbol = checker.getSymbolAtLocation(moduleSpecifier);
                    if (moduleSymbol === searchModuleSymbol) {
                        refs.push({ kind: "import", literal: moduleSpecifier });
                    }
                });
            }
            return refs;
        }
        FindAllReferences.findModuleReferences = findModuleReferences;
        /** Returns a map from a module symbol Id to all import statements that directly reference the module. */
        function getDirectImportsMap(sourceFiles, checker, cancellationToken) {
            var map = new ts.Map();
            for (var _i = 0, sourceFiles_2 = sourceFiles; _i < sourceFiles_2.length; _i++) {
                var sourceFile = sourceFiles_2[_i];
                if (cancellationToken)
                    cancellationToken.throwIfCancellationRequested();
                forEachImport(sourceFile, function (importDecl, moduleSpecifier) {
                    var moduleSymbol = checker.getSymbolAtLocation(moduleSpecifier);
                    if (moduleSymbol) {
                        var id = ts.getSymbolId(moduleSymbol).toString();
                        var imports = map.get(id);
                        if (!imports) {
                            map.set(id, imports = []);
                        }
                        imports.push(importDecl);
                    }
                });
            }
            return map;
        }
        /** Iterates over all statements at the top level or in module declarations. Returns the first truthy result. */
        function forEachPossibleImportOrExportStatement(sourceFileLike, action) {
            return ts.forEach(sourceFileLike.kind === 300 /* SourceFile */ ? sourceFileLike.statements : sourceFileLike.body.statements, function (statement) {
                return action(statement) || (isAmbientModuleDeclaration(statement) && ts.forEach(statement.body && statement.body.statements, action));
            });
        }
        /** Calls `action` for each import, re-export, or require() in a file. */
        function forEachImport(sourceFile, action) {
            if (sourceFile.externalModuleIndicator || sourceFile.imports !== undefined) {
                for (var _i = 0, _a = sourceFile.imports; _i < _a.length; _i++) {
                    var i = _a[_i];
                    action(ts.importFromModuleSpecifier(i), i);
                }
            }
            else {
                forEachPossibleImportOrExportStatement(sourceFile, function (statement) {
                    switch (statement.kind) {
                        case 270 /* ExportDeclaration */:
                        case 264 /* ImportDeclaration */: {
                            var decl = statement;
                            if (decl.moduleSpecifier && ts.isStringLiteral(decl.moduleSpecifier)) {
                                action(decl, decl.moduleSpecifier);
                            }
                            break;
                        }
                        case 263 /* ImportEqualsDeclaration */: {
                            var decl = statement;
                            if (isExternalModuleImportEquals(decl)) {
                                action(decl, decl.moduleReference.expression);
                            }
                            break;
                        }
                    }
                });
            }
        }
        /**
         * Given a local reference, we might notice that it's an import/export and recursively search for references of that.
         * If at an import, look locally for the symbol it imports.
         * If at an export, look for all imports of it.
         * This doesn't handle export specifiers; that is done in `getReferencesAtExportSpecifier`.
         * @param comingFromExport If we are doing a search for all exports, don't bother looking backwards for the imported symbol, since that's the reason we're here.
         */
        function getImportOrExportSymbol(node, symbol, checker, comingFromExport) {
            return comingFromExport ? getExport() : getExport() || getImport();
            function getExport() {
                var _a;
                var parent = node.parent;
                var grandparent = parent.parent;
                if (symbol.exportSymbol) {
                    if (parent.kind === 204 /* PropertyAccessExpression */) {
                        // When accessing an export of a JS module, there's no alias. The symbol will still be flagged as an export even though we're at the use.
                        // So check that we are at the declaration.
                        return ((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d === parent; })) && ts.isBinaryExpression(grandparent)
                            ? getSpecialPropertyExport(grandparent, /*useLhsSymbol*/ false)
                            : undefined;
                    }
                    else {
                        return exportInfo(symbol.exportSymbol, getExportKindForDeclaration(parent));
                    }
                }
                else {
                    var exportNode = getExportNode(parent, node);
                    if (exportNode && ts.hasSyntacticModifier(exportNode, 1 /* Export */)) {
                        if (ts.isImportEqualsDeclaration(exportNode) && exportNode.moduleReference === node) {
                            // We're at `Y` in `export import X = Y`. This is not the exported symbol, the left-hand-side is. So treat this as an import statement.
                            if (comingFromExport) {
                                return undefined;
                            }
                            var lhsSymbol = checker.getSymbolAtLocation(exportNode.name);
                            return { kind: 0 /* Import */, symbol: lhsSymbol };
                        }
                        else {
                            return exportInfo(symbol, getExportKindForDeclaration(exportNode));
                        }
                    }
                    else if (ts.isNamespaceExport(parent)) {
                        return exportInfo(symbol, 0 /* Named */);
                    }
                    // If we are in `export = a;` or `export default a;`, `parent` is the export assignment.
                    else if (ts.isExportAssignment(parent)) {
                        return getExportAssignmentExport(parent);
                    }
                    // If we are in `export = class A {};` (or `export = class A {};`) at `A`, `parent.parent` is the export assignment.
                    else if (ts.isExportAssignment(grandparent)) {
                        return getExportAssignmentExport(grandparent);
                    }
                    // Similar for `module.exports =` and `exports.A =`.
                    else if (ts.isBinaryExpression(parent)) {
                        return getSpecialPropertyExport(parent, /*useLhsSymbol*/ true);
                    }
                    else if (ts.isBinaryExpression(grandparent)) {
                        return getSpecialPropertyExport(grandparent, /*useLhsSymbol*/ true);
                    }
                    else if (ts.isJSDocTypedefTag(parent)) {
                        return exportInfo(symbol, 0 /* Named */);
                    }
                }
                function getExportAssignmentExport(ex) {
                    // Get the symbol for the `export =` node; its parent is the module it's the export of.
                    if (!ex.symbol.parent)
                        return undefined;
                    var exportKind = ex.isExportEquals ? 2 /* ExportEquals */ : 1 /* Default */;
                    return { kind: 1 /* Export */, symbol: symbol, exportInfo: { exportingModuleSymbol: ex.symbol.parent, exportKind: exportKind } };
                }
                function getSpecialPropertyExport(node, useLhsSymbol) {
                    var kind;
                    switch (ts.getAssignmentDeclarationKind(node)) {
                        case 1 /* ExportsProperty */:
                            kind = 0 /* Named */;
                            break;
                        case 2 /* ModuleExports */:
                            kind = 2 /* ExportEquals */;
                            break;
                        default:
                            return undefined;
                    }
                    var sym = useLhsSymbol ? checker.getSymbolAtLocation(ts.getNameOfAccessExpression(ts.cast(node.left, ts.isAccessExpression))) : symbol;
                    return sym && exportInfo(sym, kind);
                }
            }
            function getImport() {
                var isImport = isNodeImport(node);
                if (!isImport)
                    return undefined;
                // A symbol being imported is always an alias. So get what that aliases to find the local symbol.
                var importedSymbol = checker.getImmediateAliasedSymbol(symbol);
                if (!importedSymbol)
                    return undefined;
                // Search on the local symbol in the exporting module, not the exported symbol.
                importedSymbol = skipExportSpecifierSymbol(importedSymbol, checker);
                // Similarly, skip past the symbol for 'export ='
                if (importedSymbol.escapedName === "export=") {
                    importedSymbol = getExportEqualsLocalSymbol(importedSymbol, checker);
                }
                // If the import has a different name than the export, do not continue searching.
                // If `importedName` is undefined, do continue searching as the export is anonymous.
                // (All imports returned from this function will be ignored anyway if we are in rename and this is a not a named export.)
                var importedName = ts.symbolEscapedNameNoDefault(importedSymbol);
                if (importedName === undefined || importedName === "default" /* Default */ || importedName === symbol.escapedName) {
                    return { kind: 0 /* Import */, symbol: importedSymbol };
                }
            }
            function exportInfo(symbol, kind) {
                var exportInfo = getExportInfo(symbol, kind, checker);
                return exportInfo && { kind: 1 /* Export */, symbol: symbol, exportInfo: exportInfo };
            }
            // Not meant for use with export specifiers or export assignment.
            function getExportKindForDeclaration(node) {
                return ts.hasSyntacticModifier(node, 512 /* Default */) ? 1 /* Default */ : 0 /* Named */;
            }
        }
        FindAllReferences.getImportOrExportSymbol = getImportOrExportSymbol;
        function getExportEqualsLocalSymbol(importedSymbol, checker) {
            if (importedSymbol.flags & 2097152 /* Alias */) {
                return ts.Debug.checkDefined(checker.getImmediateAliasedSymbol(importedSymbol));
            }
            var decl = ts.Debug.checkDefined(importedSymbol.valueDeclaration);
            if (ts.isExportAssignment(decl)) { // `export = class {}`
                return ts.Debug.checkDefined(decl.expression.symbol);
            }
            else if (ts.isBinaryExpression(decl)) { // `module.exports = class {}`
                return ts.Debug.checkDefined(decl.right.symbol);
            }
            else if (ts.isSourceFile(decl)) { // json module
                return ts.Debug.checkDefined(decl.symbol);
            }
            return ts.Debug.fail();
        }
        // If a reference is a class expression, the exported node would be its parent.
        // If a reference is a variable declaration, the exported node would be the variable statement.
        function getExportNode(parent, node) {
            var declaration = ts.isVariableDeclaration(parent) ? parent : ts.isBindingElement(parent) ? ts.walkUpBindingElementsAndPatterns(parent) : undefined;
            if (declaration) {
                return parent.name !== node ? undefined :
                    ts.isCatchClause(declaration.parent) ? undefined : ts.isVariableStatement(declaration.parent.parent) ? declaration.parent.parent : undefined;
            }
            else {
                return parent;
            }
        }
        function isNodeImport(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 263 /* ImportEqualsDeclaration */:
                    return parent.name === node && isExternalModuleImportEquals(parent);
                case 268 /* ImportSpecifier */:
                    // For a rename import `{ foo as bar }`, don't search for the imported symbol. Just find local uses of `bar`.
                    return !parent.propertyName;
                case 265 /* ImportClause */:
                case 266 /* NamespaceImport */:
                    ts.Debug.assert(parent.name === node);
                    return true;
                case 201 /* BindingElement */:
                    return ts.isInJSFile(node) && ts.isRequireVariableDeclaration(parent);
                default:
                    return false;
            }
        }
        function getExportInfo(exportSymbol, exportKind, checker) {
            var moduleSymbol = exportSymbol.parent;
            if (!moduleSymbol)
                return undefined; // This can happen if an `export` is not at the top-level (which is a compile error).
            var exportingModuleSymbol = checker.getMergedSymbol(moduleSymbol); // Need to get merged symbol in case there's an augmentation.
            // `export` may appear in a namespace. In that case, just rely on global search.
            return ts.isExternalModuleSymbol(exportingModuleSymbol) ? { exportingModuleSymbol: exportingModuleSymbol, exportKind: exportKind } : undefined;
        }
        FindAllReferences.getExportInfo = getExportInfo;
        /** If at an export specifier, go to the symbol it refers to. */
        function skipExportSpecifierSymbol(symbol, checker) {
            // For `export { foo } from './bar", there's nothing to skip, because it does not create a new alias. But `export { foo } does.
            if (symbol.declarations) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    if (ts.isExportSpecifier(declaration) && !declaration.propertyName && !declaration.parent.parent.moduleSpecifier) {
                        return checker.getExportSpecifierLocalTargetSymbol(declaration);
                    }
                    else if (ts.isPropertyAccessExpression(declaration) && ts.isModuleExportsAccessExpression(declaration.expression) && !ts.isPrivateIdentifier(declaration.name)) {
                        // Export of form 'module.exports.propName = expr';
                        return checker.getSymbolAtLocation(declaration);
                    }
                    else if (ts.isShorthandPropertyAssignment(declaration)
                        && ts.isBinaryExpression(declaration.parent.parent)
                        && ts.getAssignmentDeclarationKind(declaration.parent.parent) === 2 /* ModuleExports */) {
                        return checker.getExportSpecifierLocalTargetSymbol(declaration.name);
                    }
                }
            }
            return symbol;
        }
        function getContainingModuleSymbol(importer, checker) {
            return checker.getMergedSymbol(getSourceFileLikeForImportDeclaration(importer).symbol);
        }
        function getSourceFileLikeForImportDeclaration(node) {
            if (node.kind === 206 /* CallExpression */) {
                return node.getSourceFile();
            }
            var parent = node.parent;
            if (parent.kind === 300 /* SourceFile */) {
                return parent;
            }
            ts.Debug.assert(parent.kind === 260 /* ModuleBlock */);
            return ts.cast(parent.parent, isAmbientModuleDeclaration);
        }
        function isAmbientModuleDeclaration(node) {
            return node.kind === 259 /* ModuleDeclaration */ && node.name.kind === 10 /* StringLiteral */;
        }
        function isExternalModuleImportEquals(eq) {
            return eq.moduleReference.kind === 275 /* ExternalModuleReference */ && eq.moduleReference.expression.kind === 10 /* StringLiteral */;
        }
    })(FindAllReferences = ts.FindAllReferences || (ts.FindAllReferences = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var FindAllReferences;
    (function (FindAllReferences) {
        var DefinitionKind;
        (function (DefinitionKind) {
            DefinitionKind[DefinitionKind["Symbol"] = 0] = "Symbol";
            DefinitionKind[DefinitionKind["Label"] = 1] = "Label";
            DefinitionKind[DefinitionKind["Keyword"] = 2] = "Keyword";
            DefinitionKind[DefinitionKind["This"] = 3] = "This";
            DefinitionKind[DefinitionKind["String"] = 4] = "String";
            DefinitionKind[DefinitionKind["TripleSlashReference"] = 5] = "TripleSlashReference";
        })(DefinitionKind = FindAllReferences.DefinitionKind || (FindAllReferences.DefinitionKind = {}));
        var EntryKind;
        (function (EntryKind) {
            EntryKind[EntryKind["Span"] = 0] = "Span";
            EntryKind[EntryKind["Node"] = 1] = "Node";
            EntryKind[EntryKind["StringLiteral"] = 2] = "StringLiteral";
            EntryKind[EntryKind["SearchedLocalFoundProperty"] = 3] = "SearchedLocalFoundProperty";
            EntryKind[EntryKind["SearchedPropertyFoundLocal"] = 4] = "SearchedPropertyFoundLocal";
        })(EntryKind = FindAllReferences.EntryKind || (FindAllReferences.EntryKind = {}));
        function nodeEntry(node, kind) {
            if (kind === void 0) { kind = 1 /* Node */; }
            return {
                kind: kind,
                node: node.name || node,
                context: getContextNodeForNodeEntry(node)
            };
        }
        FindAllReferences.nodeEntry = nodeEntry;
        function isContextWithStartAndEndNode(node) {
            return node && node.kind === undefined;
        }
        FindAllReferences.isContextWithStartAndEndNode = isContextWithStartAndEndNode;
        function getContextNodeForNodeEntry(node) {
            if (ts.isDeclaration(node)) {
                return getContextNode(node);
            }
            if (!node.parent)
                return undefined;
            if (!ts.isDeclaration(node.parent) && !ts.isExportAssignment(node.parent)) {
                // Special property assignment in javascript
                if (ts.isInJSFile(node)) {
                    var binaryExpression = ts.isBinaryExpression(node.parent) ?
                        node.parent :
                        ts.isAccessExpression(node.parent) &&
                            ts.isBinaryExpression(node.parent.parent) &&
                            node.parent.parent.left === node.parent ?
                            node.parent.parent :
                            undefined;
                    if (binaryExpression && ts.getAssignmentDeclarationKind(binaryExpression) !== 0 /* None */) {
                        return getContextNode(binaryExpression);
                    }
                }
                // Jsx Tags
                if (ts.isJsxOpeningElement(node.parent) || ts.isJsxClosingElement(node.parent)) {
                    return node.parent.parent;
                }
                else if (ts.isJsxSelfClosingElement(node.parent) ||
                    ts.isLabeledStatement(node.parent) ||
                    ts.isBreakOrContinueStatement(node.parent)) {
                    return node.parent;
                }
                else if (ts.isStringLiteralLike(node)) {
                    var validImport = ts.tryGetImportFromModuleSpecifier(node);
                    if (validImport) {
                        var declOrStatement = ts.findAncestor(validImport, function (node) {
                            return ts.isDeclaration(node) ||
                                ts.isStatement(node) ||
                                ts.isJSDocTag(node);
                        });
                        return ts.isDeclaration(declOrStatement) ?
                            getContextNode(declOrStatement) :
                            declOrStatement;
                    }
                }
                // Handle computed property name
                var propertyName = ts.findAncestor(node, ts.isComputedPropertyName);
                return propertyName ?
                    getContextNode(propertyName.parent) :
                    undefined;
            }
            if (node.parent.name === node || // node is name of declaration, use parent
                ts.isConstructorDeclaration(node.parent) ||
                ts.isExportAssignment(node.parent) ||
                // Property name of the import export specifier or binding pattern, use parent
                ((ts.isImportOrExportSpecifier(node.parent) || ts.isBindingElement(node.parent))
                    && node.parent.propertyName === node) ||
                // Is default export
                (node.kind === 88 /* DefaultKeyword */ && ts.hasSyntacticModifier(node.parent, 513 /* ExportDefault */))) {
                return getContextNode(node.parent);
            }
            return undefined;
        }
        function getContextNode(node) {
            if (!node)
                return undefined;
            switch (node.kind) {
                case 252 /* VariableDeclaration */:
                    return !ts.isVariableDeclarationList(node.parent) || node.parent.declarations.length !== 1 ?
                        node :
                        ts.isVariableStatement(node.parent.parent) ?
                            node.parent.parent :
                            ts.isForInOrOfStatement(node.parent.parent) ?
                                getContextNode(node.parent.parent) :
                                node.parent;
                case 201 /* BindingElement */:
                    return getContextNode(node.parent.parent);
                case 268 /* ImportSpecifier */:
                    return node.parent.parent.parent;
                case 273 /* ExportSpecifier */:
                case 266 /* NamespaceImport */:
                    return node.parent.parent;
                case 265 /* ImportClause */:
                case 272 /* NamespaceExport */:
                    return node.parent;
                case 219 /* BinaryExpression */:
                    return ts.isExpressionStatement(node.parent) ?
                        node.parent :
                        node;
                case 242 /* ForOfStatement */:
                case 241 /* ForInStatement */:
                    return {
                        start: node.initializer,
                        end: node.expression
                    };
                case 291 /* PropertyAssignment */:
                case 292 /* ShorthandPropertyAssignment */:
                    return ts.isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent) ?
                        getContextNode(ts.findAncestor(node.parent, function (node) {
                            return ts.isBinaryExpression(node) || ts.isForInOrOfStatement(node);
                        })) :
                        node;
                default:
                    return node;
            }
        }
        FindAllReferences.getContextNode = getContextNode;
        function toContextSpan(textSpan, sourceFile, context) {
            if (!context)
                return undefined;
            var contextSpan = isContextWithStartAndEndNode(context) ?
                getTextSpan(context.start, sourceFile, context.end) :
                getTextSpan(context, sourceFile);
            return contextSpan.start !== textSpan.start || contextSpan.length !== textSpan.length ?
                { contextSpan: contextSpan } :
                undefined;
        }
        FindAllReferences.toContextSpan = toContextSpan;
        var FindReferencesUse;
        (function (FindReferencesUse) {
            /**
             * When searching for references to a symbol, the location will not be adjusted (this is the default behavior when not specified).
             */
            FindReferencesUse[FindReferencesUse["Other"] = 0] = "Other";
            /**
             * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.
             */
            FindReferencesUse[FindReferencesUse["References"] = 1] = "References";
            /**
             * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.
             * Unlike `References`, the location will only be adjusted keyword belonged to a declaration with a valid name.
             * If set, we will find fewer references -- if it is referenced by several different names, we still only find references for the original name.
             */
            FindReferencesUse[FindReferencesUse["Rename"] = 2] = "Rename";
        })(FindReferencesUse = FindAllReferences.FindReferencesUse || (FindAllReferences.FindReferencesUse = {}));
        function findReferencedSymbols(program, cancellationToken, sourceFiles, sourceFile, position) {
            var node = ts.getTouchingPropertyName(sourceFile, position);
            var referencedSymbols = Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, { use: 1 /* References */ });
            var checker = program.getTypeChecker();
            return !referencedSymbols || !referencedSymbols.length ? undefined : ts.mapDefined(referencedSymbols, function (_a) {
                var definition = _a.definition, references = _a.references;
                // Only include referenced symbols that have a valid definition.
                return definition && {
                    definition: checker.runWithCancellationToken(cancellationToken, function (checker) { return definitionToReferencedSymbolDefinitionInfo(definition, checker, node); }),
                    references: references.map(toReferenceEntry)
                };
            });
        }
        FindAllReferences.findReferencedSymbols = findReferencedSymbols;
        function getImplementationsAtPosition(program, cancellationToken, sourceFiles, sourceFile, position) {
            var node = ts.getTouchingPropertyName(sourceFile, position);
            var referenceEntries;
            var entries = getImplementationReferenceEntries(program, cancellationToken, sourceFiles, node, position);
            if (node.parent.kind === 204 /* PropertyAccessExpression */
                || node.parent.kind === 201 /* BindingElement */
                || node.parent.kind === 205 /* ElementAccessExpression */
                || node.kind === 106 /* SuperKeyword */) {
                referenceEntries = entries && __spreadArray([], entries, true);
            }
            else {
                var queue = entries && __spreadArray([], entries, true);
                var seenNodes = new ts.Map();
                while (queue && queue.length) {
                    var entry = queue.shift();
                    if (!ts.addToSeen(seenNodes, ts.getNodeId(entry.node))) {
                        continue;
                    }
                    referenceEntries = ts.append(referenceEntries, entry);
                    var entries_1 = getImplementationReferenceEntries(program, cancellationToken, sourceFiles, entry.node, entry.node.pos);
                    if (entries_1) {
                        queue.push.apply(queue, entries_1);
                    }
                }
            }
            var checker = program.getTypeChecker();
            return ts.map(referenceEntries, function (entry) { return toImplementationLocation(entry, checker); });
        }
        FindAllReferences.getImplementationsAtPosition = getImplementationsAtPosition;
        function getImplementationReferenceEntries(program, cancellationToken, sourceFiles, node, position) {
            if (node.kind === 300 /* SourceFile */) {
                return undefined;
            }
            var checker = program.getTypeChecker();
            // If invoked directly on a shorthand property assignment, then return
            // the declaration of the symbol being assigned (not the symbol being assigned to).
            if (node.parent.kind === 292 /* ShorthandPropertyAssignment */) {
                var result_2 = [];
                Core.getReferenceEntriesForShorthandPropertyAssignment(node, checker, function (node) { return result_2.push(nodeEntry(node)); });
                return result_2;
            }
            else if (node.kind === 106 /* SuperKeyword */ || ts.isSuperProperty(node.parent)) {
                // References to and accesses on the super keyword only have one possible implementation, so no
                // need to "Find all References"
                var symbol = checker.getSymbolAtLocation(node);
                return symbol.valueDeclaration && [nodeEntry(symbol.valueDeclaration)];
            }
            else {
                // Perform "Find all References" and retrieve only those that are implementations
                return getReferenceEntriesForNode(position, node, program, sourceFiles, cancellationToken, { implementations: true, use: 1 /* References */ });
            }
        }
        function findReferenceOrRenameEntries(program, cancellationToken, sourceFiles, node, position, options, convertEntry) {
            return ts.map(flattenEntries(Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options)), function (entry) { return convertEntry(entry, node, program.getTypeChecker()); });
        }
        FindAllReferences.findReferenceOrRenameEntries = findReferenceOrRenameEntries;
        function getReferenceEntriesForNode(position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet) {
            if (options === void 0) { options = {}; }
            if (sourceFilesSet === void 0) { sourceFilesSet = new ts.Set(sourceFiles.map(function (f) { return f.fileName; })); }
            return flattenEntries(Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet));
        }
        FindAllReferences.getReferenceEntriesForNode = getReferenceEntriesForNode;
        function flattenEntries(referenceSymbols) {
            return referenceSymbols && ts.flatMap(referenceSymbols, function (r) { return r.references; });
        }
        function definitionToReferencedSymbolDefinitionInfo(def, checker, originalNode) {
            var info = (function () {
                switch (def.type) {
                    case 0 /* Symbol */: {
                        var symbol = def.symbol;
                        var _a = getDefinitionKindAndDisplayParts(symbol, checker, originalNode), displayParts_1 = _a.displayParts, kind_1 = _a.kind;
                        var name_1 = displayParts_1.map(function (p) { return p.text; }).join("");
                        var declaration = symbol.declarations && ts.firstOrUndefined(symbol.declarations);
                        var node = declaration ? (ts.getNameOfDeclaration(declaration) || declaration) : originalNode;
                        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), { name: name_1, kind: kind_1, displayParts: displayParts_1, context: getContextNode(declaration) });
                    }
                    case 1 /* Label */: {
                        var node = def.node;
                        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), { name: node.text, kind: "label" /* label */, displayParts: [ts.displayPart(node.text, ts.SymbolDisplayPartKind.text)] });
                    }
                    case 2 /* Keyword */: {
                        var node = def.node;
                        var name_2 = ts.tokenToString(node.kind);
                        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), { name: name_2, kind: "keyword" /* keyword */, displayParts: [{ text: name_2, kind: "keyword" /* keyword */ }] });
                    }
                    case 3 /* This */: {
                        var node = def.node;
                        var symbol = checker.getSymbolAtLocation(node);
                        var displayParts_2 = symbol && ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(checker, symbol, node.getSourceFile(), ts.getContainerNode(node), node).displayParts || [ts.textPart("this")];
                        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), { name: "this", kind: "var" /* variableElement */, displayParts: displayParts_2 });
                    }
                    case 4 /* String */: {
                        var node = def.node;
                        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), { name: node.text, kind: "var" /* variableElement */, displayParts: [ts.displayPart(ts.getTextOfNode(node), ts.SymbolDisplayPartKind.stringLiteral)] });
                    }
                    case 5 /* TripleSlashReference */: {
                        return {
                            textSpan: ts.createTextSpanFromRange(def.reference),
                            sourceFile: def.file,
                            name: def.reference.fileName,
                            kind: "string" /* string */,
                            displayParts: [ts.displayPart("\"" + def.reference.fileName + "\"", ts.SymbolDisplayPartKind.stringLiteral)]
                        };
                    }
                    default:
                        return ts.Debug.assertNever(def);
                }
            })();
            var sourceFile = info.sourceFile, textSpan = info.textSpan, name = info.name, kind = info.kind, displayParts = info.displayParts, context = info.context;
            return __assign({ containerKind: "" /* unknown */, containerName: "", fileName: sourceFile.fileName, kind: kind, name: name, textSpan: textSpan, displayParts: displayParts }, toContextSpan(textSpan, sourceFile, context));
        }
        function getFileAndTextSpanFromNode(node) {
            var sourceFile = node.getSourceFile();
            return {
                sourceFile: sourceFile,
                textSpan: getTextSpan(ts.isComputedPropertyName(node) ? node.expression : node, sourceFile)
            };
        }
        function getDefinitionKindAndDisplayParts(symbol, checker, node) {
            var meaning = Core.getIntersectingMeaningFromDeclarations(node, symbol);
            var enclosingDeclaration = symbol.declarations && ts.firstOrUndefined(symbol.declarations) || node;
            var _a = ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(checker, symbol, enclosingDeclaration.getSourceFile(), enclosingDeclaration, enclosingDeclaration, meaning), displayParts = _a.displayParts, symbolKind = _a.symbolKind;
            return { displayParts: displayParts, kind: symbolKind };
        }
        function toRenameLocation(entry, originalNode, checker, providePrefixAndSuffixText) {
            return __assign(__assign({}, entryToDocumentSpan(entry)), (providePrefixAndSuffixText && getPrefixAndSuffixText(entry, originalNode, checker)));
        }
        FindAllReferences.toRenameLocation = toRenameLocation;
        function toReferenceEntry(entry) {
            var documentSpan = entryToDocumentSpan(entry);
            if (entry.kind === 0 /* Span */) {
                return __assign(__assign({}, documentSpan), { isWriteAccess: false, isDefinition: false });
            }
            var kind = entry.kind, node = entry.node;
            return __assign(__assign({}, documentSpan), { isWriteAccess: isWriteAccessForReference(node), isDefinition: isDefinitionForReference(node), isInString: kind === 2 /* StringLiteral */ ? true : undefined });
        }
        FindAllReferences.toReferenceEntry = toReferenceEntry;
        function entryToDocumentSpan(entry) {
            if (entry.kind === 0 /* Span */) {
                return { textSpan: entry.textSpan, fileName: entry.fileName };
            }
            else {
                var sourceFile = entry.node.getSourceFile();
                var textSpan = getTextSpan(entry.node, sourceFile);
                return __assign({ textSpan: textSpan, fileName: sourceFile.fileName }, toContextSpan(textSpan, sourceFile, entry.context));
            }
        }
        function getPrefixAndSuffixText(entry, originalNode, checker) {
            if (entry.kind !== 0 /* Span */ && ts.isIdentifier(originalNode)) {
                var node = entry.node, kind = entry.kind;
                var parent = node.parent;
                var name = originalNode.text;
                var isShorthandAssignment = ts.isShorthandPropertyAssignment(parent);
                if (isShorthandAssignment || (ts.isObjectBindingElementWithoutPropertyName(parent) && parent.name === node && parent.dotDotDotToken === undefined)) {
                    var prefixColon = { prefixText: name + ": " };
                    var suffixColon = { suffixText: ": " + name };
                    if (kind === 3 /* SearchedLocalFoundProperty */) {
                        return prefixColon;
                    }
                    if (kind === 4 /* SearchedPropertyFoundLocal */) {
                        return suffixColon;
                    }
                    // In `const o = { x }; o.x`, symbolAtLocation at `x` in `{ x }` is the property symbol.
                    // For a binding element `const { x } = o;`, symbolAtLocation at `x` is the property symbol.
                    if (isShorthandAssignment) {
                        var grandParent = parent.parent;
                        if (ts.isObjectLiteralExpression(grandParent) &&
                            ts.isBinaryExpression(grandParent.parent) &&
                            ts.isModuleExportsAccessExpression(grandParent.parent.left)) {
                            return prefixColon;
                        }
                        return suffixColon;
                    }
                    else {
                        return prefixColon;
                    }
                }
                else if (ts.isImportSpecifier(parent) && !parent.propertyName) {
                    // If the original symbol was using this alias, just rename the alias.
                    var originalSymbol = ts.isExportSpecifier(originalNode.parent) ? checker.getExportSpecifierLocalTargetSymbol(originalNode.parent) : checker.getSymbolAtLocation(originalNode);
                    return ts.contains(originalSymbol.declarations, parent) ? { prefixText: name + " as " } : ts.emptyOptions;
                }
                else if (ts.isExportSpecifier(parent) && !parent.propertyName) {
                    // If the symbol for the node is same as declared node symbol use prefix text
                    return originalNode === entry.node || checker.getSymbolAtLocation(originalNode) === checker.getSymbolAtLocation(entry.node) ?
                        { prefixText: name + " as " } :
                        { suffixText: " as " + name };
                }
            }
            return ts.emptyOptions;
        }
        function toImplementationLocation(entry, checker) {
            var documentSpan = entryToDocumentSpan(entry);
            if (entry.kind !== 0 /* Span */) {
                var node = entry.node;
                return __assign(__assign({}, documentSpan), implementationKindDisplayParts(node, checker));
            }
            else {
                return __assign(__assign({}, documentSpan), { kind: "" /* unknown */, displayParts: [] });
            }
        }
        function implementationKindDisplayParts(node, checker) {
            var symbol = checker.getSymbolAtLocation(ts.isDeclaration(node) && node.name ? node.name : node);
            if (symbol) {
                return getDefinitionKindAndDisplayParts(symbol, checker, node);
            }
            else if (node.kind === 203 /* ObjectLiteralExpression */) {
                return {
                    kind: "interface" /* interfaceElement */,
                    displayParts: [ts.punctuationPart(20 /* OpenParenToken */), ts.textPart("object literal"), ts.punctuationPart(21 /* CloseParenToken */)]
                };
            }
            else if (node.kind === 224 /* ClassExpression */) {
                return {
                    kind: "local class" /* localClassElement */,
                    displayParts: [ts.punctuationPart(20 /* OpenParenToken */), ts.textPart("anonymous local class"), ts.punctuationPart(21 /* CloseParenToken */)]
                };
            }
            else {
                return { kind: ts.getNodeKind(node), displayParts: [] };
            }
        }
        function toHighlightSpan(entry) {
            var documentSpan = entryToDocumentSpan(entry);
            if (entry.kind === 0 /* Span */) {
                return {
                    fileName: documentSpan.fileName,
                    span: {
                        textSpan: documentSpan.textSpan,
                        kind: "reference" /* reference */
                    }
                };
            }
            var writeAccess = isWriteAccessForReference(entry.node);
            var span = __assign({ textSpan: documentSpan.textSpan, kind: writeAccess ? "writtenReference" /* writtenReference */ : "reference" /* reference */, isInString: entry.kind === 2 /* StringLiteral */ ? true : undefined }, documentSpan.contextSpan && { contextSpan: documentSpan.contextSpan });
            return { fileName: documentSpan.fileName, span: span };
        }
        FindAllReferences.toHighlightSpan = toHighlightSpan;
        function getTextSpan(node, sourceFile, endNode) {
            var start = node.getStart(sourceFile);
            var end = (endNode || node).getEnd();
            if (ts.isStringLiteralLike(node)) {
                ts.Debug.assert(endNode === undefined);
                start += 1;
                end -= 1;
            }
            return ts.createTextSpanFromBounds(start, end);
        }
        function getTextSpanOfEntry(entry) {
            return entry.kind === 0 /* Span */ ? entry.textSpan :
                getTextSpan(entry.node, entry.node.getSourceFile());
        }
        FindAllReferences.getTextSpanOfEntry = getTextSpanOfEntry;
        /** A node is considered a writeAccess iff it is a name of a declaration or a target of an assignment */
        function isWriteAccessForReference(node) {
            var decl = ts.getDeclarationFromName(node);
            return !!decl && declarationIsWriteAccess(decl) || node.kind === 88 /* DefaultKeyword */ || ts.isWriteAccess(node);
        }
        function isDefinitionForReference(node) {
            return node.kind === 88 /* DefaultKeyword */
                || !!ts.getDeclarationFromName(node)
                || ts.isLiteralComputedPropertyDeclarationName(node)
                || (node.kind === 133 /* ConstructorKeyword */ && ts.isConstructorDeclaration(node.parent));
        }
        /**
         * True if 'decl' provides a value, as in `function f() {}`;
         * false if 'decl' is just a location for a future write, as in 'let x;'
         */
        function declarationIsWriteAccess(decl) {
            // Consider anything in an ambient declaration to be a write access since it may be coming from JS.
            if (!!(decl.flags & 8388608 /* Ambient */))
                return true;
            switch (decl.kind) {
                case 219 /* BinaryExpression */:
                case 201 /* BindingElement */:
                case 255 /* ClassDeclaration */:
                case 224 /* ClassExpression */:
                case 88 /* DefaultKeyword */:
                case 258 /* EnumDeclaration */:
                case 294 /* EnumMember */:
                case 273 /* ExportSpecifier */:
                case 265 /* ImportClause */: // default import
                case 263 /* ImportEqualsDeclaration */:
                case 268 /* ImportSpecifier */:
                case 256 /* InterfaceDeclaration */:
                case 333 /* JSDocCallbackTag */:
                case 340 /* JSDocTypedefTag */:
                case 283 /* JsxAttribute */:
                case 259 /* ModuleDeclaration */:
                case 262 /* NamespaceExportDeclaration */:
                case 266 /* NamespaceImport */:
                case 272 /* NamespaceExport */:
                case 162 /* Parameter */:
                case 292 /* ShorthandPropertyAssignment */:
                case 257 /* TypeAliasDeclaration */:
                case 161 /* TypeParameter */:
                    return true;
                case 291 /* PropertyAssignment */:
                    // In `({ x: y } = 0);`, `x` is not a write access. (Won't call this function for `y`.)
                    return !ts.isArrayLiteralOrObjectLiteralDestructuringPattern(decl.parent);
                case 254 /* FunctionDeclaration */:
                case 211 /* FunctionExpression */:
                case 169 /* Constructor */:
                case 167 /* MethodDeclaration */:
                case 170 /* GetAccessor */:
                case 171 /* SetAccessor */:
                    return !!decl.body;
                case 252 /* VariableDeclaration */:
                case 165 /* PropertyDeclaration */:
                    return !!decl.initializer || ts.isCatchClause(decl.parent);
                case 166 /* MethodSignature */:
                case 164 /* PropertySignature */:
                case 342 /* JSDocPropertyTag */:
                case 335 /* JSDocParameterTag */:
                    return false;
                default:
                    return ts.Debug.failBadSyntaxKind(decl);
            }
        }
        /** Encapsulates the core find-all-references algorithm. */
        var Core;
        (function (Core) {
            /** Core find-all-references algorithm. Handles special cases before delegating to `getReferencedSymbolsForSymbol`. */
            function getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet) {
                var _a, _b;
                if (options === void 0) { options = {}; }
                if (sourceFilesSet === void 0) { sourceFilesSet = new ts.Set(sourceFiles.map(function (f) { return f.fileName; })); }
                if (options.use === 1 /* References */) {
                    node = ts.getAdjustedReferenceLocation(node);
                }
                else if (options.use === 2 /* Rename */) {
                    node = ts.getAdjustedRenameLocation(node);
                }
                if (ts.isSourceFile(node)) {
                    var resolvedRef = ts.GoToDefinition.getReferenceAtPosition(node, position, program);
                    if (!(resolvedRef === null || resolvedRef === void 0 ? void 0 : resolvedRef.file)) {
                        return undefined;
                    }
                    var moduleSymbol = program.getTypeChecker().getMergedSymbol(resolvedRef.file.symbol);
                    if (moduleSymbol) {
                        return getReferencedSymbolsForModule(program, moduleSymbol, /*excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet);
                    }
                    var fileIncludeReasons = program.getFileIncludeReasons();
                    if (!fileIncludeReasons) {
                        return undefined;
                    }
                    return [{
                            definition: { type: 5 /* TripleSlashReference */, reference: resolvedRef.reference, file: node },
                            references: getReferencesForNonModule(resolvedRef.file, fileIncludeReasons, program) || ts.emptyArray
                        }];
                }
                if (!options.implementations) {
                    var special = getReferencedSymbolsSpecial(node, sourceFiles, cancellationToken);
                    if (special) {
                        return special;
                    }
                }
                var checker = program.getTypeChecker();
                // constructors should use the class symbol, detected by name, if present
                var symbol = checker.getSymbolAtLocation(ts.isConstructorDeclaration(node) && node.parent.name || node);
                // Could not find a symbol e.g. unknown identifier
                if (!symbol) {
                    // String literal might be a property (and thus have a symbol), so do this here rather than in getReferencedSymbolsSpecial.
                    if (!options.implementations && ts.isStringLiteralLike(node)) {
                        if (ts.isModuleSpecifierLike(node)) {
                            var fileIncludeReasons = program.getFileIncludeReasons();
                            var referencedFileName = (_b = (_a = node.getSourceFile().resolvedModules) === null || _a === void 0 ? void 0 : _a.get(node.text)) === null || _b === void 0 ? void 0 : _b.resolvedFileName;
                            var referencedFile = referencedFileName ? program.getSourceFile(referencedFileName) : undefined;
                            if (referencedFile) {
                                return [{ definition: { type: 4 /* String */, node: node }, references: getReferencesForNonModule(referencedFile, fileIncludeReasons, program) || ts.emptyArray }];
                            }
                            // Fall through to string literal references. This is not very likely to return
                            // anything useful, but I guess it's better than nothing, and there's an existing
                            // test that expects this to happen (fourslash/cases/untypedModuleImport.ts).
                        }
                        return getReferencesForStringLiteral(node, sourceFiles, checker, cancellationToken);
                    }
                    return undefined;
                }
                if (symbol.escapedName === "export=" /* ExportEquals */) {
                    return getReferencedSymbolsForModule(program, symbol.parent, /*excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet);
                }
                var moduleReferences = getReferencedSymbolsForModuleIfDeclaredBySourceFile(symbol, program, sourceFiles, cancellationToken, options, sourceFilesSet);
                if (moduleReferences && !(symbol.flags & 33554432 /* Transient */)) {
                    return moduleReferences;
                }
                var aliasedSymbol = getMergedAliasedSymbolOfNamespaceExportDeclaration(node, symbol, checker);
                var moduleReferencesOfExportTarget = aliasedSymbol &&
                    getReferencedSymbolsForModuleIfDeclaredBySourceFile(aliasedSymbol, program, sourceFiles, cancellationToken, options, sourceFilesSet);
                var references = getReferencedSymbolsForSymbol(symbol, node, sourceFiles, sourceFilesSet, checker, cancellationToken, options);
                return mergeReferences(program, moduleReferences, references, moduleReferencesOfExportTarget);
            }
            Core.getReferencedSymbolsForNode = getReferencedSymbolsForNode;
            function getReferencesForFileName(fileName, program, sourceFiles, sourceFilesSet) {
                var _a, _b;
                if (sourceFilesSet === void 0) { sourceFilesSet = new ts.Set(sourceFiles.map(function (f) { return f.fileName; })); }
                var moduleSymbol = (_a = program.getSourceFile(fileName)) === null || _a === void 0 ? void 0 : _a.symbol;
                if (moduleSymbol) {
                    return ((_b = getReferencedSymbolsForModule(program, moduleSymbol, /*excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet)[0]) === null || _b === void 0 ? void 0 : _b.references) || ts.emptyArray;
                }
                var fileIncludeReasons = program.getFileIncludeReasons();
                var referencedFile = program.getSourceFile(fileName);
                return referencedFile && fileIncludeReasons && getReferencesForNonModule(referencedFile, fileIncludeReasons, program) || ts.emptyArray;
            }
            Core.getReferencesForFileName = getReferencesForFileName;
            function getReferencesForNonModule(referencedFile, refFileMap, program) {
                var entries;
                var references = refFileMap.get(referencedFile.path) || ts.emptyArray;
                for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                    var ref = references_1[_i];
                    if (ts.isReferencedFile(ref)) {
                        var referencingFile = program.getSourceFileByPath(ref.file);
                        var location = ts.getReferencedFileLocation(program.getSourceFileByPath, ref);
                        if (ts.isReferenceFileLocation(location)) {
                            entries = ts.append(entries, {
                                kind: 0 /* Span */,
                                fileName: referencingFile.fileName,
                                textSpan: ts.createTextSpanFromRange(location)
                            });
                        }
                    }
                }
                return entries;
            }
            function getMergedAliasedSymbolOfNamespaceExportDeclaration(node, symbol, checker) {
                if (node.parent && ts.isNamespaceExportDeclaration(node.parent)) {
                    var aliasedSymbol = checker.getAliasedSymbol(symbol);
                    var targetSymbol = checker.getMergedSymbol(aliasedSymbol);
                    if (aliasedSymbol !== targetSymbol) {
                        return targetSymbol;
                    }
                }
                return undefined;
            }
            function getReferencedSymbolsForModuleIfDeclaredBySourceFile(symbol, program, sourceFiles, cancellationToken, options, sourceFilesSet) {
                var moduleSourceFile = (symbol.flags & 1536 /* Module */) && symbol.declarations && ts.find(symbol.declarations, ts.isSourceFile);
                if (!moduleSourceFile)
                    return undefined;
                var exportEquals = symbol.exports.get("export=" /* ExportEquals */);
                // If !!exportEquals, we're about to add references to `import("mod")` anyway, so don't double-count them.
                var moduleReferences = getReferencedSymbolsForModule(program, symbol, !!exportEquals, sourceFiles, sourceFilesSet);
                if (!exportEquals || !sourceFilesSet.has(moduleSourceFile.fileName))
                    return moduleReferences;
                // Continue to get references to 'export ='.
                var checker = program.getTypeChecker();
                symbol = ts.skipAlias(exportEquals, checker);
                return mergeReferences(program, moduleReferences, getReferencedSymbolsForSymbol(symbol, /*node*/ undefined, sourceFiles, sourceFilesSet, checker, cancellationToken, options));
            }
            /**
             * Merges the references by sorting them (by file index in sourceFiles and their location in it) that point to same definition symbol
             */
            function mergeReferences(program) {
                var referencesToMerge = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    referencesToMerge[_i - 1] = arguments[_i];
                }
                var result;
                for (var _a = 0, referencesToMerge_1 = referencesToMerge; _a < referencesToMerge_1.length; _a++) {
                    var references = referencesToMerge_1[_a];
                    if (!references || !references.length)
                        continue;
                    if (!result) {
                        result = references;
                        continue;
                    }
                    var _loop_4 = function (entry) {
                        if (!entry.definition || entry.definition.type !== 0 /* Symbol */) {
                            result.push(entry);
                            return "continue";
                        }
                        var symbol = entry.definition.symbol;
                        var refIndex = ts.findIndex(result, function (ref) { return !!ref.definition &&
                            ref.definition.type === 0 /* Symbol */ &&
                            ref.definition.symbol === symbol; });
                        if (refIndex === -1) {
                            result.push(entry);
                            return "continue";
                        }
                        var reference = result[refIndex];
                        result[refIndex] = {
                            definition: reference.definition,
                            references: reference.references.concat(entry.references).sort(function (entry1, entry2) {
                                var entry1File = getSourceFileIndexOfEntry(program, entry1);
                                var entry2File = getSourceFileIndexOfEntry(program, entry2);
                                if (entry1File !== entry2File) {
                                    return ts.compareValues(entry1File, entry2File);
                                }
                                var entry1Span = getTextSpanOfEntry(entry1);
                                var entry2Span = getTextSpanOfEntry(entry2);
                                return entry1Span.start !== entry2Span.start ?
                                    ts.compareValues(entry1Span.start, entry2Span.start) :
                                    ts.compareValues(entry1Span.length, entry2Span.length);
                            })
                        };
                    };
                    for (var _b = 0, references_2 = references; _b < references_2.length; _b++) {
                        var entry = references_2[_b];
                        _loop_4(entry);
                    }
                }
                return result;
            }
            function getSourceFileIndexOfEntry(program, entry) {
                var sourceFile = entry.kind === 0 /* Span */ ?
                    program.getSourceFile(entry.fileName) :
                    entry.node.getSourceFile();
                return program.getSourceFiles().indexOf(sourceFile);
            }
            function getReferencedSymbolsForModule(program, symbol, excludeImportTypeOfExportEquals, sourceFiles, sourceFilesSet) {
                ts.Debug.assert(!!symbol.valueDeclaration);
                var references = ts.mapDefined(FindAllReferences.findModuleReferences(program, sourceFiles, symbol), function (reference) {
                    if (reference.kind === "import") {
                        var parent = reference.literal.parent;
                        if (ts.isLiteralTypeNode(parent)) {
                            var importType = ts.cast(parent.parent, ts.isImportTypeNode);
                            if (excludeImportTypeOfExportEquals && !importType.qualifier) {
                                return undefined;
                            }
                        }
                        // import("foo") with no qualifier will reference the `export =` of the module, which may be referenced anyway.
                        return nodeEntry(reference.literal);
                    }
                    else {
                        return {
                            kind: 0 /* Span */,
                            fileName: reference.referencingFile.fileName,
                            textSpan: ts.createTextSpanFromRange(reference.ref),
                        };
                    }
                });
                if (symbol.declarations) {
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var decl = _a[_i];
                        switch (decl.kind) {
                            case 300 /* SourceFile */:
                                // Don't include the source file itself. (This may not be ideal behavior, but awkward to include an entire file as a reference.)
                                break;
                            case 259 /* ModuleDeclaration */:
                                if (sourceFilesSet.has(decl.getSourceFile().fileName)) {
                                    references.push(nodeEntry(decl.name));
                                }
                                break;
                            default:
                                // This may be merged with something.
                                ts.Debug.assert(!!(symbol.flags & 33554432 /* Transient */), "Expected a module symbol to be declared by a SourceFile or ModuleDeclaration.");
                        }
                    }
                }
                var exported = symbol.exports.get("export=" /* ExportEquals */);
                if (exported === null || exported === void 0 ? void 0 : exported.declarations) {
                    for (var _b = 0, _c = exported.declarations; _b < _c.length; _b++) {
                        var decl = _c[_b];
                        var sourceFile = decl.getSourceFile();
                        if (sourceFilesSet.has(sourceFile.fileName)) {
                            // At `module.exports = ...`, reference node is `module`
                            var node = ts.isBinaryExpression(decl) && ts.isPropertyAccessExpression(decl.left) ? decl.left.expression :
                                ts.isExportAssignment(decl) ? ts.Debug.checkDefined(ts.findChildOfKind(decl, 93 /* ExportKeyword */, sourceFile)) :
                                    ts.getNameOfDeclaration(decl) || decl;
                            references.push(nodeEntry(node));
                        }
                    }
                }
                return references.length ? [{ definition: { type: 0 /* Symbol */, symbol: symbol }, references: references }] : ts.emptyArray;
            }
            /** As in a `readonly prop: any` or `constructor(readonly prop: any)`, not a `readonly any[]`. */
            function isReadonlyTypeOperator(node) {
                return node.kind === 143 /* ReadonlyKeyword */
                    && ts.isTypeOperatorNode(node.parent)
                    && node.parent.operator === 143 /* ReadonlyKeyword */;
            }
            /** getReferencedSymbols for special node kinds. */
            function getReferencedSymbolsSpecial(node, sourceFiles, cancellationToken) {
                if (ts.isTypeKeyword(node.kind)) {
                    // A void expression (i.e., `void foo()`) is not special, but the `void` type is.
                    if (node.kind === 114 /* VoidKeyword */ && ts.isVoidExpression(node.parent)) {
                        return undefined;
                    }
                    // A modifier readonly (like on a property declaration) is not special;
                    // a readonly type keyword (like `readonly string[]`) is.
                    if (node.kind === 143 /* ReadonlyKeyword */ && !isReadonlyTypeOperator(node)) {
                        return undefined;
                    }
                    // Likewise, when we *are* looking for a special keyword, make sure we
                    // *don’t* include readonly member modifiers.
                    return getAllReferencesForKeyword(sourceFiles, node.kind, cancellationToken, node.kind === 143 /* ReadonlyKeyword */ ? isReadonlyTypeOperator : undefined);
                }
                if (ts.isStaticModifier(node) && ts.isClassStaticBlockDeclaration(node.parent)) {
                    return [{ definition: { type: 2 /* Keyword */, node: node }, references: [nodeEntry(node)] }];
                }
                // Labels
                if (ts.isJumpStatementTarget(node)) {
                    var labelDefinition = ts.getTargetLabel(node.parent, node.text);
                    // if we have a label definition, look within its statement for references, if not, then
                    // the label is undefined and we have no results..
                    return labelDefinition && getLabelReferencesInNode(labelDefinition.parent, labelDefinition);
                }
                else if (ts.isLabelOfLabeledStatement(node)) {
                    // it is a label definition and not a target, search within the parent labeledStatement
                    return getLabelReferencesInNode(node.parent, node);
                }
                if (ts.isThis(node)) {
                    return getReferencesForThisKeyword(node, sourceFiles, cancellationToken);
                }
                if (node.kind === 106 /* SuperKeyword */) {
                    return getReferencesForSuperKeyword(node);
                }
                return undefined;
            }
            /** Core find-all-references algorithm for a normal symbol. */
            function getReferencedSymbolsForSymbol(originalSymbol, node, sourceFiles, sourceFilesSet, checker, cancellationToken, options) {
                var symbol = node && skipPastExportOrImportSpecifierOrUnion(originalSymbol, node, checker, /*useLocalSymbolForExportSpecifier*/ !isForRenameWithPrefixAndSuffixText(options)) || originalSymbol;
                // Compute the meaning from the location and the symbol it references
                var searchMeaning = node ? getIntersectingMeaningFromDeclarations(node, symbol) : 7 /* All */;
                var result = [];
                var state = new State(sourceFiles, sourceFilesSet, node ? getSpecialSearchKind(node) : 0 /* None */, checker, cancellationToken, searchMeaning, options, result);
                var exportSpecifier = !isForRenameWithPrefixAndSuffixText(options) || !symbol.declarations ? undefined : ts.find(symbol.declarations, ts.isExportSpecifier);
                if (exportSpecifier) {
                    // When renaming at an export specifier, rename the export and not the thing being exported.
                    getReferencesAtExportSpecifier(exportSpecifier.name, symbol, exportSpecifier, state.createSearch(node, originalSymbol, /*comingFrom*/ undefined), state, /*addReferencesHere*/ true, /*alwaysGetReferences*/ true);
                }
                else if (node && node.kind === 88 /* DefaultKeyword */ && symbol.escapedName === "default" /* Default */ && symbol.parent) {
                    addReference(node, symbol, state);
                    searchForImportsOfExport(node, symbol, { exportingModuleSymbol: symbol.parent, exportKind: 1 /* Default */ }, state);
                }
                else {
                    var search = state.createSearch(node, symbol, /*comingFrom*/ undefined, { allSearchSymbols: node ? populateSearchSymbolSet(symbol, node, checker, options.use === 2 /* Rename */, !!options.providePrefixAndSuffixTextForRename, !!options.implementations) : [symbol] });
                    getReferencesInContainerOrFiles(symbol, state, search);
                }
                return result;
            }
            function getReferencesInContainerOrFiles(symbol, state, search) {
                // Try to get the smallest valid scope that we can limit our search to;
                // otherwise we'll need to search globally (i.e. include each file).
                var scope = getSymbolScope(symbol);
                if (scope) {
                    getReferencesInContainer(scope, scope.getSourceFile(), search, state, /*addReferencesHere*/ !(ts.isSourceFile(scope) && !ts.contains(state.sourceFiles, scope)));
                }
                else {
                    // Global search
                    for (var _i = 0, _a = state.sourceFiles; _i < _a.length; _i++) {
                        var sourceFile = _a[_i];
                        state.cancellationToken.throwIfCancellationRequested();
                        searchForName(sourceFile, search, state);
                    }
                }
            }
            function getSpecialSearchKind(node) {
                switch (node.kind) {
                    case 169 /* Constructor */:
                    case 133 /* ConstructorKeyword */:
                        return 1 /* Constructor */;
                    case 79 /* Identifier */:
                        if (ts.isClassLike(node.parent)) {
                            ts.Debug.assert(node.parent.name === node);
                            return 2 /* Class */;
                        }
                    // falls through
                    default:
                        return 0 /* None */;
                }
            }
            /** Handle a few special cases relating to export/import specifiers. */
            function skipPastExportOrImportSpecifierOrUnion(symbol, node, checker, useLocalSymbolForExportSpecifier) {
                var parent = node.parent;
                if (ts.isExportSpecifier(parent) && useLocalSymbolForExportSpecifier) {
                    return getLocalSymbolForExportSpecifier(node, symbol, parent, checker);
                }
                // If the symbol is declared as part of a declaration like `{ type: "a" } | { type: "b" }`, use the property on the union type to get more references.
                return ts.firstDefined(symbol.declarations, function (decl) {
                    if (!decl.parent) {
                        // Ignore UMD module and global merge
                        if (symbol.flags & 33554432 /* Transient */)
                            return undefined;
                        // Assertions for GH#21814. We should be handling SourceFile symbols in `getReferencedSymbolsForModule` instead of getting here.
                        ts.Debug.fail("Unexpected symbol at " + ts.Debug.formatSyntaxKind(node.kind) + ": " + ts.Debug.formatSymbol(symbol));
                    }
                    return ts.isTypeLiteralNode(decl.parent) && ts.isUnionTypeNode(decl.parent.parent)
                        ? checker.getPropertyOfType(checker.getTypeFromTypeNode(decl.parent.parent), symbol.name)
                        : undefined;
                });
            }
            var SpecialSearchKind;
            (function (SpecialSearchKind) {
                SpecialSearchKind[SpecialSearchKind["None"] = 0] = "None";
                SpecialSearchKind[SpecialSearchKind["Constructor"] = 1] = "Constructor";
                SpecialSearchKind[SpecialSearchKind["Class"] = 2] = "Class";
            })(SpecialSearchKind || (SpecialSearchKind = {}));
            function getNonModuleSymbolOfMergedModuleSymbol(symbol) {
                if (!(symbol.flags & (1536 /* Module */ | 33554432 /* Transient */)))
                    return undefined;
                var decl = symbol.declarations && ts.find(symbol.declarations, function (d) { return !ts.isSourceFile(d) && !ts.isModuleDeclaration(d); });
                return decl && decl.symbol;
            }
            /**
             * Holds all state needed for the finding references.
             * Unlike `Search`, there is only one `State`.
             */
            var State = /** @class */ (function () {
                function State(sourceFiles, sourceFilesSet, specialSearchKind, checker, cancellationToken, searchMeaning, options, result) {
                    this.sourceFiles = sourceFiles;
                    this.sourceFilesSet = sourceFilesSet;
                    this.specialSearchKind = specialSearchKind;
                    this.checker = checker;
                    this.cancellationToken = cancellationToken;
                    this.searchMeaning = searchMeaning;
                    this.options = options;
                    this.result = result;
                    /** Cache for `explicitlyinheritsFrom`. */
                    this.inheritsFromCache = new ts.Map();
                    /**
                     * Type nodes can contain multiple references to the same type. For example:
                     *      let x: Foo & (Foo & Bar) = ...
                     * Because we are returning the implementation locations and not the identifier locations,
                     * duplicate entries would be returned here as each of the type references is part of
                     * the same implementation. For that reason, check before we add a new entry.
                     */
                    this.markSeenContainingTypeReference = ts.nodeSeenTracker();
                    /**
                     * It's possible that we will encounter the right side of `export { foo as bar } from "x";` more than once.
                     * For example:
                     *     // b.ts
                     *     export { foo as bar } from "./a";
                     *     import { bar } from "./b";
                     *
                     * Normally at `foo as bar` we directly add `foo` and do not locally search for it (since it doesn't declare a local).
                     * But another reference to it may appear in the same source file.
                     * See `tests/cases/fourslash/transitiveExportImports3.ts`.
                     */
                    this.markSeenReExportRHS = ts.nodeSeenTracker();
                    this.symbolIdToReferences = [];
                    // Source file ID → symbol ID → Whether the symbol has been searched for in the source file.
                    this.sourceFileToSeenSymbols = [];
                }
                State.prototype.includesSourceFile = function (sourceFile) {
                    return this.sourceFilesSet.has(sourceFile.fileName);
                };
                /** Gets every place to look for references of an exported symbols. See `ImportsResult` in `importTracker.ts` for more documentation. */
                State.prototype.getImportSearches = function (exportSymbol, exportInfo) {
                    if (!this.importTracker)
                        this.importTracker = FindAllReferences.createImportTracker(this.sourceFiles, this.sourceFilesSet, this.checker, this.cancellationToken);
                    return this.importTracker(exportSymbol, exportInfo, this.options.use === 2 /* Rename */);
                };
                /** @param allSearchSymbols set of additional symbols for use by `includes`. */
                State.prototype.createSearch = function (location, symbol, comingFrom, searchOptions) {
                    if (searchOptions === void 0) { searchOptions = {}; }
                    // Note: if this is an external module symbol, the name doesn't include quotes.
                    // Note: getLocalSymbolForExportDefault handles `export default class C {}`, but not `export default C` or `export { C as default }`.
                    // The other two forms seem to be handled downstream (e.g. in `skipPastExportOrImportSpecifier`), so special-casing the first form
                    // here appears to be intentional).
                    var _a = searchOptions.text, text = _a === void 0 ? ts.stripQuotes(ts.symbolName(ts.getLocalSymbolForExportDefault(symbol) || getNonModuleSymbolOfMergedModuleSymbol(symbol) || symbol)) : _a, _b = searchOptions.allSearchSymbols, allSearchSymbols = _b === void 0 ? [symbol] : _b;
                    var escapedText = ts.escapeLeadingUnderscores(text);
                    var parents = this.options.implementations && location ? getParentSymbolsOfPropertyAccess(location, symbol, this.checker) : undefined;
                    return { symbol: symbol, comingFrom: comingFrom, text: text, escapedText: escapedText, parents: parents, allSearchSymbols: allSearchSymbols, includes: function (sym) { return ts.contains(allSearchSymbols, sym); } };
                };
                /**
                 * Callback to add references for a particular searched symbol.
                 * This initializes a reference group, so only call this if you will add at least one reference.
                 */
                State.prototype.referenceAdder = function (searchSymbol) {
                    var symbolId = ts.getSymbolId(searchSymbol);
                    var references = this.symbolIdToReferences[symbolId];
                    if (!references) {
                        references = this.symbolIdToReferences[symbolId] = [];
                        this.result.push({ definition: { type: 0 /* Symbol */, symbol: searchSymbol }, references: references });
                    }
                    return function (node, kind) { return references.push(nodeEntry(node, kind)); };
                };
                /** Add a reference with no associated definition. */
                State.prototype.addStringOrCommentReference = function (fileName, textSpan) {
                    this.result.push({
                        definition: undefined,
                        references: [{ kind: 0 /* Span */, fileName: fileName, textSpan: textSpan }]
                    });
                };
                /** Returns `true` the first time we search for a symbol in a file and `false` afterwards. */
                State.prototype.markSearchedSymbols = function (sourceFile, symbols) {
                    var sourceId = ts.getNodeId(sourceFile);
                    var seenSymbols = this.sourceFileToSeenSymbols[sourceId] || (this.sourceFileToSeenSymbols[sourceId] = new ts.Set());
                    var anyNewSymbols = false;
                    for (var _i = 0, symbols_2 = symbols; _i < symbols_2.length; _i++) {
                        var sym = symbols_2[_i];
                        anyNewSymbols = ts.tryAddToSet(seenSymbols, ts.getSymbolId(sym)) || anyNewSymbols;
                    }
                    return anyNewSymbols;
                };
                return State;
            }());
            /** Search for all imports of a given exported symbol using `State.getImportSearches`. */
            function searchForImportsOfExport(exportLocation, exportSymbol, exportInfo, state) {
                var _a = state.getImportSearches(exportSymbol, exportInfo), importSearches = _a.importSearches, singleReferences = _a.singleReferences, indirectUsers = _a.indirectUsers;
                // For `import { foo as bar }` just add the reference to `foo`, and don't otherwise search in the file.
                if (singleReferences.length) {
                    var addRef = state.referenceAdder(exportSymbol);
                    for (var _i = 0, singleReferences_1 = singleReferences; _i < singleReferences_1.length; _i++) {
                        var singleRef = singleReferences_1[_i];
                        if (shouldAddSingleReference(singleRef, state))
                            addRef(singleRef);
                    }
                }
                // For each import, find all references to that import in its source file.
                for (var _b = 0, importSearches_1 = importSearches; _b < importSearches_1.length; _b++) {
                    var _c = importSearches_1[_b], importLocation = _c[0], importSymbol = _c[1];
                    getReferencesInSourceFile(importLocation.getSourceFile(), state.createSearch(importLocation, importSymbol, 1 /* Export */), state);
                }
                if (indirectUsers.length) {
                    var indirectSearch = void 0;
                    switch (exportInfo.exportKind) {
                        case 0 /* Named */:
                            indirectSearch = state.createSearch(exportLocation, exportSymbol, 1 /* Export */);
                            break;
                        case 1 /* Default */:
                            // Search for a property access to '.default'. This can't be renamed.
                            indirectSearch = state.options.use === 2 /* Rename */ ? undefined : state.createSearch(exportLocation, exportSymbol, 1 /* Export */, { text: "default" });
                            break;
                        case 2 /* ExportEquals */:
                            break;
                    }
                    if (indirectSearch) {
                        for (var _d = 0, indirectUsers_1 = indirectUsers; _d < indirectUsers_1.length; _d++) {
                            var indirectUser = indirectUsers_1[_d];
                            searchForName(indirectUser, indirectSearch, state);
                        }
                    }
                }
            }
            function eachExportReference(sourceFiles, checker, cancellationToken, exportSymbol, exportingModuleSymbol, exportName, isDefaultExport, cb) {
                var importTracker = FindAllReferences.createImportTracker(sourceFiles, new ts.Set(sourceFiles.map(function (f) { return f.fileName; })), checker, cancellationToken);
                var _a = importTracker(exportSymbol, { exportKind: isDefaultExport ? 1 /* Default */ : 0 /* Named */, exportingModuleSymbol: exportingModuleSymbol }, /*isForRename*/ false), importSearches = _a.importSearches, indirectUsers = _a.indirectUsers;
                for (var _i = 0, importSearches_2 = importSearches; _i < importSearches_2.length; _i++) {
                    var importLocation = importSearches_2[_i][0];
                    cb(importLocation);
                }
                for (var _b = 0, indirectUsers_2 = indirectUsers; _b < indirectUsers_2.length; _b++) {
                    var indirectUser = indirectUsers_2[_b];
                    for (var _c = 0, _d = getPossibleSymbolReferenceNodes(indirectUser, isDefaultExport ? "default" : exportName); _c < _d.length; _c++) {
                        var node = _d[_c];
                        // Import specifiers should be handled by importSearches
                        var symbol = checker.getSymbolAtLocation(node);
                        var hasExportAssignmentDeclaration = ts.some(symbol === null || symbol === void 0 ? void 0 : symbol.declarations, function (d) { return ts.tryCast(d, ts.isExportAssignment) ? true : false; });
                        if (ts.isIdentifier(node) && !ts.isImportOrExportSpecifier(node.parent) && (symbol === exportSymbol || hasExportAssignmentDeclaration)) {
                            cb(node);
                        }
                    }
                }
            }
            Core.eachExportReference = eachExportReference;
            function shouldAddSingleReference(singleRef, state) {
                if (!hasMatchingMeaning(singleRef, state))
                    return false;
                if (state.options.use !== 2 /* Rename */)
                    return true;
                // Don't rename an import type `import("./module-name")` when renaming `name` in `export = name;`
                if (!ts.isIdentifier(singleRef))
                    return false;
                // At `default` in `import { default as x }` or `export { default as x }`, do add a reference, but do not rename.
                return !(ts.isImportOrExportSpecifier(singleRef.parent) && singleRef.escapedText === "default" /* Default */);
            }
            // Go to the symbol we imported from and find references for it.
            function searchForImportedSymbol(symbol, state) {
                if (!symbol.declarations)
                    return;
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    var exportingFile = declaration.getSourceFile();
                    // Need to search in the file even if it's not in the search-file set, because it might export the symbol.
                    getReferencesInSourceFile(exportingFile, state.createSearch(declaration, symbol, 0 /* Import */), state, state.includesSourceFile(exportingFile));
                }
            }
            /** Search for all occurences of an identifier in a source file (and filter out the ones that match). */
            function searchForName(sourceFile, search, state) {
                if (ts.getNameTable(sourceFile).get(search.escapedText) !== undefined) {
                    getReferencesInSourceFile(sourceFile, search, state);
                }
            }
            function getPropertySymbolOfDestructuringAssignment(location, checker) {
                return ts.isArrayLiteralOrObjectLiteralDestructuringPattern(location.parent.parent)
                    ? checker.getPropertySymbolOfDestructuringAssignment(location)
                    : undefined;
            }
            /**
             * Determines the smallest scope in which a symbol may have named references.
             * Note that not every construct has been accounted for. This function can
             * probably be improved.
             *
             * @returns undefined if the scope cannot be determined, implying that
             * a reference to a symbol can occur anywhere.
             */
            function getSymbolScope(symbol) {
                // If this is the symbol of a named function expression or named class expression,
                // then named references are limited to its own scope.
                var declarations = symbol.declarations, flags = symbol.flags, parent = symbol.parent, valueDeclaration = symbol.valueDeclaration;
                if (valueDeclaration && (valueDeclaration.kind === 211 /* FunctionExpression */ || valueDeclaration.kind === 224 /* ClassExpression */)) {
                    return valueDeclaration;
                }
                if (!declarations) {
                    return undefined;
                }
                // If this is private property or method, the scope is the containing class
                if (flags & (4 /* Property */ | 8192 /* Method */)) {
                    var privateDeclaration = ts.find(declarations, function (d) { return ts.hasEffectiveModifier(d, 8 /* Private */) || ts.isPrivateIdentifierClassElementDeclaration(d); });
                    if (privateDeclaration) {
                        return ts.getAncestor(privateDeclaration, 255 /* ClassDeclaration */);
                    }
                    // Else this is a public property and could be accessed from anywhere.
                    return undefined;
                }
                // If symbol is of object binding pattern element without property name we would want to
                // look for property too and that could be anywhere
                if (declarations.some(ts.isObjectBindingElementWithoutPropertyName)) {
                    return undefined;
                }
                /*
                If the symbol has a parent, it's globally visible unless:
                - It's a private property (handled above).
                - It's a type parameter.
                - The parent is an external module: then we should only search in the module (and recurse on the export later).
                - But if the parent has `export as namespace`, the symbol is globally visible through that namespace.
                */
                var exposedByParent = parent && !(symbol.flags & 262144 /* TypeParameter */);
                if (exposedByParent && !(ts.isExternalModuleSymbol(parent) && !parent.globalExports)) {
                    return undefined;
                }
                var scope;
                for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
                    var declaration = declarations_1[_i];
                    var container = ts.getContainerNode(declaration);
                    if (scope && scope !== container) {
                        // Different declarations have different containers, bail out
                        return undefined;
                    }
                    if (!container || container.kind === 300 /* SourceFile */ && !ts.isExternalOrCommonJsModule(container)) {
                        // This is a global variable and not an external module, any declaration defined
                        // within this scope is visible outside the file
                        return undefined;
                    }
                    scope = container;
                    if (ts.isFunctionExpression(scope)) {
                        var next = void 0;
                        while (next = ts.getNextJSDocCommentLocation(scope)) {
                            scope = next;
                        }
                    }
                }
                // If symbol.parent, this means we are in an export of an external module. (Otherwise we would have returned `undefined` above.)
                // For an export of a module, we may be in a declaration file, and it may be accessed elsewhere. E.g.:
                //     declare module "a" { export type T = number; }
                //     declare module "b" { import { T } from "a"; export const x: T; }
                // So we must search the whole source file. (Because we will mark the source file as seen, we we won't return to it when searching for imports.)
                return exposedByParent ? scope.getSourceFile() : scope; // TODO: GH#18217
            }
            /** Used as a quick check for whether a symbol is used at all in a file (besides its definition). */
            function isSymbolReferencedInFile(definition, checker, sourceFile, searchContainer) {
                if (searchContainer === void 0) { searchContainer = sourceFile; }
                return eachSymbolReferenceInFile(definition, checker, sourceFile, function () { return true; }, searchContainer) || false;
            }
            Core.isSymbolReferencedInFile = isSymbolReferencedInFile;
            function eachSymbolReferenceInFile(definition, checker, sourceFile, cb, searchContainer) {
                if (searchContainer === void 0) { searchContainer = sourceFile; }
                var symbol = ts.isParameterPropertyDeclaration(definition.parent, definition.parent.parent)
                    ? ts.first(checker.getSymbolsOfParameterPropertyDeclaration(definition.parent, definition.text))
                    : checker.getSymbolAtLocation(definition);
                if (!symbol)
                    return undefined;
                for (var _i = 0, _a = getPossibleSymbolReferenceNodes(sourceFile, symbol.name, searchContainer); _i < _a.length; _i++) {
                    var token = _a[_i];
                    if (!ts.isIdentifier(token) || token === definition || token.escapedText !== definition.escapedText)
                        continue;
                    var referenceSymbol = checker.getSymbolAtLocation(token); // See GH#19955 for why the type annotation is necessary
                    if (referenceSymbol === symbol
                        || checker.getShorthandAssignmentValueSymbol(token.parent) === symbol
                        || ts.isExportSpecifier(token.parent) && getLocalSymbolForExportSpecifier(token, referenceSymbol, token.parent, checker) === symbol) {
                        var res = cb(token);
                        if (res)
                            return res;
                    }
                }
            }
            Core.eachSymbolReferenceInFile = eachSymbolReferenceInFile;
            function someSignatureUsage(signature, sourceFiles, checker, cb) {
                if (!signature.name || !ts.isIdentifier(signature.name))
                    return false;
                var symbol = ts.Debug.checkDefined(checker.getSymbolAtLocation(signature.name));
                for (var _i = 0, sourceFiles_3 = sourceFiles; _i < sourceFiles_3.length; _i++) {
                    var sourceFile = sourceFiles_3[_i];
                    for (var _a = 0, _b = getPossibleSymbolReferenceNodes(sourceFile, symbol.name); _a < _b.length; _a++) {
                        var name = _b[_a];
                        if (!ts.isIdentifier(name) || name === signature.name || name.escapedText !== signature.name.escapedText)
                            continue;
                        var called = ts.climbPastPropertyAccess(name);
                        var call = ts.isCallExpression(called.parent) && called.parent.expression === called ? called.parent : undefined;
                        var referenceSymbol = checker.getSymbolAtLocation(name);
                        if (referenceSymbol && checker.getRootSymbols(referenceSymbol).some(function (s) { return s === symbol; })) {
                            if (cb(name, call)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            Core.someSignatureUsage = someSignatureUsage;
            function getPossibleSymbolReferenceNodes(sourceFile, symbolName, container) {
                if (container === void 0) { container = sourceFile; }
                return getPossibleSymbolReferencePositions(sourceFile, symbolName, container).map(function (pos) { return ts.getTouchingPropertyName(sourceFile, pos); });
            }
            function getPossibleSymbolReferencePositions(sourceFile, symbolName, container) {
                if (container === void 0) { container = sourceFile; }
                var positions = [];
                /// TODO: Cache symbol existence for files to save text search
                // Also, need to make this work for unicode escapes.
                // Be resilient in the face of a symbol with no name or zero length name
                if (!symbolName || !symbolName.length) {
                    return positions;
                }
                var text = sourceFile.text;
                var sourceLength = text.length;
                var symbolNameLength = symbolName.length;
                var position = text.indexOf(symbolName, container.pos);
                while (position >= 0) {
                    // If we are past the end, stop looking
                    if (position > container.end)
                        break;
                    // We found a match.  Make sure it's not part of a larger word (i.e. the char
                    // before and after it have to be a non-identifier char).
                    var endPosition = position + symbolNameLength;
                    if ((position === 0 || !ts.isIdentifierPart(text.charCodeAt(position - 1), 99 /* Latest */)) &&
                        (endPosition === sourceLength || !ts.isIdentifierPart(text.charCodeAt(endPosition), 99 /* Latest */))) {
                        // Found a real match.  Keep searching.
                        positions.push(position);
                    }
                    position = text.indexOf(symbolName, position + symbolNameLength + 1);
                }
                return positions;
            }
            function getLabelReferencesInNode(container, targetLabel) {
                var sourceFile = container.getSourceFile();
                var labelName = targetLabel.text;
                var references = ts.mapDefined(getPossibleSymbolReferenceNodes(sourceFile, labelName, container), function (node) {
                    // Only pick labels that are either the target label, or have a target that is the target label
                    return node === targetLabel || (ts.isJumpStatementTarget(node) && ts.getTargetLabel(node, labelName) === targetLabel) ? nodeEntry(node) : undefined;
                });
                return [{ definition: { type: 1 /* Label */, node: targetLabel }, references: references }];
            }
            function isValidReferencePosition(node, searchSymbolName) {
                // Compare the length so we filter out strict superstrings of the symbol we are looking for
                switch (node.kind) {
                    case 80 /* PrivateIdentifier */:
                        if (ts.isJSDocMemberName(node.parent)) {
                            return true;
                        }
                    // falls through I guess
                    case 79 /* Identifier */:
                        return node.text.length === searchSymbolName.length;
                    case 14 /* NoSubstitutionTemplateLiteral */:
                    case 10 /* StringLiteral */: {
                        var str = node;
                        return (ts.isLiteralNameOfPropertyDeclarationOrIndexAccess(str) || ts.isNameOfModuleDeclaration(node) || ts.isExpressionOfExternalModuleImportEqualsDeclaration(node) || (ts.isCallExpression(node.parent) && ts.isBindableObjectDefinePropertyCall(node.parent) && node.parent.arguments[1] === node)) &&
                            str.text.length === searchSymbolName.length;
                    }
                    case 8 /* NumericLiteral */:
                        return ts.isLiteralNameOfPropertyDeclarationOrIndexAccess(node) && node.text.length === searchSymbolName.length;
                    case 88 /* DefaultKeyword */:
                        return "default".length === searchSymbolName.length;
                    default:
                        return false;
                }
            }
            function getAllReferencesForKeyword(sourceFiles, keywordKind, cancellationToken, filter) {
                var references = ts.flatMap(sourceFiles, function (sourceFile) {
                    cancellationToken.throwIfCancellationRequested();
                    return ts.mapDefined(getPossibleSymbolReferenceNodes(sourceFile, ts.tokenToString(keywordKind), sourceFile), function (referenceLocation) {
                        if (referenceLocation.kind === keywordKind && (!filter || filter(referenceLocation))) {
                            return nodeEntry(referenceLocation);
                        }
                    });
                });
                return references.length ? [{ definition: { type: 2 /* Keyword */, node: references[0].node }, references: references }] : undefined;
            }
            function getReferencesInSourceFile(sourceFile, search, state, addReferencesHere) {
                if (addReferencesHere === void 0) { addReferencesHere = true; }
                state.cancellationToken.throwIfCancellationRequested();
                return getReferencesInContainer(sourceFile, sourceFile, search, state, addReferencesHere);
            }
            /**
             * Search within node "container" for references for a search value, where the search value is defined as a
             * tuple of(searchSymbol, searchText, searchLocation, and searchMeaning).
             * searchLocation: a node where the search value
             */
            function getReferencesInContainer(container, sourceFile, search, state, addReferencesHere) {
                if (!state.markSearchedSymbols(sourceFile, search.allSearchSymbols)) {
                    return;
                }
                for (var _i = 0, _a = getPossibleSymbolReferencePositions(sourceFile, search.text, container); _i < _a.length; _i++) {
                    var position = _a[_i];
                    getReferencesAtLocation(sourceFile, position, search, state, addReferencesHere);
                }
            }
            function hasMatchingMeaning(referenceLocation, state) {
                return !!(ts.getMeaningFromLocation(referenceLocation) & state.searchMeaning);
            }
            function getReferencesAtLocation(sourceFile, position, search, state, addReferencesHere) {
                var referenceLocation = ts.getTouchingPropertyName(sourceFile, position);
                if (!isValidReferencePosition(referenceLocation, search.text)) {
                    // This wasn't the start of a token.  Check to see if it might be a
                    // match in a comment or string if that's what the caller is asking
                    // for.
                    if (!state.options.implementations && (state.options.findInStrings && ts.isInString(sourceFile, position) || state.options.findInComments && ts.isInNonReferenceComment(sourceFile, position))) {
                        // In the case where we're looking inside comments/strings, we don't have
                        // an actual definition.  So just use 'undefined' here.  Features like
                        // 'Rename' won't care (as they ignore the definitions), and features like
                        // 'FindReferences' will just filter out these results.
                        state.addStringOrCommentReference(sourceFile.fileName, ts.createTextSpan(position, search.text.length));
                    }
                    return;
                }
                if (!hasMatchingMeaning(referenceLocation, state))
                    return;
                var referenceSymbol = state.checker.getSymbolAtLocation(referenceLocation);
                if (!referenceSymbol) {
                    return;
                }
                var parent = referenceLocation.parent;
                if (ts.isImportSpecifier(parent) && parent.propertyName === referenceLocation) {
                    // This is added through `singleReferences` in ImportsResult. If we happen to see it again, don't add it again.
                    return;
                }
                if (ts.isExportSpecifier(parent)) {
                    ts.Debug.assert(referenceLocation.kind === 79 /* Identifier */);
                    getReferencesAtExportSpecifier(referenceLocation, referenceSymbol, parent, search, state, addReferencesHere);
                    return;
                }
                var relatedSymbol = getRelatedSymbol(search, referenceSymbol, referenceLocation, state);
                if (!relatedSymbol) {
                    getReferenceForShorthandProperty(referenceSymbol, search, state);
                    return;
                }
                switch (state.specialSearchKind) {
                    case 0 /* None */:
                        if (addReferencesHere)
                            addReference(referenceLocation, relatedSymbol, state);
                        break;
                    case 1 /* Constructor */:
                        addConstructorReferences(referenceLocation, sourceFile, search, state);
                        break;
                    case 2 /* Class */:
                        addClassStaticThisReferences(referenceLocation, search, state);
                        break;
                    default:
                        ts.Debug.assertNever(state.specialSearchKind);
                }
                // Use the parent symbol if the location is commonjs require syntax on javascript files only.
                referenceSymbol = ts.isInJSFile(referenceLocation) && referenceLocation.parent.kind === 201 /* BindingElement */ && ts.isRequireVariableDeclaration(referenceLocation.parent)
                    ? referenceLocation.parent.symbol
                    : referenceSymbol;
                getImportOrExportReferences(referenceLocation, referenceSymbol, search, state);
            }
            function getReferencesAtExportSpecifier(referenceLocation, referenceSymbol, exportSpecifier, search, state, addReferencesHere, alwaysGetReferences) {
                ts.Debug.assert(!alwaysGetReferences || !!state.options.providePrefixAndSuffixTextForRename, "If alwaysGetReferences is true, then prefix/suffix text must be enabled");
                var parent = exportSpecifier.parent, propertyName = exportSpecifier.propertyName, name = exportSpecifier.name;
                var exportDeclaration = parent.parent;
                var localSymbol = getLocalSymbolForExportSpecifier(referenceLocation, referenceSymbol, exportSpecifier, state.checker);
                if (!alwaysGetReferences && !search.includes(localSymbol)) {
                    return;
                }
                if (!propertyName) {
                    // Don't rename at `export { default } from "m";`. (but do continue to search for imports of the re-export)
                    if (!(state.options.use === 2 /* Rename */ && (name.escapedText === "default" /* Default */))) {
                        addRef();
                    }
                }
                else if (referenceLocation === propertyName) {
                    // For `export { foo as bar } from "baz"`, "`foo`" will be added from the singleReferences for import searches of the original export.
                    // For `export { foo as bar };`, where `foo` is a local, so add it now.
                    if (!exportDeclaration.moduleSpecifier) {
                        addRef();
                    }
                    if (addReferencesHere && state.options.use !== 2 /* Rename */ && state.markSeenReExportRHS(name)) {
                        addReference(name, ts.Debug.checkDefined(exportSpecifier.symbol), state);
                    }
                }
                else {
                    if (state.markSeenReExportRHS(referenceLocation)) {
                        addRef();
                    }
                }
                // For `export { foo as bar }`, rename `foo`, but not `bar`.
                if (!isForRenameWithPrefixAndSuffixText(state.options) || alwaysGetReferences) {
                    var isDefaultExport = referenceLocation.originalKeywordKind === 88 /* DefaultKeyword */
                        || exportSpecifier.name.originalKeywordKind === 88 /* DefaultKeyword */;
                    var exportKind = isDefaultExport ? 1 /* Default */ : 0 /* Named */;
                    var exportSymbol = ts.Debug.checkDefined(exportSpecifier.symbol);
                    var exportInfo = FindAllReferences.getExportInfo(exportSymbol, exportKind, state.checker);
                    if (exportInfo) {
                        searchForImportsOfExport(referenceLocation, exportSymbol, exportInfo, state);
                    }
                }
                // At `export { x } from "foo"`, also search for the imported symbol `"foo".x`.
                if (search.comingFrom !== 1 /* Export */ && exportDeclaration.moduleSpecifier && !propertyName && !isForRenameWithPrefixAndSuffixText(state.options)) {
                    var imported = state.checker.getExportSpecifierLocalTargetSymbol(exportSpecifier);
                    if (imported)
                        searchForImportedSymbol(imported, state);
                }
                function addRef() {
                    if (addReferencesHere)
                        addReference(referenceLocation, localSymbol, state);
                }
            }
            function getLocalSymbolForExportSpecifier(referenceLocation, referenceSymbol, exportSpecifier, checker) {
                return isExportSpecifierAlias(referenceLocation, exportSpecifier) && checker.getExportSpecifierLocalTargetSymbol(exportSpecifier) || referenceSymbol;
            }
            function isExportSpecifierAlias(referenceLocation, exportSpecifier) {
                var parent = exportSpecifier.parent, propertyName = exportSpecifier.propertyName, name = exportSpecifier.name;
                ts.Debug.assert(propertyName === referenceLocation || name === referenceLocation);
                if (propertyName) {
                    // Given `export { foo as bar } [from "someModule"]`: It's an alias at `foo`, but at `bar` it's a new symbol.
                    return propertyName === referenceLocation;
                }
                else {
                    // `export { foo } from "foo"` is a re-export.
                    // `export { foo };` is not a re-export, it creates an alias for the local variable `foo`.
                    return !parent.parent.moduleSpecifier;
                }
            }
            function getImportOrExportReferences(referenceLocation, referenceSymbol, search, state) {
                var importOrExport = FindAllReferences.getImportOrExportSymbol(referenceLocation, referenceSymbol, state.checker, search.comingFrom === 1 /* Export */);
                if (!importOrExport)
                    return;
                var symbol = importOrExport.symbol;
                if (importOrExport.kind === 0 /* Import */) {
                    if (!(isForRenameWithPrefixAndSuffixText(state.options))) {
                        searchForImportedSymbol(symbol, state);
                    }
                }
                else {
                    searchForImportsOfExport(referenceLocation, symbol, importOrExport.exportInfo, state);
                }
            }
            function getReferenceForShorthandProperty(_a, search, state) {
                var flags = _a.flags, valueDeclaration = _a.valueDeclaration;
                var shorthandValueSymbol = state.checker.getShorthandAssignmentValueSymbol(valueDeclaration);
                var name = valueDeclaration && ts.getNameOfDeclaration(valueDeclaration);
                /*
                * Because in short-hand property assignment, an identifier which stored as name of the short-hand property assignment
                * has two meanings: property name and property value. Therefore when we do findAllReference at the position where
                * an identifier is declared, the language service should return the position of the variable declaration as well as
                * the position in short-hand property assignment excluding property accessing. However, if we do findAllReference at the
                * position of property accessing, the referenceEntry of such position will be handled in the first case.
                */
                if (!(flags & 33554432 /* Transient */) && name && search.includes(shorthandValueSymbol)) {
                    addReference(name, shorthandValueSymbol, state);
                }
            }
            function addReference(referenceLocation, relatedSymbol, state) {
                var _a = "kind" in relatedSymbol ? relatedSymbol : { kind: undefined, symbol: relatedSymbol }, kind = _a.kind, symbol = _a.symbol; // eslint-disable-line no-in-operator
                var addRef = state.referenceAdder(symbol);
                if (state.options.implementations) {
                    addImplementationReferences(referenceLocation, addRef, state);
                }
                else {
                    addRef(referenceLocation, kind);
                }
            }
            /** Adds references when a constructor is used with `new this()` in its own class and `super()` calls in subclasses.  */
            function addConstructorReferences(referenceLocation, sourceFile, search, state) {
                if (ts.isNewExpressionTarget(referenceLocation)) {
                    addReference(referenceLocation, search.symbol, state);
                }
                var pusher = function () { return state.referenceAdder(search.symbol); };
                if (ts.isClassLike(referenceLocation.parent)) {
                    ts.Debug.assert(referenceLocation.kind === 88 /* DefaultKeyword */ || referenceLocation.parent.name === referenceLocation);
                    // This is the class declaration containing the constructor.
                    findOwnConstructorReferences(search.symbol, sourceFile, pusher());
                }
                else {
                    // If this class appears in `extends C`, then the extending class' "super" calls are references.
                    var classExtending = tryGetClassByExtendingIdentifier(referenceLocation);
                    if (classExtending) {
                        findSuperConstructorAccesses(classExtending, pusher());
                        findInheritedConstructorReferences(classExtending, state);
                    }
                }
            }
            function addClassStaticThisReferences(referenceLocation, search, state) {
                addReference(referenceLocation, search.symbol, state);
                var classLike = referenceLocation.parent;
                if (state.options.use === 2 /* Rename */ || !ts.isClassLike(classLike))
                    return;
                ts.Debug.assert(classLike.name === referenceLocation);
                var addRef = state.referenceAdder(search.symbol);
                for (var _i = 0, _a = classLike.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (!(ts.isMethodOrAccessor(member) && ts.isStatic(member))) {
                        continue;
                    }
                    if (member.body) {
                        member.body.forEachChild(function cb(node) {
                            if (node.kind === 108 /* ThisKeyword */) {
                                addRef(node);
                            }
                            else if (!ts.isFunctionLike(node) && !ts.isClassLike(node)) {
                                node.forEachChild(cb);
                            }
                        });
                    }
                }
            }
            /**
             * `classSymbol` is the class where the constructor was defined.
             * Reference the constructor and all calls to `new this()`.
             */
            function findOwnConstructorReferences(classSymbol, sourceFile, addNode) {
                var constructorSymbol = getClassConstructorSymbol(classSymbol);
                if (constructorSymbol && constructorSymbol.declarations) {
                    for (var _i = 0, _a = constructorSymbol.declarations; _i < _a.length; _i++) {
                        var decl = _a[_i];
                        var ctrKeyword = ts.findChildOfKind(decl, 133 /* ConstructorKeyword */, sourceFile);
                        ts.Debug.assert(decl.kind === 169 /* Constructor */ && !!ctrKeyword);
                        addNode(ctrKeyword);
                    }
                }
                if (classSymbol.exports) {
                    classSymbol.exports.forEach(function (member) {
                        var decl = member.valueDeclaration;
                        if (decl && decl.kind === 167 /* MethodDeclaration */) {
                            var body = decl.body;
                            if (body) {
                                forEachDescendantOfKind(body, 108 /* ThisKeyword */, function (thisKeyword) {
                                    if (ts.isNewExpressionTarget(thisKeyword)) {
                                        addNode(thisKeyword);
                                    }
                                });
                            }
                        }
                    });
                }
            }
            function getClassConstructorSymbol(classSymbol) {
                return classSymbol.members && classSymbol.members.get("__constructor" /* Constructor */);
            }
            /** Find references to `super` in the constructor of an extending class.  */
            function findSuperConstructorAccesses(classDeclaration, addNode) {
                var constructor = getClassConstructorSymbol(classDeclaration.symbol);
                if (!(constructor && constructor.declarations)) {
                    return;
                }
                for (var _i = 0, _a = constructor.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    ts.Debug.assert(decl.kind === 169 /* Constructor */);
                    var body = decl.body;
                    if (body) {
                        forEachDescendantOfKind(body, 106 /* SuperKeyword */, function (node) {
                            if (ts.isCallExpressionTarget(node)) {
                                addNode(node);
                            }
                        });
                    }
                }
            }
            function hasOwnConstructor(classDeclaration) {
                return !!getClassConstructorSymbol(classDeclaration.symbol);
            }
            function findInheritedConstructorReferences(classDeclaration, state) {
                if (hasOwnConstructor(classDeclaration))
                    return;
                var classSymbol = classDeclaration.symbol;
                var search = state.createSearch(/*location*/ undefined, classSymbol, /*comingFrom*/ undefined);
                getReferencesInContainerOrFiles(classSymbol, state, search);
            }
            function addImplementationReferences(refNode, addReference, state) {
                // Check if we found a function/propertyAssignment/method with an implementation or initializer
                if (ts.isDeclarationName(refNode) && isImplementation(refNode.parent)) {
                    addReference(refNode);
                    return;
                }
                if (refNode.kind !== 79 /* Identifier */) {
                    return;
                }
                if (refNode.parent.kind === 292 /* ShorthandPropertyAssignment */) {
                    // Go ahead and dereference the shorthand assignment by going to its definition
                    getReferenceEntriesForShorthandPropertyAssignment(refNode, state.checker, addReference);
                }
                // Check if the node is within an extends or implements clause
                var containingClass = getContainingClassIfInHeritageClause(refNode);
                if (containingClass) {
                    addReference(containingClass);
                    return;
                }
                // If we got a type reference, try and see if the reference applies to any expressions that can implement an interface
                // Find the first node whose parent isn't a type node -- i.e., the highest type node.
                var typeNode = ts.findAncestor(refNode, function (a) { return !ts.isQualifiedName(a.parent) && !ts.isTypeNode(a.parent) && !ts.isTypeElement(a.parent); });
                var typeHavingNode = typeNode.parent;
                if (ts.hasType(typeHavingNode) && typeHavingNode.type === typeNode && state.markSeenContainingTypeReference(typeHavingNode)) {
                    if (ts.hasInitializer(typeHavingNode)) {
                        addIfImplementation(typeHavingNode.initializer);
                    }
                    else if (ts.isFunctionLike(typeHavingNode) && typeHavingNode.body) {
                        var body = typeHavingNode.body;
                        if (body.kind === 233 /* Block */) {
                            ts.forEachReturnStatement(body, function (returnStatement) {
                                if (returnStatement.expression)
                                    addIfImplementation(returnStatement.expression);
                            });
                        }
                        else {
                            addIfImplementation(body);
                        }
                    }
                    else if (ts.isAssertionExpression(typeHavingNode)) {
                        addIfImplementation(typeHavingNode.expression);
                    }
                }
                function addIfImplementation(e) {
                    if (isImplementationExpression(e))
                        addReference(e);
                }
            }
            function getContainingClassIfInHeritageClause(node) {
                return ts.isIdentifier(node) || ts.isPropertyAccessExpression(node) ? getContainingClassIfInHeritageClause(node.parent)
                    : ts.isExpressionWithTypeArguments(node) ? ts.tryCast(node.parent.parent, ts.isClassLike) : undefined;
            }
            /**
             * Returns true if this is an expression that can be considered an implementation
             */
            function isImplementationExpression(node) {
                switch (node.kind) {
                    case 210 /* ParenthesizedExpression */:
                        return isImplementationExpression(node.expression);
                    case 212 /* ArrowFunction */:
                    case 211 /* FunctionExpression */:
                    case 203 /* ObjectLiteralExpression */:
                    case 224 /* ClassExpression */:
                    case 202 /* ArrayLiteralExpression */:
                        return true;
                    default:
                        return false;
                }
            }
            /**
             * Determines if the parent symbol occurs somewhere in the child's ancestry. If the parent symbol
             * is an interface, determines if some ancestor of the child symbol extends or inherits from it.
             * Also takes in a cache of previous results which makes this slightly more efficient and is
             * necessary to avoid potential loops like so:
             *     class A extends B { }
             *     class B extends A { }
             *
             * We traverse the AST rather than using the type checker because users are typically only interested
             * in explicit implementations of an interface/class when calling "Go to Implementation". Sibling
             * implementations of types that share a common ancestor with the type whose implementation we are
             * searching for need to be filtered out of the results. The type checker doesn't let us make the
             * distinction between structurally compatible implementations and explicit implementations, so we
             * must use the AST.
             *
             * @param symbol         A class or interface Symbol
             * @param parent        Another class or interface Symbol
             * @param cachedResults A map of symbol id pairs (i.e. "child,parent") to booleans indicating previous results
             */
            function explicitlyInheritsFrom(symbol, parent, cachedResults, checker) {
                if (symbol === parent) {
                    return true;
                }
                var key = ts.getSymbolId(symbol) + "," + ts.getSymbolId(parent);
                var cached = cachedResults.get(key);
                if (cached !== undefined) {
                    return cached;
                }
                // Set the key so that we don't infinitely recurse
                cachedResults.set(key, false);
                var inherits = !!symbol.declarations && symbol.declarations.some(function (declaration) {
                    return ts.getAllSuperTypeNodes(declaration).some(function (typeReference) {
                        var type = checker.getTypeAtLocation(typeReference);
                        return !!type && !!type.symbol && explicitlyInheritsFrom(type.symbol, parent, cachedResults, checker);
                    });
                });
                cachedResults.set(key, inherits);
                return inherits;
            }
            function getReferencesForSuperKeyword(superKeyword) {
                var searchSpaceNode = ts.getSuperContainer(superKeyword, /*stopOnFunctions*/ false);
                if (!searchSpaceNode) {
                    return undefined;
                }
                // Whether 'super' occurs in a static context within a class.
                var staticFlag = 32 /* Static */;
                switch (searchSpaceNode.kind) {
                    case 165 /* PropertyDeclaration */:
                    case 164 /* PropertySignature */:
                    case 167 /* MethodDeclaration */:
                    case 166 /* MethodSignature */:
                    case 169 /* Constructor */:
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                        staticFlag &= ts.getSyntacticModifierFlags(searchSpaceNode);
                        searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class
                        break;
                    default:
                        return undefined;
                }
                var sourceFile = searchSpaceNode.getSourceFile();
                var references = ts.mapDefined(getPossibleSymbolReferenceNodes(sourceFile, "super", searchSpaceNode), function (node) {
                    if (node.kind !== 106 /* SuperKeyword */) {
                        return;
                    }
                    var container = ts.getSuperContainer(node, /*stopOnFunctions*/ false);
                    // If we have a 'super' container, we must have an enclosing class.
                    // Now make sure the owning class is the same as the search-space
                    // and has the same static qualifier as the original 'super's owner.
                    return container && ts.isStatic(container) === !!staticFlag && container.parent.symbol === searchSpaceNode.symbol ? nodeEntry(node) : undefined;
                });
                return [{ definition: { type: 0 /* Symbol */, symbol: searchSpaceNode.symbol }, references: references }];
            }
            function isParameterName(node) {
                return node.kind === 79 /* Identifier */ && node.parent.kind === 162 /* Parameter */ && node.parent.name === node;
            }
            function getReferencesForThisKeyword(thisOrSuperKeyword, sourceFiles, cancellationToken) {
                var searchSpaceNode = ts.getThisContainer(thisOrSuperKeyword, /* includeArrowFunctions */ false);
                // Whether 'this' occurs in a static context within a class.
                var staticFlag = 32 /* Static */;
                switch (searchSpaceNode.kind) {
                    case 167 /* MethodDeclaration */:
                    case 166 /* MethodSignature */:
                        if (ts.isObjectLiteralMethod(searchSpaceNode)) {
                            staticFlag &= ts.getSyntacticModifierFlags(searchSpaceNode);
                            searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning object literals
                            break;
                        }
                    // falls through
                    case 165 /* PropertyDeclaration */:
                    case 164 /* PropertySignature */:
                    case 169 /* Constructor */:
                    case 170 /* GetAccessor */:
                    case 171 /* SetAccessor */:
                        staticFlag &= ts.getSyntacticModifierFlags(searchSpaceNode);
                        searchSpaceNode = searchSpaceNode.parent; // re-assign to be the owning class
                        break;
                    case 300 /* SourceFile */:
                        if (ts.isExternalModule(searchSpaceNode) || isParameterName(thisOrSuperKeyword)) {
                            return undefined;
                        }
                    // falls through
                    case 254 /* FunctionDeclaration */:
                    case 211 /* FunctionExpression */:
                        break;
                    // Computed properties in classes are not handled here because references to this are illegal,
                    // so there is no point finding references to them.
                    default:
                        return undefined;
                }
                var references = ts.flatMap(searchSpaceNode.kind === 300 /* SourceFile */ ? sourceFiles : [searchSpaceNode.getSourceFile()], function (sourceFile) {
                    cancellationToken.throwIfCancellationRequested();
                    return getPossibleSymbolReferenceNodes(sourceFile, "this", ts.isSourceFile(searchSpaceNode) ? sourceFile : searchSpaceNode).filter(function (node) {
                        if (!ts.isThis(node)) {
                            return false;
                        }
                        var container = ts.getThisContainer(node, /* includeArrowFunctions */ false);
                        switch (searchSpaceNode.kind) {
                            case 211 /* FunctionExpression */:
                            case 254 /* FunctionDeclaration */:
                                return searchSpaceNode.symbol === container.symbol;
                            case 167 /* MethodDeclaration */:
                            case 166 /* MethodSignature */:
                                return ts.isObjectLiteralMethod(searchSpaceNode) && searchSpaceNode.symbol === container.symbol;
                            case 224 /* ClassExpression */:
                            case 255 /* ClassDeclaration */:
                            case 203 /* ObjectLiteralExpression */:
                                // Make sure the container belongs to the same class/object literals
                                // and has the appropriate static modifier from the original container.
                                return container.parent && searchSpaceNode.symbol === container.parent.symbol && ts.isStatic(container) === !!staticFlag;
                            case 300 /* SourceFile */:
                                return container.kind === 300 /* SourceFile */ && !ts.isExternalModule(container) && !isParameterName(node);
                        }
                    });
                }).map(function (n) { return nodeEntry(n); });
                var thisParameter = ts.firstDefined(references, function (r) { return ts.isParameter(r.node.parent) ? r.node : undefined; });
                return [{
                        definition: { type: 3 /* This */, node: thisParameter || thisOrSuperKeyword },
                        references: references
                    }];
            }
            function getReferencesForStringLiteral(node, sourceFiles, checker, cancellationToken) {
                var type = ts.getContextualTypeOrAncestorTypeNodeType(node, checker);
                var references = ts.flatMap(sourceFiles, function (sourceFile) {
                    cancellationToken.throwIfCancellationRequested();
                    return ts.mapDefined(getPossibleSymbolReferenceNodes(sourceFile, node.text), function (ref) {
                        if (ts.isStringLiteralLike(ref) && ref.text === node.text) {
                            if (type) {
                                var refType = ts.getContextualTypeOrAncestorTypeNodeType(ref, checker);
                                if (type !== checker.getStringType() && type === refType) {
                                    return nodeEntry(ref, 2 /* StringLiteral */);
                                }
                            }
                            else {
                                return nodeEntry(ref, 2 /* StringLiteral */);
                            }
                        }
                    });
                });
                return [{
                        definition: { type: 4 /* String */, node: node },
                        references: references
                    }];
            }
            // For certain symbol kinds, we need to include other symbols in the search set.
            // This is not needed when searching for re-exports.
            function populateSearchSymbolSet(symbol, location, checker, isForRename, providePrefixAndSuffixText, implementations) {
                var result = [];
                forEachRelatedSymbol(symbol, location, checker, isForRename, !(isForRename && providePrefixAndSuffixText), function (sym, root, base) {
                    // static method/property and instance method/property might have the same name. Only include static or only include instance.
                    if (base) {
                        if (isStaticSymbol(symbol) !== isStaticSymbol(base)) {
                            base = undefined;
                        }
                    }
                    result.push(base || root || sym);
                }, 
                // when try to find implementation, implementations is true, and not allowed to find base class
                /*allowBaseTypes*/ function () { return !implementations; });
                return result;
            }
            /**
             * @param allowBaseTypes return true means it would try to find in base class or interface.
             */
            function forEachRelatedSymbol(symbol, location, checker, isForRenamePopulateSearchSymbolSet, onlyIncludeBindingElementAtReferenceLocation, 
            /**
             * @param baseSymbol This symbol means one property/mehtod from base class or interface when it is not null or undefined,
             */
            cbSymbol, allowBaseTypes) {
                var containingObjectLiteralElement = ts.getContainingObjectLiteralElement(location);
                if (containingObjectLiteralElement) {
                    /* Because in short-hand property assignment, location has two meaning : property name and as value of the property
                    * When we do findAllReference at the position of the short-hand property assignment, we would want to have references to position of
                    * property name and variable declaration of the identifier.
                    * Like in below example, when querying for all references for an identifier 'name', of the property assignment, the language service
                    * should show both 'name' in 'obj' and 'name' in variable declaration
                    *      const name = "Foo";
                    *      const obj = { name };
                    * In order to do that, we will populate the search set with the value symbol of the identifier as a value of the property assignment
                    * so that when matching with potential reference symbol, both symbols from property declaration and variable declaration
                    * will be included correctly.
                    */
                    var shorthandValueSymbol = checker.getShorthandAssignmentValueSymbol(location.parent); // gets the local symbol
                    if (shorthandValueSymbol && isForRenamePopulateSearchSymbolSet) {
                        // When renaming 'x' in `const o = { x }`, just rename the local variable, not the property.
                        return cbSymbol(shorthandValueSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, 3 /* SearchedLocalFoundProperty */);
                    }
                    // If the location is in a context sensitive location (i.e. in an object literal) try
                    // to get a contextual type for it, and add the property symbol from the contextual
                    // type to the search set
                    var contextualType = checker.getContextualType(containingObjectLiteralElement.parent);
                    var res_1 = contextualType && ts.firstDefined(ts.getPropertySymbolsFromContextualType(containingObjectLiteralElement, checker, contextualType, /*unionSymbolOk*/ true), function (sym) { return fromRoot(sym, 4 /* SearchedPropertyFoundLocal */); });
                    if (res_1)
                        return res_1;
                    // If the location is name of property symbol from object literal destructuring pattern
                    // Search the property symbol
                    //      for ( { property: p2 } of elems) { }
                    var propertySymbol = getPropertySymbolOfDestructuringAssignment(location, checker);
                    var res1 = propertySymbol && cbSymbol(propertySymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, 4 /* SearchedPropertyFoundLocal */);
                    if (res1)
                        return res1;
                    var res2 = shorthandValueSymbol && cbSymbol(shorthandValueSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, 3 /* SearchedLocalFoundProperty */);
                    if (res2)
                        return res2;
                }
                var aliasedSymbol = getMergedAliasedSymbolOfNamespaceExportDeclaration(location, symbol, checker);
                if (aliasedSymbol) {
                    // In case of UMD module and global merging, search for global as well
                    var res_2 = cbSymbol(aliasedSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, 1 /* Node */);
                    if (res_2)
                        return res_2;
                }
                var res = fromRoot(symbol);
                if (res)
                    return res;
                if (symbol.valueDeclaration && ts.isParameterPropertyDeclaration(symbol.valueDeclaration, symbol.valueDeclaration.parent)) {
                    // For a parameter property, now try on the other symbol (property if this was a parameter, parameter if this was a property).
                    var paramProps = checker.getSymbolsOfParameterPropertyDeclaration(ts.cast(symbol.valueDeclaration, ts.isParameter), symbol.name);
                    ts.Debug.assert(paramProps.length === 2 && !!(paramProps[0].flags & 1 /* FunctionScopedVariable */) && !!(paramProps[1].flags & 4 /* Property */)); // is [parameter, property]
                    return fromRoot(symbol.flags & 1 /* FunctionScopedVariable */ ? paramProps[1] : paramProps[0]);
                }
                var exportSpecifier = ts.getDeclarationOfKind(symbol, 273 /* ExportSpecifier */);
                if (!isForRenamePopulateSearchSymbolSet || exportSpecifier && !exportSpecifier.propertyName) {
                    var localSymbol = exportSpecifier && checker.getExportSpecifierLocalTargetSymbol(exportSpecifier);
                    if (localSymbol) {
                        var res_3 = cbSymbol(localSymbol, /*rootSymbol*/ undefined, /*baseSymbol*/ undefined, 1 /* Node */);
                        if (res_3)
                            return res_3;
                    }
                }
                // symbolAtLocation for a binding element is the local symbol. See if the search symbol is the property.
                // Don't do this when populating search set for a rename when prefix and suffix text will be provided -- just rename the local.
                if (!isForRenamePopulateSearchSymbolSet) {
                    var bindingElementPropertySymbol = void 0;
                    if (onlyIncludeBindingElementAtReferenceLocation) {
                        bindingElementPropertySymbol = ts.isObjectBindingElementWithoutPropertyName(location.parent) ? ts.getPropertySymbolFromBindingElement(checker, location.parent) : undefined;
                    }
                    else {
                        bindingElementPropertySymbol = getPropertySymbolOfObjectBindingPatternWithoutPropertyName(symbol, checker);
                    }
                    return bindingElementPropertySymbol && fromRoot(bindingElementPropertySymbol, 4 /* SearchedPropertyFoundLocal */);
                }
                ts.Debug.assert(isForRenamePopulateSearchSymbolSet);
                // due to the above assert and the arguments at the uses of this function,
                // (onlyIncludeBindingElementAtReferenceLocation <=> !providePrefixAndSuffixTextForRename) holds
                var includeOriginalSymbolOfBindingElement = onlyIncludeBindingElementAtReferenceLocation;
                if (includeOriginalSymbolOfBindingElement) {
                    var bindingElementPropertySymbol = getPropertySymbolOfObjectBindingPatternWithoutPropertyName(symbol, checker);
                    return bindingElementPropertySymbol && fromRoot(bindingElementPropertySymbol, 4 /* SearchedPropertyFoundLocal */);
                }
                function fromRoot(sym, kind) {
                    // If this is a union property:
                    //   - In populateSearchSymbolsSet we will add all the symbols from all its source symbols in all unioned types.
                    //   - In findRelatedSymbol, we will just use the union symbol if any source symbol is included in the search.
                    // If the symbol is an instantiation from a another symbol (e.g. widened symbol):
                    //   - In populateSearchSymbolsSet, add the root the list
                    //   - In findRelatedSymbol, return the source symbol if that is in the search. (Do not return the instantiation symbol.)
                    return ts.firstDefined(checker.getRootSymbols(sym), function (rootSymbol) {
                        return cbSymbol(sym, rootSymbol, /*baseSymbol*/ undefined, kind)
                            // Add symbol of properties/methods of the same name in base classes and implemented interfaces definitions
                            || (rootSymbol.parent && rootSymbol.parent.flags & (32 /* Class */ | 64 /* Interface */) && allowBaseTypes(rootSymbol)
                                ? getPropertySymbolsFromBaseTypes(rootSymbol.parent, rootSymbol.name, checker, function (base) { return cbSymbol(sym, rootSymbol, base, kind); })
                                : undefined);
                    });
                }
                function getPropertySymbolOfObjectBindingPatternWithoutPropertyName(symbol, checker) {
                    var bindingElement = ts.getDeclarationOfKind(symbol, 201 /* BindingElement */);
                    if (bindingElement && ts.isObjectBindingElementWithoutPropertyName(bindingElement)) {
                        return ts.getPropertySymbolFromBindingElement(checker, bindingElement);
                    }
                }
            }
            /**
             * Find symbol of the given property-name and add the symbol to the given result array
             * @param symbol a symbol to start searching for the given propertyName
             * @param propertyName a name of property to search for
             * @param result an array of symbol of found property symbols
             * @param previousIterationSymbolsCache a cache of symbol from previous iterations of calling this function to prevent infinite revisiting of the same symbol.
             *                                The value of previousIterationSymbol is undefined when the function is first called.
             */
            function getPropertySymbolsFromBaseTypes(symbol, propertyName, checker, cb) {
                var seen = new ts.Map();
                return recur(symbol);
                function recur(symbol) {
                    // Use `addToSeen` to ensure we don't infinitely recurse in this situation:
                    //      interface C extends C {
                    //          /*findRef*/propName: string;
                    //      }
                    if (!(symbol.flags & (32 /* Class */ | 64 /* Interface */)) || !ts.addToSeen(seen, ts.getSymbolId(symbol)))
                        return;
                    return ts.firstDefined(symbol.declarations, function (declaration) { return ts.firstDefined(ts.getAllSuperTypeNodes(declaration), function (typeReference) {
                        var type = checker.getTypeAtLocation(typeReference);
                        var propertySymbol = type && type.symbol && checker.getPropertyOfType(type, propertyName);
                        // Visit the typeReference as well to see if it directly or indirectly uses that property
                        return type && propertySymbol && (ts.firstDefined(checker.getRootSymbols(propertySymbol), cb) || recur(type.symbol));
                    }); });
                }
            